var j_=Object.defineProperty;var N_=(ke,V,f)=>V in ke?j_(ke,V,{enumerable:!0,configurable:!0,writable:!0,value:f}):ke[V]=f;var Fe=(ke,V,f)=>N_(ke,typeof V!="symbol"?V+"":V,f);(function(){const V=document.createElement("link").relList;if(V&&V.supports&&V.supports("modulepreload"))return;for(const R of document.querySelectorAll('link[rel="modulepreload"]'))P(R);new MutationObserver(R=>{for(const Q of R)if(Q.type==="childList")for(const se of Q.addedNodes)se.tagName==="LINK"&&se.rel==="modulepreload"&&P(se)}).observe(document,{childList:!0,subtree:!0});function f(R){const Q={};return R.integrity&&(Q.integrity=R.integrity),R.referrerPolicy&&(Q.referrerPolicy=R.referrerPolicy),R.crossOrigin==="use-credentials"?Q.credentials="include":R.crossOrigin==="anonymous"?Q.credentials="omit":Q.credentials="same-origin",Q}function P(R){if(R.ep)return;R.ep=!0;const Q=f(R);fetch(R.href,Q)}})();var If={exports:{}},Dp={},Af={exports:{}},Pr={};/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var om;function U_(){if(om)return Pr;om=1;var ke=Symbol.for("react.element"),V=Symbol.for("react.portal"),f=Symbol.for("react.fragment"),P=Symbol.for("react.strict_mode"),R=Symbol.for("react.profiler"),Q=Symbol.for("react.provider"),se=Symbol.for("react.context"),oe=Symbol.for("react.forward_ref"),E=Symbol.for("react.suspense"),C=Symbol.for("react.memo"),k=Symbol.for("react.lazy"),A=Symbol.iterator;function $(ee){return ee===null||typeof ee!="object"?null:(ee=A&&ee[A]||ee["@@iterator"],typeof ee=="function"?ee:null)}var ae={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},fe=Object.assign,ge={};function le(ee,Te,je){this.props=ee,this.context=Te,this.refs=ge,this.updater=je||ae}le.prototype.isReactComponent={},le.prototype.setState=function(ee,Te){if(typeof ee!="object"&&typeof ee!="function"&&ee!=null)throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");this.updater.enqueueSetState(this,ee,Te,"setState")},le.prototype.forceUpdate=function(ee){this.updater.enqueueForceUpdate(this,ee,"forceUpdate")};function q(){}q.prototype=le.prototype;function ie(ee,Te,je){this.props=ee,this.context=Te,this.refs=ge,this.updater=je||ae}var pe=ie.prototype=new q;pe.constructor=ie,fe(pe,le.prototype),pe.isPureReactComponent=!0;var X=Array.isArray,W=Object.prototype.hasOwnProperty,b={current:null},z={key:!0,ref:!0,__self:!0,__source:!0};function L(ee,Te,je){var qe,tt={},he=null,Ve=null;if(Te!=null)for(qe in Te.ref!==void 0&&(Ve=Te.ref),Te.key!==void 0&&(he=""+Te.key),Te)W.call(Te,qe)&&!z.hasOwnProperty(qe)&&(tt[qe]=Te[qe]);var Je=arguments.length-2;if(Je===1)tt.children=je;else if(1<Je){for(var We=Array(Je),be=0;be<Je;be++)We[be]=arguments[be+2];tt.children=We}if(ee&&ee.defaultProps)for(qe in Je=ee.defaultProps,Je)tt[qe]===void 0&&(tt[qe]=Je[qe]);return{$$typeof:ke,type:ee,key:he,ref:Ve,props:tt,_owner:b.current}}function de(ee,Te){return{$$typeof:ke,type:ee.type,key:Te,ref:ee.ref,props:ee.props,_owner:ee._owner}}function ce(ee){return typeof ee=="object"&&ee!==null&&ee.$$typeof===ke}function Pe(ee){var Te={"=":"=0",":":"=2"};return"$"+ee.replace(/[=:]/g,function(je){return Te[je]})}var Ee=/\/+/g;function Se(ee,Te){return typeof ee=="object"&&ee!==null&&ee.key!=null?Pe(""+ee.key):Te.toString(36)}function Be(ee,Te,je,qe,tt){var he=typeof ee;(he==="undefined"||he==="boolean")&&(ee=null);var Ve=!1;if(ee===null)Ve=!0;else switch(he){case"string":case"number":Ve=!0;break;case"object":switch(ee.$$typeof){case ke:case V:Ve=!0}}if(Ve)return Ve=ee,tt=tt(Ve),ee=qe===""?"."+Se(Ve,0):qe,X(tt)?(je="",ee!=null&&(je=ee.replace(Ee,"$&/")+"/"),Be(tt,Te,je,"",function(be){return be})):tt!=null&&(ce(tt)&&(tt=de(tt,je+(!tt.key||Ve&&Ve.key===tt.key?"":(""+tt.key).replace(Ee,"$&/")+"/")+ee)),Te.push(tt)),1;if(Ve=0,qe=qe===""?".":qe+":",X(ee))for(var Je=0;Je<ee.length;Je++){he=ee[Je];var We=qe+Se(he,Je);Ve+=Be(he,Te,je,We,tt)}else if(We=$(ee),typeof We=="function")for(ee=We.call(ee),Je=0;!(he=ee.next()).done;)he=he.value,We=qe+Se(he,Je++),Ve+=Be(he,Te,je,We,tt);else if(he==="object")throw Te=String(ee),Error("Objects are not valid as a React child (found: "+(Te==="[object Object]"?"object with keys {"+Object.keys(ee).join(", ")+"}":Te)+"). If you meant to render a collection of children, use an array instead.");return Ve}function Le(ee,Te,je){if(ee==null)return ee;var qe=[],tt=0;return Be(ee,qe,"","",function(he){return Te.call(je,he,tt++)}),qe}function He(ee){if(ee._status===-1){var Te=ee._result;Te=Te(),Te.then(function(je){(ee._status===0||ee._status===-1)&&(ee._status=1,ee._result=je)},function(je){(ee._status===0||ee._status===-1)&&(ee._status=2,ee._result=je)}),ee._status===-1&&(ee._status=0,ee._result=Te)}if(ee._status===1)return ee._result.default;throw ee._result}var Me={current:null},N={transition:null},me={ReactCurrentDispatcher:Me,ReactCurrentBatchConfig:N,ReactCurrentOwner:b};function ue(){throw Error("act(...) is not supported in production builds of React.")}return Pr.Children={map:Le,forEach:function(ee,Te,je){Le(ee,function(){Te.apply(this,arguments)},je)},count:function(ee){var Te=0;return Le(ee,function(){Te++}),Te},toArray:function(ee){return Le(ee,function(Te){return Te})||[]},only:function(ee){if(!ce(ee))throw Error("React.Children.only expected to receive a single React element child.");return ee}},Pr.Component=le,Pr.Fragment=f,Pr.Profiler=R,Pr.PureComponent=ie,Pr.StrictMode=P,Pr.Suspense=E,Pr.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=me,Pr.act=ue,Pr.cloneElement=function(ee,Te,je){if(ee==null)throw Error("React.cloneElement(...): The argument must be a React element, but you passed "+ee+".");var qe=fe({},ee.props),tt=ee.key,he=ee.ref,Ve=ee._owner;if(Te!=null){if(Te.ref!==void 0&&(he=Te.ref,Ve=b.current),Te.key!==void 0&&(tt=""+Te.key),ee.type&&ee.type.defaultProps)var Je=ee.type.defaultProps;for(We in Te)W.call(Te,We)&&!z.hasOwnProperty(We)&&(qe[We]=Te[We]===void 0&&Je!==void 0?Je[We]:Te[We])}var We=arguments.length-2;if(We===1)qe.children=je;else if(1<We){Je=Array(We);for(var be=0;be<We;be++)Je[be]=arguments[be+2];qe.children=Je}return{$$typeof:ke,type:ee.type,key:tt,ref:he,props:qe,_owner:Ve}},Pr.createContext=function(ee){return ee={$$typeof:se,_currentValue:ee,_currentValue2:ee,_threadCount:0,Provider:null,Consumer:null,_defaultValue:null,_globalName:null},ee.Provider={$$typeof:Q,_context:ee},ee.Consumer=ee},Pr.createElement=L,Pr.createFactory=function(ee){var Te=L.bind(null,ee);return Te.type=ee,Te},Pr.createRef=function(){return{current:null}},Pr.forwardRef=function(ee){return{$$typeof:oe,render:ee}},Pr.isValidElement=ce,Pr.lazy=function(ee){return{$$typeof:k,_payload:{_status:-1,_result:ee},_init:He}},Pr.memo=function(ee,Te){return{$$typeof:C,type:ee,compare:Te===void 0?null:Te}},Pr.startTransition=function(ee){var Te=N.transition;N.transition={};try{ee()}finally{N.transition=Te}},Pr.unstable_act=ue,Pr.useCallback=function(ee,Te){return Me.current.useCallback(ee,Te)},Pr.useContext=function(ee){return Me.current.useContext(ee)},Pr.useDebugValue=function(){},Pr.useDeferredValue=function(ee){return Me.current.useDeferredValue(ee)},Pr.useEffect=function(ee,Te){return Me.current.useEffect(ee,Te)},Pr.useId=function(){return Me.current.useId()},Pr.useImperativeHandle=function(ee,Te,je){return Me.current.useImperativeHandle(ee,Te,je)},Pr.useInsertionEffect=function(ee,Te){return Me.current.useInsertionEffect(ee,Te)},Pr.useLayoutEffect=function(ee,Te){return Me.current.useLayoutEffect(ee,Te)},Pr.useMemo=function(ee,Te){return Me.current.useMemo(ee,Te)},Pr.useReducer=function(ee,Te,je){return Me.current.useReducer(ee,Te,je)},Pr.useRef=function(ee){return Me.current.useRef(ee)},Pr.useState=function(ee){return Me.current.useState(ee)},Pr.useSyncExternalStore=function(ee,Te,je){return Me.current.useSyncExternalStore(ee,Te,je)},Pr.useTransition=function(){return Me.current.useTransition()},Pr.version="18.3.1",Pr}var im;function jf(){return im||(im=1,Af.exports=U_()),Af.exports}/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var am;function V_(){if(am)return Dp;am=1;var ke=jf(),V=Symbol.for("react.element"),f=Symbol.for("react.fragment"),P=Object.prototype.hasOwnProperty,R=ke.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,Q={key:!0,ref:!0,__self:!0,__source:!0};function se(oe,E,C){var k,A={},$=null,ae=null;C!==void 0&&($=""+C),E.key!==void 0&&($=""+E.key),E.ref!==void 0&&(ae=E.ref);for(k in E)P.call(E,k)&&!Q.hasOwnProperty(k)&&(A[k]=E[k]);if(oe&&oe.defaultProps)for(k in E=oe.defaultProps,E)A[k]===void 0&&(A[k]=E[k]);return{$$typeof:V,type:oe,key:$,ref:ae,props:A,_owner:R.current}}return Dp.Fragment=f,Dp.jsx=se,Dp.jsxs=se,Dp}var lm;function W_(){return lm||(lm=1,If.exports=V_()),If.exports}var Mr=W_(),nf={},Ff={exports:{}},ko={},Of={exports:{}},Lf={};/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var um;function G_(){return um||(um=1,function(ke){function V(N,me){var ue=N.length;N.push(me);e:for(;0<ue;){var ee=ue-1>>>1,Te=N[ee];if(0<R(Te,me))N[ee]=me,N[ue]=Te,ue=ee;else break e}}function f(N){return N.length===0?null:N[0]}function P(N){if(N.length===0)return null;var me=N[0],ue=N.pop();if(ue!==me){N[0]=ue;e:for(var ee=0,Te=N.length,je=Te>>>1;ee<je;){var qe=2*(ee+1)-1,tt=N[qe],he=qe+1,Ve=N[he];if(0>R(tt,ue))he<Te&&0>R(Ve,tt)?(N[ee]=Ve,N[he]=ue,ee=he):(N[ee]=tt,N[qe]=ue,ee=qe);else if(he<Te&&0>R(Ve,ue))N[ee]=Ve,N[he]=ue,ee=he;else break e}}return me}function R(N,me){var ue=N.sortIndex-me.sortIndex;return ue!==0?ue:N.id-me.id}if(typeof performance=="object"&&typeof performance.now=="function"){var Q=performance;ke.unstable_now=function(){return Q.now()}}else{var se=Date,oe=se.now();ke.unstable_now=function(){return se.now()-oe}}var E=[],C=[],k=1,A=null,$=3,ae=!1,fe=!1,ge=!1,le=typeof setTimeout=="function"?setTimeout:null,q=typeof clearTimeout=="function"?clearTimeout:null,ie=typeof setImmediate<"u"?setImmediate:null;typeof navigator<"u"&&navigator.scheduling!==void 0&&navigator.scheduling.isInputPending!==void 0&&navigator.scheduling.isInputPending.bind(navigator.scheduling);function pe(N){for(var me=f(C);me!==null;){if(me.callback===null)P(C);else if(me.startTime<=N)P(C),me.sortIndex=me.expirationTime,V(E,me);else break;me=f(C)}}function X(N){if(ge=!1,pe(N),!fe)if(f(E)!==null)fe=!0,He(W);else{var me=f(C);me!==null&&Me(X,me.startTime-N)}}function W(N,me){fe=!1,ge&&(ge=!1,q(L),L=-1),ae=!0;var ue=$;try{for(pe(me),A=f(E);A!==null&&(!(A.expirationTime>me)||N&&!Pe());){var ee=A.callback;if(typeof ee=="function"){A.callback=null,$=A.priorityLevel;var Te=ee(A.expirationTime<=me);me=ke.unstable_now(),typeof Te=="function"?A.callback=Te:A===f(E)&&P(E),pe(me)}else P(E);A=f(E)}if(A!==null)var je=!0;else{var qe=f(C);qe!==null&&Me(X,qe.startTime-me),je=!1}return je}finally{A=null,$=ue,ae=!1}}var b=!1,z=null,L=-1,de=5,ce=-1;function Pe(){return!(ke.unstable_now()-ce<de)}function Ee(){if(z!==null){var N=ke.unstable_now();ce=N;var me=!0;try{me=z(!0,N)}finally{me?Se():(b=!1,z=null)}}else b=!1}var Se;if(typeof ie=="function")Se=function(){ie(Ee)};else if(typeof MessageChannel<"u"){var Be=new MessageChannel,Le=Be.port2;Be.port1.onmessage=Ee,Se=function(){Le.postMessage(null)}}else Se=function(){le(Ee,0)};function He(N){z=N,b||(b=!0,Se())}function Me(N,me){L=le(function(){N(ke.unstable_now())},me)}ke.unstable_IdlePriority=5,ke.unstable_ImmediatePriority=1,ke.unstable_LowPriority=4,ke.unstable_NormalPriority=3,ke.unstable_Profiling=null,ke.unstable_UserBlockingPriority=2,ke.unstable_cancelCallback=function(N){N.callback=null},ke.unstable_continueExecution=function(){fe||ae||(fe=!0,He(W))},ke.unstable_forceFrameRate=function(N){0>N||125<N?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):de=0<N?Math.floor(1e3/N):5},ke.unstable_getCurrentPriorityLevel=function(){return $},ke.unstable_getFirstCallbackNode=function(){return f(E)},ke.unstable_next=function(N){switch($){case 1:case 2:case 3:var me=3;break;default:me=$}var ue=$;$=me;try{return N()}finally{$=ue}},ke.unstable_pauseExecution=function(){},ke.unstable_requestPaint=function(){},ke.unstable_runWithPriority=function(N,me){switch(N){case 1:case 2:case 3:case 4:case 5:break;default:N=3}var ue=$;$=N;try{return me()}finally{$=ue}},ke.unstable_scheduleCallback=function(N,me,ue){var ee=ke.unstable_now();switch(typeof ue=="object"&&ue!==null?(ue=ue.delay,ue=typeof ue=="number"&&0<ue?ee+ue:ee):ue=ee,N){case 1:var Te=-1;break;case 2:Te=250;break;case 5:Te=1073741823;break;case 4:Te=1e4;break;default:Te=5e3}return Te=ue+Te,N={id:k++,callback:me,priorityLevel:N,startTime:ue,expirationTime:Te,sortIndex:-1},ue>ee?(N.sortIndex=ue,V(C,N),f(E)===null&&N===f(C)&&(ge?(q(L),L=-1):ge=!0,Me(X,ue-ee))):(N.sortIndex=Te,V(E,N),fe||ae||(fe=!0,He(W))),N},ke.unstable_shouldYield=Pe,ke.unstable_wrapCallback=function(N){var me=$;return function(){var ue=$;$=me;try{return N.apply(this,arguments)}finally{$=ue}}}}(Lf)),Lf}var cm;function K_(){return cm||(cm=1,Of.exports=G_()),Of.exports}/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var dm;function H_(){if(dm)return ko;dm=1;var ke=jf(),V=K_();function f(t){for(var n="https://reactjs.org/docs/error-decoder.html?invariant="+t,o=1;o<arguments.length;o++)n+="&args[]="+encodeURIComponent(arguments[o]);return"Minified React error #"+t+"; visit "+n+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}var P=new Set,R={};function Q(t,n){se(t,n),se(t+"Capture",n)}function se(t,n){for(R[t]=n,t=0;t<n.length;t++)P.add(n[t])}var oe=!(typeof window>"u"||typeof window.document>"u"||typeof window.document.createElement>"u"),E=Object.prototype.hasOwnProperty,C=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,k={},A={};function $(t){return E.call(A,t)?!0:E.call(k,t)?!1:C.test(t)?A[t]=!0:(k[t]=!0,!1)}function ae(t,n,o,u){if(o!==null&&o.type===0)return!1;switch(typeof n){case"function":case"symbol":return!0;case"boolean":return u?!1:o!==null?!o.acceptsBooleans:(t=t.toLowerCase().slice(0,5),t!=="data-"&&t!=="aria-");default:return!1}}function fe(t,n,o,u){if(n===null||typeof n>"u"||ae(t,n,o,u))return!0;if(u)return!1;if(o!==null)switch(o.type){case 3:return!n;case 4:return n===!1;case 5:return isNaN(n);case 6:return isNaN(n)||1>n}return!1}function ge(t,n,o,u,m,M,K){this.acceptsBooleans=n===2||n===3||n===4,this.attributeName=u,this.attributeNamespace=m,this.mustUseProperty=o,this.propertyName=t,this.type=n,this.sanitizeURL=M,this.removeEmptyString=K}var le={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(t){le[t]=new ge(t,0,!1,t,null,!1,!1)}),[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(t){var n=t[0];le[n]=new ge(n,1,!1,t[1],null,!1,!1)}),["contentEditable","draggable","spellCheck","value"].forEach(function(t){le[t]=new ge(t,2,!1,t.toLowerCase(),null,!1,!1)}),["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(t){le[t]=new ge(t,2,!1,t,null,!1,!1)}),"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(t){le[t]=new ge(t,3,!1,t.toLowerCase(),null,!1,!1)}),["checked","multiple","muted","selected"].forEach(function(t){le[t]=new ge(t,3,!0,t,null,!1,!1)}),["capture","download"].forEach(function(t){le[t]=new ge(t,4,!1,t,null,!1,!1)}),["cols","rows","size","span"].forEach(function(t){le[t]=new ge(t,6,!1,t,null,!1,!1)}),["rowSpan","start"].forEach(function(t){le[t]=new ge(t,5,!1,t.toLowerCase(),null,!1,!1)});var q=/[\-:]([a-z])/g;function ie(t){return t[1].toUpperCase()}"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(t){var n=t.replace(q,ie);le[n]=new ge(n,1,!1,t,null,!1,!1)}),"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(t){var n=t.replace(q,ie);le[n]=new ge(n,1,!1,t,"http://www.w3.org/1999/xlink",!1,!1)}),["xml:base","xml:lang","xml:space"].forEach(function(t){var n=t.replace(q,ie);le[n]=new ge(n,1,!1,t,"http://www.w3.org/XML/1998/namespace",!1,!1)}),["tabIndex","crossOrigin"].forEach(function(t){le[t]=new ge(t,1,!1,t.toLowerCase(),null,!1,!1)}),le.xlinkHref=new ge("xlinkHref",1,!1,"xlink:href","http://www.w3.org/1999/xlink",!0,!1),["src","href","action","formAction"].forEach(function(t){le[t]=new ge(t,1,!1,t.toLowerCase(),null,!0,!0)});function pe(t,n,o,u){var m=le.hasOwnProperty(n)?le[n]:null;(m!==null?m.type!==0:u||!(2<n.length)||n[0]!=="o"&&n[0]!=="O"||n[1]!=="n"&&n[1]!=="N")&&(fe(n,o,m,u)&&(o=null),u||m===null?$(n)&&(o===null?t.removeAttribute(n):t.setAttribute(n,""+o)):m.mustUseProperty?t[m.propertyName]=o===null?m.type===3?!1:"":o:(n=m.attributeName,u=m.attributeNamespace,o===null?t.removeAttribute(n):(m=m.type,o=m===3||m===4&&o===!0?"":""+o,u?t.setAttributeNS(u,n,o):t.setAttribute(n,o))))}var X=ke.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,W=Symbol.for("react.element"),b=Symbol.for("react.portal"),z=Symbol.for("react.fragment"),L=Symbol.for("react.strict_mode"),de=Symbol.for("react.profiler"),ce=Symbol.for("react.provider"),Pe=Symbol.for("react.context"),Ee=Symbol.for("react.forward_ref"),Se=Symbol.for("react.suspense"),Be=Symbol.for("react.suspense_list"),Le=Symbol.for("react.memo"),He=Symbol.for("react.lazy"),Me=Symbol.for("react.offscreen"),N=Symbol.iterator;function me(t){return t===null||typeof t!="object"?null:(t=N&&t[N]||t["@@iterator"],typeof t=="function"?t:null)}var ue=Object.assign,ee;function Te(t){if(ee===void 0)try{throw Error()}catch(o){var n=o.stack.trim().match(/\n( *(at )?)/);ee=n&&n[1]||""}return`
`+ee+t}var je=!1;function qe(t,n){if(!t||je)return"";je=!0;var o=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{if(n)if(n=function(){throw Error()},Object.defineProperty(n.prototype,"props",{set:function(){throw Error()}}),typeof Reflect=="object"&&Reflect.construct){try{Reflect.construct(n,[])}catch(s){var u=s}Reflect.construct(t,[],n)}else{try{n.call()}catch(s){u=s}t.call(n.prototype)}else{try{throw Error()}catch(s){u=s}t()}}catch(s){if(s&&u&&typeof s.stack=="string"){for(var m=s.stack.split(`
`),M=u.stack.split(`
`),K=m.length-1,e=M.length-1;1<=K&&0<=e&&m[K]!==M[e];)e--;for(;1<=K&&0<=e;K--,e--)if(m[K]!==M[e]){if(K!==1||e!==1)do if(K--,e--,0>e||m[K]!==M[e]){var r=`
`+m[K].replace(" at new "," at ");return t.displayName&&r.includes("<anonymous>")&&(r=r.replace("<anonymous>",t.displayName)),r}while(1<=K&&0<=e);break}}}finally{je=!1,Error.prepareStackTrace=o}return(t=t?t.displayName||t.name:"")?Te(t):""}function tt(t){switch(t.tag){case 5:return Te(t.type);case 16:return Te("Lazy");case 13:return Te("Suspense");case 19:return Te("SuspenseList");case 0:case 2:case 15:return t=qe(t.type,!1),t;case 11:return t=qe(t.type.render,!1),t;case 1:return t=qe(t.type,!0),t;default:return""}}function he(t){if(t==null)return null;if(typeof t=="function")return t.displayName||t.name||null;if(typeof t=="string")return t;switch(t){case z:return"Fragment";case b:return"Portal";case de:return"Profiler";case L:return"StrictMode";case Se:return"Suspense";case Be:return"SuspenseList"}if(typeof t=="object")switch(t.$$typeof){case Pe:return(t.displayName||"Context")+".Consumer";case ce:return(t._context.displayName||"Context")+".Provider";case Ee:var n=t.render;return t=t.displayName,t||(t=n.displayName||n.name||"",t=t!==""?"ForwardRef("+t+")":"ForwardRef"),t;case Le:return n=t.displayName||null,n!==null?n:he(t.type)||"Memo";case He:n=t._payload,t=t._init;try{return he(t(n))}catch{}}return null}function Ve(t){var n=t.type;switch(t.tag){case 24:return"Cache";case 9:return(n.displayName||"Context")+".Consumer";case 10:return(n._context.displayName||"Context")+".Provider";case 18:return"DehydratedFragment";case 11:return t=n.render,t=t.displayName||t.name||"",n.displayName||(t!==""?"ForwardRef("+t+")":"ForwardRef");case 7:return"Fragment";case 5:return n;case 4:return"Portal";case 3:return"Root";case 6:return"Text";case 16:return he(n);case 8:return n===L?"StrictMode":"Mode";case 22:return"Offscreen";case 12:return"Profiler";case 21:return"Scope";case 13:return"Suspense";case 19:return"SuspenseList";case 25:return"TracingMarker";case 1:case 0:case 17:case 2:case 14:case 15:if(typeof n=="function")return n.displayName||n.name||null;if(typeof n=="string")return n}return null}function Je(t){switch(typeof t){case"boolean":case"number":case"string":case"undefined":return t;case"object":return t;default:return""}}function We(t){var n=t.type;return(t=t.nodeName)&&t.toLowerCase()==="input"&&(n==="checkbox"||n==="radio")}function be(t){var n=We(t)?"checked":"value",o=Object.getOwnPropertyDescriptor(t.constructor.prototype,n),u=""+t[n];if(!t.hasOwnProperty(n)&&typeof o<"u"&&typeof o.get=="function"&&typeof o.set=="function"){var m=o.get,M=o.set;return Object.defineProperty(t,n,{configurable:!0,get:function(){return m.call(this)},set:function(K){u=""+K,M.call(this,K)}}),Object.defineProperty(t,n,{enumerable:o.enumerable}),{getValue:function(){return u},setValue:function(K){u=""+K},stopTracking:function(){t._valueTracker=null,delete t[n]}}}}function Re(t){t._valueTracker||(t._valueTracker=be(t))}function lt(t){if(!t)return!1;var n=t._valueTracker;if(!n)return!0;var o=n.getValue(),u="";return t&&(u=We(t)?t.checked?"true":"false":t.value),t=u,t!==o?(n.setValue(t),!0):!1}function ot(t){if(t=t||(typeof document<"u"?document:void 0),typeof t>"u")return null;try{return t.activeElement||t.body}catch{return t.body}}function st(t,n){var o=n.checked;return ue({},n,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:o??t._wrapperState.initialChecked})}function Xe(t,n){var o=n.defaultValue==null?"":n.defaultValue,u=n.checked!=null?n.checked:n.defaultChecked;o=Je(n.value!=null?n.value:o),t._wrapperState={initialChecked:u,initialValue:o,controlled:n.type==="checkbox"||n.type==="radio"?n.checked!=null:n.value!=null}}function pt(t,n){n=n.checked,n!=null&&pe(t,"checked",n,!1)}function _t(t,n){pt(t,n);var o=Je(n.value),u=n.type;if(o!=null)u==="number"?(o===0&&t.value===""||t.value!=o)&&(t.value=""+o):t.value!==""+o&&(t.value=""+o);else if(u==="submit"||u==="reset"){t.removeAttribute("value");return}n.hasOwnProperty("value")?wt(t,n.type,o):n.hasOwnProperty("defaultValue")&&wt(t,n.type,Je(n.defaultValue)),n.checked==null&&n.defaultChecked!=null&&(t.defaultChecked=!!n.defaultChecked)}function Et(t,n,o){if(n.hasOwnProperty("value")||n.hasOwnProperty("defaultValue")){var u=n.type;if(!(u!=="submit"&&u!=="reset"||n.value!==void 0&&n.value!==null))return;n=""+t._wrapperState.initialValue,o||n===t.value||(t.value=n),t.defaultValue=n}o=t.name,o!==""&&(t.name=""),t.defaultChecked=!!t._wrapperState.initialChecked,o!==""&&(t.name=o)}function wt(t,n,o){(n!=="number"||ot(t.ownerDocument)!==t)&&(o==null?t.defaultValue=""+t._wrapperState.initialValue:t.defaultValue!==""+o&&(t.defaultValue=""+o))}var vt=Array.isArray;function U(t,n,o,u){if(t=t.options,n){n={};for(var m=0;m<o.length;m++)n["$"+o[m]]=!0;for(o=0;o<t.length;o++)m=n.hasOwnProperty("$"+t[o].value),t[o].selected!==m&&(t[o].selected=m),m&&u&&(t[o].defaultSelected=!0)}else{for(o=""+Je(o),n=null,m=0;m<t.length;m++){if(t[m].value===o){t[m].selected=!0,u&&(t[m].defaultSelected=!0);return}n!==null||t[m].disabled||(n=t[m])}n!==null&&(n.selected=!0)}}function _e(t,n){if(n.dangerouslySetInnerHTML!=null)throw Error(f(91));return ue({},n,{value:void 0,defaultValue:void 0,children:""+t._wrapperState.initialValue})}function Z(t,n){var o=n.value;if(o==null){if(o=n.children,n=n.defaultValue,o!=null){if(n!=null)throw Error(f(92));if(vt(o)){if(1<o.length)throw Error(f(93));o=o[0]}n=o}n==null&&(n=""),o=n}t._wrapperState={initialValue:Je(o)}}function xe(t,n){var o=Je(n.value),u=Je(n.defaultValue);o!=null&&(o=""+o,o!==t.value&&(t.value=o),n.defaultValue==null&&t.defaultValue!==o&&(t.defaultValue=o)),u!=null&&(t.defaultValue=""+u)}function Ne(t){var n=t.textContent;n===t._wrapperState.initialValue&&n!==""&&n!==null&&(t.value=n)}function at(t){switch(t){case"svg":return"http://www.w3.org/2000/svg";case"math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function ct(t,n){return t==null||t==="http://www.w3.org/1999/xhtml"?at(n):t==="http://www.w3.org/2000/svg"&&n==="foreignObject"?"http://www.w3.org/1999/xhtml":t}var gt,zt=function(t){return typeof MSApp<"u"&&MSApp.execUnsafeLocalFunction?function(n,o,u,m){MSApp.execUnsafeLocalFunction(function(){return t(n,o,u,m)})}:t}(function(t,n){if(t.namespaceURI!=="http://www.w3.org/2000/svg"||"innerHTML"in t)t.innerHTML=n;else{for(gt=gt||document.createElement("div"),gt.innerHTML="<svg>"+n.valueOf().toString()+"</svg>",n=gt.firstChild;t.firstChild;)t.removeChild(t.firstChild);for(;n.firstChild;)t.appendChild(n.firstChild)}});function $t(t,n){if(n){var o=t.firstChild;if(o&&o===t.lastChild&&o.nodeType===3){o.nodeValue=n;return}}t.textContent=n}var St={animationIterationCount:!0,aspectRatio:!0,borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},Ft=["Webkit","ms","Moz","O"];Object.keys(St).forEach(function(t){Ft.forEach(function(n){n=n+t.charAt(0).toUpperCase()+t.substring(1),St[n]=St[t]})});function gr(t,n,o){return n==null||typeof n=="boolean"||n===""?"":o||typeof n!="number"||n===0||St.hasOwnProperty(t)&&St[t]?(""+n).trim():n+"px"}function Cr(t,n){t=t.style;for(var o in n)if(n.hasOwnProperty(o)){var u=o.indexOf("--")===0,m=gr(o,n[o],u);o==="float"&&(o="cssFloat"),u?t.setProperty(o,m):t[o]=m}}var rn=ue({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0});function an(t,n){if(n){if(rn[t]&&(n.children!=null||n.dangerouslySetInnerHTML!=null))throw Error(f(137,t));if(n.dangerouslySetInnerHTML!=null){if(n.children!=null)throw Error(f(60));if(typeof n.dangerouslySetInnerHTML!="object"||!("__html"in n.dangerouslySetInnerHTML))throw Error(f(61))}if(n.style!=null&&typeof n.style!="object")throw Error(f(62))}}function Pn(t,n){if(t.indexOf("-")===-1)return typeof n.is=="string";switch(t){case"annotation-xml":case"color-profile":case"font-face":case"font-face-src":case"font-face-uri":case"font-face-format":case"font-face-name":case"missing-glyph":return!1;default:return!0}}var Ns=null;function Us(t){return t=t.target||t.srcElement||window,t.correspondingUseElement&&(t=t.correspondingUseElement),t.nodeType===3?t.parentNode:t}var Ps=null,Bn=null,Gt=null;function fs(t){if(t=Vi(t)){if(typeof Ps!="function")throw Error(f(280));var n=t.stateNode;n&&(n=Wi(n),Ps(t.stateNode,t.type,n))}}function Vs(t){Bn?Gt?Gt.push(t):Gt=[t]:Bn=t}function so(){if(Bn){var t=Bn,n=Gt;if(Gt=Bn=null,fs(t),n)for(t=0;t<n.length;t++)fs(n[t])}}function Io(t,n){return t(n)}function ts(){}var oo=!1;function io(t,n,o){if(oo)return t(n,o);oo=!0;try{return Io(t,n,o)}finally{oo=!1,(Bn!==null||Gt!==null)&&(ts(),so())}}function hs(t,n){var o=t.stateNode;if(o===null)return null;var u=Wi(o);if(u===null)return null;o=u[n];e:switch(n){case"onClick":case"onClickCapture":case"onDoubleClick":case"onDoubleClickCapture":case"onMouseDown":case"onMouseDownCapture":case"onMouseMove":case"onMouseMoveCapture":case"onMouseUp":case"onMouseUpCapture":case"onMouseEnter":(u=!u.disabled)||(t=t.type,u=!(t==="button"||t==="input"||t==="select"||t==="textarea")),t=!u;break e;default:t=!1}if(t)return null;if(o&&typeof o!="function")throw Error(f(231,n,typeof o));return o}var Cs=!1;if(oe)try{var Cn={};Object.defineProperty(Cn,"passive",{get:function(){Cs=!0}}),window.addEventListener("test",Cn,Cn),window.removeEventListener("test",Cn,Cn)}catch{Cs=!1}function dt(t,n,o,u,m,M,K,e,r){var s=Array.prototype.slice.call(arguments,3);try{n.apply(o,s)}catch(i){this.onError(i)}}var Pt=!1,jt=null,ln=!1,Ws=null,ao={onError:function(t){Pt=!0,jt=t}};function Dr(t,n,o,u,m,M,K,e,r){Pt=!1,jt=null,dt.apply(ao,arguments)}function rs(t,n,o,u,m,M,K,e,r){if(Dr.apply(this,arguments),Pt){if(Pt){var s=jt;Pt=!1,jt=null}else throw Error(f(198));ln||(ln=!0,Ws=s)}}function zr(t){var n=t,o=t;if(t.alternate)for(;n.return;)n=n.return;else{t=n;do n=t,n.flags&4098&&(o=n.return),t=n.return;while(t)}return n.tag===3?o:null}function Ss(t){if(t.tag===13){var n=t.memoizedState;if(n===null&&(t=t.alternate,t!==null&&(n=t.memoizedState)),n!==null)return n.dehydrated}return null}function Sr(t){if(zr(t)!==t)throw Error(f(188))}function lo(t){var n=t.alternate;if(!n){if(n=zr(t),n===null)throw Error(f(188));return n!==t?null:t}for(var o=t,u=n;;){var m=o.return;if(m===null)break;var M=m.alternate;if(M===null){if(u=m.return,u!==null){o=u;continue}break}if(m.child===M.child){for(M=m.child;M;){if(M===o)return Sr(m),t;if(M===u)return Sr(m),n;M=M.sibling}throw Error(f(188))}if(o.return!==u.return)o=m,u=M;else{for(var K=!1,e=m.child;e;){if(e===o){K=!0,o=m,u=M;break}if(e===u){K=!0,u=m,o=M;break}e=e.sibling}if(!K){for(e=M.child;e;){if(e===o){K=!0,o=M,u=m;break}if(e===u){K=!0,u=M,o=m;break}e=e.sibling}if(!K)throw Error(f(189))}}if(o.alternate!==u)throw Error(f(190))}if(o.tag!==3)throw Error(f(188));return o.stateNode.current===o?t:n}function Ei(t){return t=lo(t),t!==null?ha(t):null}function ha(t){if(t.tag===5||t.tag===6)return t;for(t=t.child;t!==null;){var n=ha(t);if(n!==null)return n;t=t.sibling}return null}var Pi=V.unstable_scheduleCallback,Ci=V.unstable_cancelCallback,uo=V.unstable_shouldYield,ma=V.unstable_requestPaint,Yr=V.unstable_now,il=V.unstable_getCurrentPriorityLevel,Gs=V.unstable_ImmediatePriority,ms=V.unstable_UserBlockingPriority,Rn=V.unstable_NormalPriority,Si=V.unstable_LowPriority,Ao=V.unstable_IdlePriority,co=null,jn=null;function po(t){if(jn&&typeof jn.onCommitFiberRoot=="function")try{jn.onCommitFiberRoot(co,t,void 0,(t.current.flags&128)===128)}catch{}}var Rt=Math.clz32?Math.clz32:ga,ki=Math.log,_a=Math.LN2;function ga(t){return t>>>=0,t===0?32:31-(ki(t)/_a|0)|0}var fo=64,Fo=4194304;function ho(t){switch(t&-t){case 1:return 1;case 2:return 2;case 4:return 4;case 8:return 8;case 16:return 16;case 32:return 32;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return t&4194240;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return t&130023424;case 134217728:return 134217728;case 268435456:return 268435456;case 536870912:return 536870912;case 1073741824:return 1073741824;default:return t}}function Ks(t,n){var o=t.pendingLanes;if(o===0)return 0;var u=0,m=t.suspendedLanes,M=t.pingedLanes,K=o&268435455;if(K!==0){var e=K&~m;e!==0?u=ho(e):(M&=K,M!==0&&(u=ho(M)))}else K=o&~m,K!==0?u=ho(K):M!==0&&(u=ho(M));if(u===0)return 0;if(n!==0&&n!==u&&!(n&m)&&(m=u&-u,M=n&-n,m>=M||m===16&&(M&4194240)!==0))return n;if(u&4&&(u|=o&16),n=t.entangledLanes,n!==0)for(t=t.entanglements,n&=u;0<n;)o=31-Rt(n),m=1<<o,u|=t[o],n&=~m;return u}function ya(t,n){switch(t){case 1:case 2:case 4:return n+250;case 8:case 16:case 32:case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return n+5e3;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return-1;case 134217728:case 268435456:case 536870912:case 1073741824:return-1;default:return-1}}function kr(t,n){for(var o=t.suspendedLanes,u=t.pingedLanes,m=t.expirationTimes,M=t.pendingLanes;0<M;){var K=31-Rt(M),e=1<<K,r=m[K];r===-1?(!(e&o)||e&u)&&(m[K]=ya(e,n)):r<=n&&(t.expiredLanes|=e),M&=~e}}function Oe(t){return t=t.pendingLanes&-1073741825,t!==0?t:t&1073741824?1073741824:0}function I(){var t=fo;return fo<<=1,!(fo&4194240)&&(fo=64),t}function ne(t){for(var n=[],o=0;31>o;o++)n.push(t);return n}function we(t,n,o){t.pendingLanes|=n,n!==536870912&&(t.suspendedLanes=0,t.pingedLanes=0),t=t.eventTimes,n=31-Rt(n),t[n]=o}function Ie(t,n){var o=t.pendingLanes&~n;t.pendingLanes=n,t.suspendedLanes=0,t.pingedLanes=0,t.expiredLanes&=n,t.mutableReadLanes&=n,t.entangledLanes&=n,n=t.entanglements;var u=t.eventTimes;for(t=t.expirationTimes;0<o;){var m=31-Rt(o),M=1<<m;n[m]=0,u[m]=-1,t[m]=-1,o&=~M}}function De(t,n){var o=t.entangledLanes|=n;for(t=t.entanglements;o;){var u=31-Rt(o),m=1<<u;m&n|t[u]&n&&(t[u]|=n),o&=~m}}var Ge=0;function mt(t){return t&=-t,1<t?4<t?t&268435455?16:536870912:4:1}var bt,yt,kt,Zt,xr,ar=!1,Fr=[],Ht=null,hr=null,fn=null,Nr=new Map,Qe=new Map,mr=[],Mn="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");function Qn(t,n){switch(t){case"focusin":case"focusout":Ht=null;break;case"dragenter":case"dragleave":hr=null;break;case"mouseover":case"mouseout":fn=null;break;case"pointerover":case"pointerout":Nr.delete(n.pointerId);break;case"gotpointercapture":case"lostpointercapture":Qe.delete(n.pointerId)}}function Nn(t,n,o,u,m,M){return t===null||t.nativeEvent!==M?(t={blockedOn:n,domEventName:o,eventSystemFlags:u,nativeEvent:M,targetContainers:[m]},n!==null&&(n=Vi(n),n!==null&&yt(n)),t):(t.eventSystemFlags|=u,n=t.targetContainers,m!==null&&n.indexOf(m)===-1&&n.push(m),t)}function qt(t,n,o,u,m){switch(n){case"focusin":return Ht=Nn(Ht,t,n,o,u,m),!0;case"dragenter":return hr=Nn(hr,t,n,o,u,m),!0;case"mouseover":return fn=Nn(fn,t,n,o,u,m),!0;case"pointerover":var M=m.pointerId;return Nr.set(M,Nn(Nr.get(M)||null,t,n,o,u,m)),!0;case"gotpointercapture":return M=m.pointerId,Qe.set(M,Nn(Qe.get(M)||null,t,n,o,u,m)),!0}return!1}function gn(t){var n=Ro(t.target);if(n!==null){var o=zr(n);if(o!==null){if(n=o.tag,n===13){if(n=Ss(o),n!==null){t.blockedOn=n,xr(t.priority,function(){kt(o)});return}}else if(n===3&&o.stateNode.current.memoizedState.isDehydrated){t.blockedOn=o.tag===3?o.stateNode.containerInfo:null;return}}}t.blockedOn=null}function Sn(t){if(t.blockedOn!==null)return!1;for(var n=t.targetContainers;0<n.length;){var o=Ut(t.domEventName,t.eventSystemFlags,n[0],t.nativeEvent);if(o===null){o=t.nativeEvent;var u=new o.constructor(o.type,o);Ns=u,o.target.dispatchEvent(u),Ns=null}else return n=Vi(o),n!==null&&yt(n),t.blockedOn=o,!1;n.shift()}return!0}function _r(t,n,o){Sn(t)&&o.delete(n)}function $r(){ar=!1,Ht!==null&&Sn(Ht)&&(Ht=null),hr!==null&&Sn(hr)&&(hr=null),fn!==null&&Sn(fn)&&(fn=null),Nr.forEach(_r),Qe.forEach(_r)}function Tt(t,n){t.blockedOn===n&&(t.blockedOn=null,ar||(ar=!0,V.unstable_scheduleCallback(V.unstable_NormalPriority,$r)))}function Jt(t){function n(m){return Tt(m,t)}if(0<Fr.length){Tt(Fr[0],t);for(var o=1;o<Fr.length;o++){var u=Fr[o];u.blockedOn===t&&(u.blockedOn=null)}}for(Ht!==null&&Tt(Ht,t),hr!==null&&Tt(hr,t),fn!==null&&Tt(fn,t),Nr.forEach(n),Qe.forEach(n),o=0;o<mr.length;o++)u=mr[o],u.blockedOn===t&&(u.blockedOn=null);for(;0<mr.length&&(o=mr[0],o.blockedOn===null);)gn(o),o.blockedOn===null&&mr.shift()}var Jr=X.ReactCurrentBatchConfig,ns=!0;function Hs(t,n,o,u){var m=Ge,M=Jr.transition;Jr.transition=null;try{Ge=1,$i(t,n,o,u)}finally{Ge=m,Jr.transition=M}}function Nt(t,n,o,u){var m=Ge,M=Jr.transition;Jr.transition=null;try{Ge=4,$i(t,n,o,u)}finally{Ge=m,Jr.transition=M}}function $i(t,n,o,u){if(ns){var m=Ut(t,n,o,u);if(m===null)Cl(t,n,u,it,o),Qn(t,u);else if(qt(m,t,n,o,u))u.stopPropagation();else if(Qn(t,u),n&4&&-1<Mn.indexOf(t)){for(;m!==null;){var M=Vi(m);if(M!==null&&bt(M),M=Ut(t,n,o,u),M===null&&Cl(t,n,u,it,o),M===m)break;m=M}m!==null&&u.stopPropagation()}else Cl(t,n,u,null,o)}}var it=null;function Ut(t,n,o,u){if(it=null,t=Us(u),t=Ro(t),t!==null)if(n=zr(t),n===null)t=null;else if(o=n.tag,o===13){if(t=Ss(n),t!==null)return t;t=null}else if(o===3){if(n.stateNode.current.memoizedState.isDehydrated)return n.tag===3?n.stateNode.containerInfo:null;t=null}else n!==t&&(t=null);return it=t,null}function al(t){switch(t){case"cancel":case"click":case"close":case"contextmenu":case"copy":case"cut":case"auxclick":case"dblclick":case"dragend":case"dragstart":case"drop":case"focusin":case"focusout":case"input":case"invalid":case"keydown":case"keypress":case"keyup":case"mousedown":case"mouseup":case"paste":case"pause":case"play":case"pointercancel":case"pointerdown":case"pointerup":case"ratechange":case"reset":case"resize":case"seeked":case"submit":case"touchcancel":case"touchend":case"touchstart":case"volumechange":case"change":case"selectionchange":case"textInput":case"compositionstart":case"compositionend":case"compositionupdate":case"beforeblur":case"afterblur":case"beforeinput":case"blur":case"fullscreenchange":case"focus":case"hashchange":case"popstate":case"select":case"selectstart":return 1;case"drag":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"mousemove":case"mouseout":case"mouseover":case"pointermove":case"pointerout":case"pointerover":case"scroll":case"toggle":case"touchmove":case"wheel":case"mouseenter":case"mouseleave":case"pointerenter":case"pointerleave":return 4;case"message":switch(il()){case Gs:return 1;case ms:return 4;case Rn:case Si:return 16;case Ao:return 536870912;default:return 16}default:return 16}}var qs=null,ll=null,Oo=null;function or(){if(Oo)return Oo;var t,n=ll,o=n.length,u,m="value"in qs?qs.value:qs.textContent,M=m.length;for(t=0;t<o&&n[t]===m[t];t++);var K=o-t;for(u=1;u<=K&&n[o-u]===m[M-u];u++);return Oo=m.slice(t,1<u?1-u:void 0)}function wa(t){var n=t.keyCode;return"charCode"in t?(t=t.charCode,t===0&&n===13&&(t=13)):t=n,t===10&&(t=13),32<=t||t===13?t:0}function Lo(){return!0}function vu(){return!1}function Xn(t){function n(o,u,m,M,K){this._reactName=o,this._targetInst=m,this.type=u,this.nativeEvent=M,this.target=K,this.currentTarget=null;for(var e in t)t.hasOwnProperty(e)&&(o=t[e],this[e]=o?o(M):M[e]);return this.isDefaultPrevented=(M.defaultPrevented!=null?M.defaultPrevented:M.returnValue===!1)?Lo:vu,this.isPropagationStopped=vu,this}return ue(n.prototype,{preventDefault:function(){this.defaultPrevented=!0;var o=this.nativeEvent;o&&(o.preventDefault?o.preventDefault():typeof o.returnValue!="unknown"&&(o.returnValue=!1),this.isDefaultPrevented=Lo)},stopPropagation:function(){var o=this.nativeEvent;o&&(o.stopPropagation?o.stopPropagation():typeof o.cancelBubble!="unknown"&&(o.cancelBubble=!0),this.isPropagationStopped=Lo)},persist:function(){},isPersistent:Lo}),n}var qo={eventPhase:0,bubbles:0,cancelable:0,timeStamp:function(t){return t.timeStamp||Date.now()},defaultPrevented:0,isTrusted:0},Un=Xn(qo),ks=ue({},qo,{view:0,detail:0}),ad=Xn(ks),mo,ul,va,Ma=ue({},ks,{screenX:0,screenY:0,clientX:0,clientY:0,pageX:0,pageY:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,getModifierState:hl,button:0,buttons:0,relatedTarget:function(t){return t.relatedTarget===void 0?t.fromElement===t.srcElement?t.toElement:t.fromElement:t.relatedTarget},movementX:function(t){return"movementX"in t?t.movementX:(t!==va&&(va&&t.type==="mousemove"?(mo=t.screenX-va.screenX,ul=t.screenY-va.screenY):ul=mo=0,va=t),mo)},movementY:function(t){return"movementY"in t?t.movementY:ul}}),cl=Xn(Ma),ld=ue({},Ma,{dataTransfer:0}),ud=Xn(ld),cd=ue({},ks,{relatedTarget:0}),dl=Xn(cd),dd=ue({},qo,{animationName:0,elapsedTime:0,pseudoElement:0}),pl=Xn(dd),$s=ue({},qo,{clipboardData:function(t){return"clipboardData"in t?t.clipboardData:window.clipboardData}}),pd=Xn($s),fd=ue({},qo,{data:0}),fl=Xn(fd),hd={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},md={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"},Mu={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"};function _d(t){var n=this.nativeEvent;return n.getModifierState?n.getModifierState(t):(t=Mu[t])?!!n[t]:!1}function hl(){return _d}var xu=ue({},ks,{key:function(t){if(t.key){var n=hd[t.key]||t.key;if(n!=="Unidentified")return n}return t.type==="keypress"?(t=wa(t),t===13?"Enter":String.fromCharCode(t)):t.type==="keydown"||t.type==="keyup"?md[t.keyCode]||"Unidentified":""},code:0,location:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,repeat:0,locale:0,getModifierState:hl,charCode:function(t){return t.type==="keypress"?wa(t):0},keyCode:function(t){return t.type==="keydown"||t.type==="keyup"?t.keyCode:0},which:function(t){return t.type==="keypress"?wa(t):t.type==="keydown"||t.type==="keyup"?t.keyCode:0}}),gd=Xn(xu),fp=ue({},Ma,{pointerId:0,width:0,height:0,pressure:0,tangentialPressure:0,tiltX:0,tiltY:0,twist:0,pointerType:0,isPrimary:0}),ss=Xn(fp),yd=ue({},ks,{touches:0,targetTouches:0,changedTouches:0,altKey:0,metaKey:0,ctrlKey:0,shiftKey:0,getModifierState:hl}),ml=Xn(yd),_l=ue({},qo,{propertyName:0,elapsedTime:0,pseudoElement:0}),Is=Xn(_l),wd=ue({},Ma,{deltaX:function(t){return"deltaX"in t?t.deltaX:"wheelDeltaX"in t?-t.wheelDeltaX:0},deltaY:function(t){return"deltaY"in t?t.deltaY:"wheelDeltaY"in t?-t.wheelDeltaY:"wheelDelta"in t?-t.wheelDelta:0},deltaZ:0,deltaMode:0}),Tu=Xn(wd),vd=[9,13,27,32],gl=oe&&"CompositionEvent"in window,Qo=null;oe&&"documentMode"in document&&(Qo=document.documentMode);var Md=oe&&"TextEvent"in window&&!Qo,bu=oe&&(!gl||Qo&&8<Qo&&11>=Qo),yl=" ",Eu=!1;function Pu(t,n){switch(t){case"keyup":return vd.indexOf(n.keyCode)!==-1;case"keydown":return n.keyCode!==229;case"keypress":case"mousedown":case"focusout":return!0;default:return!1}}function os(t){return t=t.detail,typeof t=="object"&&"data"in t?t.data:null}var Xo=!1;function xd(t,n){switch(t){case"compositionend":return os(n);case"keypress":return n.which!==32?null:(Eu=!0,yl);case"textInput":return t=n.data,t===yl&&Eu?null:t;default:return null}}function Cu(t,n){if(Xo)return t==="compositionend"||!gl&&Pu(t,n)?(t=or(),Oo=ll=qs=null,Xo=!1,t):null;switch(t){case"paste":return null;case"keypress":if(!(n.ctrlKey||n.altKey||n.metaKey)||n.ctrlKey&&n.altKey){if(n.char&&1<n.char.length)return n.char;if(n.which)return String.fromCharCode(n.which)}return null;case"compositionend":return bu&&n.locale!=="ko"?null:n.data;default:return null}}var Td={color:!0,date:!0,datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};function Su(t){var n=t&&t.nodeName&&t.nodeName.toLowerCase();return n==="input"?!!Td[t.type]:n==="textarea"}function wl(t,n,o,u){Vs(u),n=ji(n,"onChange"),0<n.length&&(o=new Un("onChange","change",null,o,u),t.push({event:o,listeners:n}))}var Ii=null,Ai=null;function ku(t){Hu(t,0)}function xa(t){var n=ti(t);if(lt(n))return t}function $u(t,n){if(t==="change")return n}var Ta=!1;if(oe){var vl;if(oe){var Ml="oninput"in document;if(!Ml){var ba=document.createElement("div");ba.setAttribute("oninput","return;"),Ml=typeof ba.oninput=="function"}vl=Ml}else vl=!1;Ta=vl&&(!document.documentMode||9<document.documentMode)}function bd(){Ii&&(Ii.detachEvent("onpropertychange",Iu),Ai=Ii=null)}function Iu(t){if(t.propertyName==="value"&&xa(Ai)){var n=[];wl(n,Ai,t,Us(t)),io(ku,n)}}function Au(t,n,o){t==="focusin"?(bd(),Ii=n,Ai=o,Ii.attachEvent("onpropertychange",Iu)):t==="focusout"&&bd()}function Ed(t){if(t==="selectionchange"||t==="keyup"||t==="keydown")return xa(Ai)}function Pd(t,n){if(t==="click")return xa(n)}function Fi(t,n){if(t==="input"||t==="change")return xa(n)}function Cd(t,n){return t===n&&(t!==0||1/t===1/n)||t!==t&&n!==n}var _s=typeof Object.is=="function"?Object.is:Cd;function Do(t,n){if(_s(t,n))return!0;if(typeof t!="object"||t===null||typeof n!="object"||n===null)return!1;var o=Object.keys(t),u=Object.keys(n);if(o.length!==u.length)return!1;for(u=0;u<o.length;u++){var m=o[u];if(!E.call(n,m)||!_s(t[m],n[m]))return!1}return!0}function Fu(t){for(;t&&t.firstChild;)t=t.firstChild;return t}function Ou(t,n){var o=Fu(t);t=0;for(var u;o;){if(o.nodeType===3){if(u=t+o.textContent.length,t<=n&&u>=n)return{node:o,offset:n-t};t=u}e:{for(;o;){if(o.nextSibling){o=o.nextSibling;break e}o=o.parentNode}o=void 0}o=Fu(o)}}function Lu(t,n){return t&&n?t===n?!0:t&&t.nodeType===3?!1:n&&n.nodeType===3?Lu(t,n.parentNode):"contains"in t?t.contains(n):t.compareDocumentPosition?!!(t.compareDocumentPosition(n)&16):!1:!1}function Du(){for(var t=window,n=ot();n instanceof t.HTMLIFrameElement;){try{var o=typeof n.contentWindow.location.href=="string"}catch{o=!1}if(o)t=n.contentWindow;else break;n=ot(t.document)}return n}function xl(t){var n=t&&t.nodeName&&t.nodeName.toLowerCase();return n&&(n==="input"&&(t.type==="text"||t.type==="search"||t.type==="tel"||t.type==="url"||t.type==="password")||n==="textarea"||t.contentEditable==="true")}function Sd(t){var n=Du(),o=t.focusedElem,u=t.selectionRange;if(n!==o&&o&&o.ownerDocument&&Lu(o.ownerDocument.documentElement,o)){if(u!==null&&xl(o)){if(n=u.start,t=u.end,t===void 0&&(t=n),"selectionStart"in o)o.selectionStart=n,o.selectionEnd=Math.min(t,o.value.length);else if(t=(n=o.ownerDocument||document)&&n.defaultView||window,t.getSelection){t=t.getSelection();var m=o.textContent.length,M=Math.min(u.start,m);u=u.end===void 0?M:Math.min(u.end,m),!t.extend&&M>u&&(m=u,u=M,M=m),m=Ou(o,M);var K=Ou(o,u);m&&K&&(t.rangeCount!==1||t.anchorNode!==m.node||t.anchorOffset!==m.offset||t.focusNode!==K.node||t.focusOffset!==K.offset)&&(n=n.createRange(),n.setStart(m.node,m.offset),t.removeAllRanges(),M>u?(t.addRange(n),t.extend(K.node,K.offset)):(n.setEnd(K.node,K.offset),t.addRange(n)))}}for(n=[],t=o;t=t.parentNode;)t.nodeType===1&&n.push({element:t,left:t.scrollLeft,top:t.scrollTop});for(typeof o.focus=="function"&&o.focus(),o=0;o<n.length;o++)t=n[o],t.element.scrollLeft=t.left,t.element.scrollTop=t.top}}var kd=oe&&"documentMode"in document&&11>=document.documentMode,zo=null,zu=null,Oi=null,wr=!1;function Bu(t,n,o){var u=o.window===o?o.document:o.nodeType===9?o:o.ownerDocument;wr||zo==null||zo!==ot(u)||(u=zo,"selectionStart"in u&&xl(u)?u={start:u.selectionStart,end:u.selectionEnd}:(u=(u.ownerDocument&&u.ownerDocument.defaultView||window).getSelection(),u={anchorNode:u.anchorNode,anchorOffset:u.anchorOffset,focusNode:u.focusNode,focusOffset:u.focusOffset}),Oi&&Do(Oi,u)||(Oi=u,u=ji(zu,"onSelect"),0<u.length&&(n=new Un("onSelect","select",null,n,o),t.push({event:n,listeners:u}),n.target=zo)))}function Ea(t,n){var o={};return o[t.toLowerCase()]=n.toLowerCase(),o["Webkit"+t]="webkit"+n,o["Moz"+t]="moz"+n,o}var Bo={animationend:Ea("Animation","AnimationEnd"),animationiteration:Ea("Animation","AnimationIteration"),animationstart:Ea("Animation","AnimationStart"),transitionend:Ea("Transition","TransitionEnd")},Tl={},Ru={};oe&&(Ru=document.createElement("div").style,"AnimationEvent"in window||(delete Bo.animationend.animation,delete Bo.animationiteration.animation,delete Bo.animationstart.animation),"TransitionEvent"in window||delete Bo.transitionend.transition);function Li(t){if(Tl[t])return Tl[t];if(!Bo[t])return t;var n=Bo[t],o;for(o in n)if(n.hasOwnProperty(o)&&o in Ru)return Tl[t]=n[o];return t}var ju=Li("animationend"),Nu=Li("animationiteration"),bl=Li("animationstart"),Uu=Li("transitionend"),Vu=new Map,Wu="abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");function _o(t,n){Vu.set(t,n),Q(n,[t])}for(var Pa=0;Pa<Wu.length;Pa++){var Yo=Wu[Pa],$d=Yo.toLowerCase(),El=Yo[0].toUpperCase()+Yo.slice(1);_o($d,"on"+El)}_o(ju,"onAnimationEnd"),_o(Nu,"onAnimationIteration"),_o(bl,"onAnimationStart"),_o("dblclick","onDoubleClick"),_o("focusin","onFocus"),_o("focusout","onBlur"),_o(Uu,"onTransitionEnd"),se("onMouseEnter",["mouseout","mouseover"]),se("onMouseLeave",["mouseout","mouseover"]),se("onPointerEnter",["pointerout","pointerover"]),se("onPointerLeave",["pointerout","pointerover"]),Q("onChange","change click focusin focusout input keydown keyup selectionchange".split(" ")),Q("onSelect","focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")),Q("onBeforeInput",["compositionend","keypress","textInput","paste"]),Q("onCompositionEnd","compositionend focusout keydown keypress keyup mousedown".split(" ")),Q("onCompositionStart","compositionstart focusout keydown keypress keyup mousedown".split(" ")),Q("onCompositionUpdate","compositionupdate focusout keydown keypress keyup mousedown".split(" "));var Di="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),Gu=new Set("cancel close invalid load scroll toggle".split(" ").concat(Di));function Ku(t,n,o){var u=t.type||"unknown-event";t.currentTarget=o,rs(u,n,void 0,t),t.currentTarget=null}function Hu(t,n){n=(n&4)!==0;for(var o=0;o<t.length;o++){var u=t[o],m=u.event;u=u.listeners;e:{var M=void 0;if(n)for(var K=u.length-1;0<=K;K--){var e=u[K],r=e.instance,s=e.currentTarget;if(e=e.listener,r!==M&&m.isPropagationStopped())break e;Ku(m,e,s),M=r}else for(K=0;K<u.length;K++){if(e=u[K],r=e.instance,s=e.currentTarget,e=e.listener,r!==M&&m.isPropagationStopped())break e;Ku(m,e,s),M=r}}}if(ln)throw t=Ws,ln=!1,Ws=null,t}function Gr(t,n){var o=n[Fl];o===void 0&&(o=n[Fl]=new Set);var u=t+"__bubble";o.has(u)||(qu(n,t,2,!1),o.add(u))}function Pl(t,n,o){var u=0;n&&(u|=4),qu(o,t,u,n)}var zi="_reactListening"+Math.random().toString(36).slice(2);function Bi(t){if(!t[zi]){t[zi]=!0,P.forEach(function(o){o!=="selectionchange"&&(Gu.has(o)||Pl(o,!1,t),Pl(o,!0,t))});var n=t.nodeType===9?t:t.ownerDocument;n===null||n[zi]||(n[zi]=!0,Pl("selectionchange",!1,n))}}function qu(t,n,o,u){switch(al(n)){case 1:var m=Hs;break;case 4:m=Nt;break;default:m=$i}o=m.bind(null,n,o,t),m=void 0,!Cs||n!=="touchstart"&&n!=="touchmove"&&n!=="wheel"||(m=!0),u?m!==void 0?t.addEventListener(n,o,{capture:!0,passive:m}):t.addEventListener(n,o,!0):m!==void 0?t.addEventListener(n,o,{passive:m}):t.addEventListener(n,o,!1)}function Cl(t,n,o,u,m){var M=u;if(!(n&1)&&!(n&2)&&u!==null)e:for(;;){if(u===null)return;var K=u.tag;if(K===3||K===4){var e=u.stateNode.containerInfo;if(e===m||e.nodeType===8&&e.parentNode===m)break;if(K===4)for(K=u.return;K!==null;){var r=K.tag;if((r===3||r===4)&&(r=K.stateNode.containerInfo,r===m||r.nodeType===8&&r.parentNode===m))return;K=K.return}for(;e!==null;){if(K=Ro(e),K===null)return;if(r=K.tag,r===5||r===6){u=M=K;continue e}e=e.parentNode}}u=u.return}io(function(){var s=M,i=Us(o),a=[];e:{var c=Vu.get(t);if(c!==void 0){var l=Un,h=t;switch(t){case"keypress":if(wa(o)===0)break e;case"keydown":case"keyup":l=gd;break;case"focusin":h="focus",l=dl;break;case"focusout":h="blur",l=dl;break;case"beforeblur":case"afterblur":l=dl;break;case"click":if(o.button===2)break e;case"auxclick":case"dblclick":case"mousedown":case"mousemove":case"mouseup":case"mouseout":case"mouseover":case"contextmenu":l=cl;break;case"drag":case"dragend":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"dragstart":case"drop":l=ud;break;case"touchcancel":case"touchend":case"touchmove":case"touchstart":l=ml;break;case ju:case Nu:case bl:l=pl;break;case Uu:l=Is;break;case"scroll":l=ad;break;case"wheel":l=Tu;break;case"copy":case"cut":case"paste":l=pd;break;case"gotpointercapture":case"lostpointercapture":case"pointercancel":case"pointerdown":case"pointermove":case"pointerout":case"pointerover":case"pointerup":l=ss}var _=(n&4)!==0,w=!_&&t==="scroll",v=_?c!==null?c+"Capture":null:c;_=[];for(var y=s,d;y!==null;){d=y;var S=d.stateNode;if(d.tag===5&&S!==null&&(d=S,v!==null&&(S=hs(y,v),S!=null&&_.push(Ri(y,S,d)))),w)break;y=y.return}0<_.length&&(c=new l(c,h,null,o,i),a.push({event:c,listeners:_}))}}if(!(n&7)){e:{if(c=t==="mouseover"||t==="pointerover",l=t==="mouseout"||t==="pointerout",c&&o!==Ns&&(h=o.relatedTarget||o.fromElement)&&(Ro(h)||h[yn]))break e;if((l||c)&&(c=i.window===i?i:(c=i.ownerDocument)?c.defaultView||c.parentWindow:window,l?(h=o.relatedTarget||o.toElement,l=s,h=h?Ro(h):null,h!==null&&(w=zr(h),h!==w||h.tag!==5&&h.tag!==6)&&(h=null)):(l=null,h=s),l!==h)){if(_=cl,S="onMouseLeave",v="onMouseEnter",y="mouse",(t==="pointerout"||t==="pointerover")&&(_=ss,S="onPointerLeave",v="onPointerEnter",y="pointer"),w=l==null?c:ti(l),d=h==null?c:ti(h),c=new _(S,y+"leave",l,o,i),c.target=w,c.relatedTarget=d,S=null,Ro(i)===s&&(_=new _(v,y+"enter",h,o,i),_.target=d,_.relatedTarget=w,S=_),w=S,l&&h)t:{for(_=l,v=h,y=0,d=_;d;d=Jo(d))y++;for(d=0,S=v;S;S=Jo(S))d++;for(;0<y-d;)_=Jo(_),y--;for(;0<d-y;)v=Jo(v),d--;for(;y--;){if(_===v||v!==null&&_===v.alternate)break t;_=Jo(_),v=Jo(v)}_=null}else _=null;l!==null&&Qu(a,c,l,_,!1),h!==null&&w!==null&&Qu(a,w,h,_,!0)}}e:{if(c=s?ti(s):window,l=c.nodeName&&c.nodeName.toLowerCase(),l==="select"||l==="input"&&c.type==="file")var B=$u;else if(Su(c))if(Ta)B=Fi;else{B=Ed;var j=Au}else(l=c.nodeName)&&l.toLowerCase()==="input"&&(c.type==="checkbox"||c.type==="radio")&&(B=Pd);if(B&&(B=B(t,s))){wl(a,B,o,i);break e}j&&j(t,c,s),t==="focusout"&&(j=c._wrapperState)&&j.controlled&&c.type==="number"&&wt(c,"number",c.value)}switch(j=s?ti(s):window,t){case"focusin":(Su(j)||j.contentEditable==="true")&&(zo=j,zu=s,Oi=null);break;case"focusout":Oi=zu=zo=null;break;case"mousedown":wr=!0;break;case"contextmenu":case"mouseup":case"dragend":wr=!1,Bu(a,o,i);break;case"selectionchange":if(kd)break;case"keydown":case"keyup":Bu(a,o,i)}var Y;if(gl)e:{switch(t){case"compositionstart":var te="onCompositionStart";break e;case"compositionend":te="onCompositionEnd";break e;case"compositionupdate":te="onCompositionUpdate";break e}te=void 0}else Xo?Pu(t,o)&&(te="onCompositionEnd"):t==="keydown"&&o.keyCode===229&&(te="onCompositionStart");te&&(bu&&o.locale!=="ko"&&(Xo||te!=="onCompositionStart"?te==="onCompositionEnd"&&Xo&&(Y=or()):(qs=i,ll="value"in qs?qs.value:qs.textContent,Xo=!0)),j=ji(s,te),0<j.length&&(te=new fl(te,t,null,o,i),a.push({event:te,listeners:j}),Y?te.data=Y:(Y=os(o),Y!==null&&(te.data=Y)))),(Y=Md?xd(t,o):Cu(t,o))&&(s=ji(s,"onBeforeInput"),0<s.length&&(i=new fl("onBeforeInput","beforeinput",null,o,i),a.push({event:i,listeners:s}),i.data=Y))}Hu(a,n)})}function Ri(t,n,o){return{instance:t,listener:n,currentTarget:o}}function ji(t,n){for(var o=n+"Capture",u=[];t!==null;){var m=t,M=m.stateNode;m.tag===5&&M!==null&&(m=M,M=hs(t,o),M!=null&&u.unshift(Ri(t,M,m)),M=hs(t,n),M!=null&&u.push(Ri(t,M,m))),t=t.return}return u}function Jo(t){if(t===null)return null;do t=t.return;while(t&&t.tag!==5);return t||null}function Qu(t,n,o,u,m){for(var M=n._reactName,K=[];o!==null&&o!==u;){var e=o,r=e.alternate,s=e.stateNode;if(r!==null&&r===u)break;e.tag===5&&s!==null&&(e=s,m?(r=hs(o,M),r!=null&&K.unshift(Ri(o,r,e))):m||(r=hs(o,M),r!=null&&K.push(Ri(o,r,e)))),o=o.return}K.length!==0&&t.push({event:n,listeners:K})}var Xu=/\r\n?/g,Id=/\u0000|\uFFFD/g;function Sl(t){return(typeof t=="string"?t:""+t).replace(Xu,`
`).replace(Id,"")}function Ni(t,n,o){if(n=Sl(n),Sl(t)!==n&&o)throw Error(f(425))}function Ui(){}var Ca=null,Sa=null;function kl(t,n){return t==="textarea"||t==="noscript"||typeof n.children=="string"||typeof n.children=="number"||typeof n.dangerouslySetInnerHTML=="object"&&n.dangerouslySetInnerHTML!==null&&n.dangerouslySetInnerHTML.__html!=null}var $l=typeof setTimeout=="function"?setTimeout:void 0,Yu=typeof clearTimeout=="function"?clearTimeout:void 0,Ju=typeof Promise=="function"?Promise:void 0,Ad=typeof queueMicrotask=="function"?queueMicrotask:typeof Ju<"u"?function(t){return Ju.resolve(null).then(t).catch(ka)}:$l;function ka(t){setTimeout(function(){throw t})}function Il(t,n){var o=n,u=0;do{var m=o.nextSibling;if(t.removeChild(o),m&&m.nodeType===8)if(o=m.data,o==="/$"){if(u===0){t.removeChild(m),Jt(n);return}u--}else o!=="$"&&o!=="$?"&&o!=="$!"||u++;o=m}while(o);Jt(n)}function go(t){for(;t!=null;t=t.nextSibling){var n=t.nodeType;if(n===1||n===3)break;if(n===8){if(n=t.data,n==="$"||n==="$!"||n==="$?")break;if(n==="/$")return null}}return t}function Al(t){t=t.previousSibling;for(var n=0;t;){if(t.nodeType===8){var o=t.data;if(o==="$"||o==="$!"||o==="$?"){if(n===0)return t;n--}else o==="/$"&&n++}t=t.previousSibling}return null}var Zo=Math.random().toString(36).slice(2),As="__reactFiber$"+Zo,ei="__reactProps$"+Zo,yn="__reactContainer$"+Zo,Fl="__reactEvents$"+Zo,Fd="__reactListeners$"+Zo,Zu="__reactHandles$"+Zo;function Ro(t){var n=t[As];if(n)return n;for(var o=t.parentNode;o;){if(n=o[yn]||o[As]){if(o=n.alternate,n.child!==null||o!==null&&o.child!==null)for(t=Al(t);t!==null;){if(o=t[As])return o;t=Al(t)}return n}t=o,o=t.parentNode}return null}function Vi(t){return t=t[As]||t[yn],!t||t.tag!==5&&t.tag!==6&&t.tag!==13&&t.tag!==3?null:t}function ti(t){if(t.tag===5||t.tag===6)return t.stateNode;throw Error(f(33))}function Wi(t){return t[ei]||null}var Ol=[],ri=-1;function Qs(t){return{current:t}}function Zr(t){0>ri||(t.current=Ol[ri],Ol[ri]=null,ri--)}function Ur(t,n){ri++,Ol[ri]=t.current,t.current=n}var Xs={},kn=Qs(Xs),Vn=Qs(!1),yo=Xs;function ni(t,n){var o=t.type.contextTypes;if(!o)return Xs;var u=t.stateNode;if(u&&u.__reactInternalMemoizedUnmaskedChildContext===n)return u.__reactInternalMemoizedMaskedChildContext;var m={},M;for(M in o)m[M]=n[M];return u&&(t=t.stateNode,t.__reactInternalMemoizedUnmaskedChildContext=n,t.__reactInternalMemoizedMaskedChildContext=m),m}function Yn(t){return t=t.childContextTypes,t!=null}function gs(){Zr(Vn),Zr(kn)}function wo(t,n,o){if(kn.current!==Xs)throw Error(f(168));Ur(kn,n),Ur(Vn,o)}function vo(t,n,o){var u=t.stateNode;if(n=n.childContextTypes,typeof u.getChildContext!="function")return o;u=u.getChildContext();for(var m in u)if(!(m in n))throw Error(f(108,Ve(t)||"Unknown",m));return ue({},o,u)}function si(t){return t=(t=t.stateNode)&&t.__reactInternalMemoizedMergedChildContext||Xs,yo=kn.current,Ur(kn,t),Ur(Vn,Vn.current),!0}function Mo(t,n,o){var u=t.stateNode;if(!u)throw Error(f(169));o?(t=vo(t,n,yo),u.__reactInternalMemoizedMergedChildContext=t,Zr(Vn),Zr(kn),Ur(kn,t)):Zr(Vn),Ur(Vn,o)}var nn=null,Gi=!1,Ki=!1;function Hi(t){nn===null?nn=[t]:nn.push(t)}function Od(t){Gi=!0,Hi(t)}function xo(){if(!Ki&&nn!==null){Ki=!0;var t=0,n=Ge;try{var o=nn;for(Ge=1;t<o.length;t++){var u=o[t];do u=u(!0);while(u!==null)}nn=null,Gi=!1}catch(m){throw nn!==null&&(nn=nn.slice(t+1)),Pi(Gs,xo),m}finally{Ge=n,Ki=!1}}return null}var oi=[],To=0,qi=null,Qi=0,Wn=[],is=0,Ys=null,ys=1,Js="";function jo(t,n){oi[To++]=Qi,oi[To++]=qi,qi=t,Qi=n}function Ld(t,n,o){Wn[is++]=ys,Wn[is++]=Js,Wn[is++]=Ys,Ys=t;var u=ys;t=Js;var m=32-Rt(u)-1;u&=~(1<<m),o+=1;var M=32-Rt(n)+m;if(30<M){var K=m-m%5;M=(u&(1<<K)-1).toString(32),u>>=K,m-=K,ys=1<<32-Rt(n)+m|o<<m|u,Js=M+t}else ys=1<<M|o<<m|u,Js=t}function $a(t){t.return!==null&&(jo(t,1),Ld(t,1,0))}function Ia(t){for(;t===qi;)qi=oi[--To],oi[To]=null,Qi=oi[--To],oi[To]=null;for(;t===Ys;)Ys=Wn[--is],Wn[is]=null,Js=Wn[--is],Wn[is]=null,ys=Wn[--is],Wn[is]=null}var $n=null,Gn=null,Kr=!1,ws=null;function Ll(t,n){var o=bs(5,null,null,0);o.elementType="DELETED",o.stateNode=n,o.return=t,n=t.deletions,n===null?(t.deletions=[o],t.flags|=16):n.push(o)}function ec(t,n){switch(t.tag){case 5:var o=t.type;return n=n.nodeType!==1||o.toLowerCase()!==n.nodeName.toLowerCase()?null:n,n!==null?(t.stateNode=n,$n=t,Gn=go(n.firstChild),!0):!1;case 6:return n=t.pendingProps===""||n.nodeType!==3?null:n,n!==null?(t.stateNode=n,$n=t,Gn=null,!0):!1;case 13:return n=n.nodeType!==8?null:n,n!==null?(o=Ys!==null?{id:ys,overflow:Js}:null,t.memoizedState={dehydrated:n,treeContext:o,retryLane:1073741824},o=bs(18,null,null,0),o.stateNode=n,o.return=t,t.child=o,$n=t,Gn=null,!0):!1;default:return!1}}function tc(t){return(t.mode&1)!==0&&(t.flags&128)===0}function Aa(t){if(Kr){var n=Gn;if(n){var o=n;if(!ec(t,n)){if(tc(t))throw Error(f(418));n=go(o.nextSibling);var u=$n;n&&ec(t,n)?Ll(u,o):(t.flags=t.flags&-4097|2,Kr=!1,$n=t)}}else{if(tc(t))throw Error(f(418));t.flags=t.flags&-4097|2,Kr=!1,$n=t}}}function rc(t){for(t=t.return;t!==null&&t.tag!==5&&t.tag!==3&&t.tag!==13;)t=t.return;$n=t}function Dl(t){if(t!==$n)return!1;if(!Kr)return rc(t),Kr=!0,!1;var n;if((n=t.tag!==3)&&!(n=t.tag!==5)&&(n=t.type,n=n!=="head"&&n!=="body"&&!kl(t.type,t.memoizedProps)),n&&(n=Gn)){if(tc(t))throw zl(),Error(f(418));for(;n;)Ll(t,n),n=go(n.nextSibling)}if(rc(t),t.tag===13){if(t=t.memoizedState,t=t!==null?t.dehydrated:null,!t)throw Error(f(317));e:{for(t=t.nextSibling,n=0;t;){if(t.nodeType===8){var o=t.data;if(o==="/$"){if(n===0){Gn=go(t.nextSibling);break e}n--}else o!=="$"&&o!=="$!"&&o!=="$?"||n++}t=t.nextSibling}Gn=null}}else Gn=$n?go(t.stateNode.nextSibling):null;return!0}function zl(){for(var t=Gn;t;)t=go(t.nextSibling)}function ii(){Gn=$n=null,Kr=!1}function Bl(t){ws===null?ws=[t]:ws.push(t)}var Dd=X.ReactCurrentBatchConfig;function ai(t,n,o){if(t=o.ref,t!==null&&typeof t!="function"&&typeof t!="object"){if(o._owner){if(o=o._owner,o){if(o.tag!==1)throw Error(f(309));var u=o.stateNode}if(!u)throw Error(f(147,t));var m=u,M=""+t;return n!==null&&n.ref!==null&&typeof n.ref=="function"&&n.ref._stringRef===M?n.ref:(n=function(K){var e=m.refs;K===null?delete e[M]:e[M]=K},n._stringRef=M,n)}if(typeof t!="string")throw Error(f(284));if(!o._owner)throw Error(f(290,t))}return t}function li(t,n){throw t=Object.prototype.toString.call(n),Error(f(31,t==="[object Object]"?"object with keys {"+Object.keys(n).join(", ")+"}":t))}function nc(t){var n=t._init;return n(t._payload)}function Xi(t){function n(v,y){if(t){var d=v.deletions;d===null?(v.deletions=[y],v.flags|=16):d.push(y)}}function o(v,y){if(!t)return null;for(;y!==null;)n(v,y),y=y.sibling;return null}function u(v,y){for(v=new Map;y!==null;)y.key!==null?v.set(y.key,y):v.set(y.index,y),y=y.sibling;return v}function m(v,y){return v=vi(v,y),v.index=0,v.sibling=null,v}function M(v,y,d){return v.index=d,t?(d=v.alternate,d!==null?(d=d.index,d<y?(v.flags|=2,y):d):(v.flags|=2,y)):(v.flags|=1048576,y)}function K(v){return t&&v.alternate===null&&(v.flags|=2),v}function e(v,y,d,S){return y===null||y.tag!==6?(y=vp(d,v.mode,S),y.return=v,y):(y=m(y,d),y.return=v,y)}function r(v,y,d,S){var B=d.type;return B===z?i(v,y,d.props.children,S,d.key):y!==null&&(y.elementType===B||typeof B=="object"&&B!==null&&B.$$typeof===He&&nc(B)===y.type)?(S=m(y,d.props),S.ref=ai(v,y,d),S.return=v,S):(S=Xc(d.type,d.key,d.props,null,v.mode,S),S.ref=ai(v,y,d),S.return=v,S)}function s(v,y,d,S){return y===null||y.tag!==4||y.stateNode.containerInfo!==d.containerInfo||y.stateNode.implementation!==d.implementation?(y=Mi(d,v.mode,S),y.return=v,y):(y=m(y,d.children||[]),y.return=v,y)}function i(v,y,d,S,B){return y===null||y.tag!==7?(y=ca(d,v.mode,S,B),y.return=v,y):(y=m(y,d),y.return=v,y)}function a(v,y,d){if(typeof y=="string"&&y!==""||typeof y=="number")return y=vp(""+y,v.mode,d),y.return=v,y;if(typeof y=="object"&&y!==null){switch(y.$$typeof){case W:return d=Xc(y.type,y.key,y.props,null,v.mode,d),d.ref=ai(v,null,y),d.return=v,d;case b:return y=Mi(y,v.mode,d),y.return=v,y;case He:var S=y._init;return a(v,S(y._payload),d)}if(vt(y)||me(y))return y=ca(y,v.mode,d,null),y.return=v,y;li(v,y)}return null}function c(v,y,d,S){var B=y!==null?y.key:null;if(typeof d=="string"&&d!==""||typeof d=="number")return B!==null?null:e(v,y,""+d,S);if(typeof d=="object"&&d!==null){switch(d.$$typeof){case W:return d.key===B?r(v,y,d,S):null;case b:return d.key===B?s(v,y,d,S):null;case He:return B=d._init,c(v,y,B(d._payload),S)}if(vt(d)||me(d))return B!==null?null:i(v,y,d,S,null);li(v,d)}return null}function l(v,y,d,S,B){if(typeof S=="string"&&S!==""||typeof S=="number")return v=v.get(d)||null,e(y,v,""+S,B);if(typeof S=="object"&&S!==null){switch(S.$$typeof){case W:return v=v.get(S.key===null?d:S.key)||null,r(y,v,S,B);case b:return v=v.get(S.key===null?d:S.key)||null,s(y,v,S,B);case He:var j=S._init;return l(v,y,d,j(S._payload),B)}if(vt(S)||me(S))return v=v.get(d)||null,i(y,v,S,B,null);li(y,S)}return null}function h(v,y,d,S){for(var B=null,j=null,Y=y,te=y=0,J=null;Y!==null&&te<d.length;te++){Y.index>te?(J=Y,Y=null):J=Y.sibling;var ye=c(v,Y,d[te],S);if(ye===null){Y===null&&(Y=J);break}t&&Y&&ye.alternate===null&&n(v,Y),y=M(ye,y,te),j===null?B=ye:j.sibling=ye,j=ye,Y=J}if(te===d.length)return o(v,Y),Kr&&jo(v,te),B;if(Y===null){for(;te<d.length;te++)Y=a(v,d[te],S),Y!==null&&(y=M(Y,y,te),j===null?B=Y:j.sibling=Y,j=Y);return Kr&&jo(v,te),B}for(Y=u(v,Y);te<d.length;te++)J=l(Y,v,te,d[te],S),J!==null&&(t&&J.alternate!==null&&Y.delete(J.key===null?te:J.key),y=M(J,y,te),j===null?B=J:j.sibling=J,j=J);return t&&Y.forEach(function(ve){return n(v,ve)}),Kr&&jo(v,te),B}function _(v,y,d,S){var B=me(d);if(typeof B!="function")throw Error(f(150));if(d=B.call(d),d==null)throw Error(f(151));for(var j=B=null,Y=y,te=y=0,J=null,ye=d.next();Y!==null&&!ye.done;te++,ye=d.next()){Y.index>te?(J=Y,Y=null):J=Y.sibling;var ve=c(v,Y,ye.value,S);if(ve===null){Y===null&&(Y=J);break}t&&Y&&ve.alternate===null&&n(v,Y),y=M(ve,y,te),j===null?B=ve:j.sibling=ve,j=ve,Y=J}if(ye.done)return o(v,Y),Kr&&jo(v,te),B;if(Y===null){for(;!ye.done;te++,ye=d.next())ye=a(v,ye.value,S),ye!==null&&(y=M(ye,y,te),j===null?B=ye:j.sibling=ye,j=ye);return Kr&&jo(v,te),B}for(Y=u(v,Y);!ye.done;te++,ye=d.next())ye=l(Y,v,te,ye.value,S),ye!==null&&(t&&ye.alternate!==null&&Y.delete(ye.key===null?te:ye.key),y=M(ye,y,te),j===null?B=ye:j.sibling=ye,j=ye);return t&&Y.forEach(function(Ce){return n(v,Ce)}),Kr&&jo(v,te),B}function w(v,y,d,S){if(typeof d=="object"&&d!==null&&d.type===z&&d.key===null&&(d=d.props.children),typeof d=="object"&&d!==null){switch(d.$$typeof){case W:e:{for(var B=d.key,j=y;j!==null;){if(j.key===B){if(B=d.type,B===z){if(j.tag===7){o(v,j.sibling),y=m(j,d.props.children),y.return=v,v=y;break e}}else if(j.elementType===B||typeof B=="object"&&B!==null&&B.$$typeof===He&&nc(B)===j.type){o(v,j.sibling),y=m(j,d.props),y.ref=ai(v,j,d),y.return=v,v=y;break e}o(v,j);break}else n(v,j);j=j.sibling}d.type===z?(y=ca(d.props.children,v.mode,S,d.key),y.return=v,v=y):(S=Xc(d.type,d.key,d.props,null,v.mode,S),S.ref=ai(v,y,d),S.return=v,v=S)}return K(v);case b:e:{for(j=d.key;y!==null;){if(y.key===j)if(y.tag===4&&y.stateNode.containerInfo===d.containerInfo&&y.stateNode.implementation===d.implementation){o(v,y.sibling),y=m(y,d.children||[]),y.return=v,v=y;break e}else{o(v,y);break}else n(v,y);y=y.sibling}y=Mi(d,v.mode,S),y.return=v,v=y}return K(v);case He:return j=d._init,w(v,y,j(d._payload),S)}if(vt(d))return h(v,y,d,S);if(me(d))return _(v,y,d,S);li(v,d)}return typeof d=="string"&&d!==""||typeof d=="number"?(d=""+d,y!==null&&y.tag===6?(o(v,y.sibling),y=m(y,d),y.return=v,v=y):(o(v,y),y=vp(d,v.mode,S),y.return=v,v=y),K(v)):o(v,y)}return w}var No=Xi(!0),Rl=Xi(!1),Fs=Qs(null),Fa=null,Uo=null,sc=null;function jl(){sc=Uo=Fa=null}function Oa(t){var n=Fs.current;Zr(Fs),t._currentValue=n}function oc(t,n,o){for(;t!==null;){var u=t.alternate;if((t.childLanes&n)!==n?(t.childLanes|=n,u!==null&&(u.childLanes|=n)):u!==null&&(u.childLanes&n)!==n&&(u.childLanes|=n),t===o)break;t=t.return}}function ui(t,n){Fa=t,sc=Uo=null,t=t.dependencies,t!==null&&t.firstContext!==null&&(t.lanes&n&&(On=!0),t.firstContext=null)}function Jn(t){var n=t._currentValue;if(sc!==t)if(t={context:t,memoizedValue:n,next:null},Uo===null){if(Fa===null)throw Error(f(308));Uo=t,Fa.dependencies={lanes:0,firstContext:t}}else Uo=Uo.next=t;return n}var ci=null;function Yi(t){ci===null?ci=[t]:ci.push(t)}function ic(t,n,o,u){var m=n.interleaved;return m===null?(o.next=o,Yi(n)):(o.next=m.next,m.next=o),n.interleaved=o,Zs(t,u)}function Zs(t,n){t.lanes|=n;var o=t.alternate;for(o!==null&&(o.lanes|=n),o=t,t=t.return;t!==null;)t.childLanes|=n,o=t.alternate,o!==null&&(o.childLanes|=n),o=t,t=t.return;return o.tag===3?o.stateNode:null}var eo=!1;function di(t){t.updateQueue={baseState:t.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,interleaved:null,lanes:0},effects:null}}function ac(t,n){t=t.updateQueue,n.updateQueue===t&&(n.updateQueue={baseState:t.baseState,firstBaseUpdate:t.firstBaseUpdate,lastBaseUpdate:t.lastBaseUpdate,shared:t.shared,effects:t.effects})}function to(t,n){return{eventTime:t,lane:n,tag:0,payload:null,callback:null,next:null}}function bo(t,n,o){var u=t.updateQueue;if(u===null)return null;if(u=u.shared,Tr&2){var m=u.pending;return m===null?n.next=n:(n.next=m.next,m.next=n),u.pending=n,Zs(t,o)}return m=u.interleaved,m===null?(n.next=n,Yi(u)):(n.next=m.next,m.next=n),u.interleaved=n,Zs(t,o)}function La(t,n,o){if(n=n.updateQueue,n!==null&&(n=n.shared,(o&4194240)!==0)){var u=n.lanes;u&=t.pendingLanes,o|=u,n.lanes=o,De(t,o)}}function Da(t,n){var o=t.updateQueue,u=t.alternate;if(u!==null&&(u=u.updateQueue,o===u)){var m=null,M=null;if(o=o.firstBaseUpdate,o!==null){do{var K={eventTime:o.eventTime,lane:o.lane,tag:o.tag,payload:o.payload,callback:o.callback,next:null};M===null?m=M=K:M=M.next=K,o=o.next}while(o!==null);M===null?m=M=n:M=M.next=n}else m=M=n;o={baseState:u.baseState,firstBaseUpdate:m,lastBaseUpdate:M,shared:u.shared,effects:u.effects},t.updateQueue=o;return}t=o.lastBaseUpdate,t===null?o.firstBaseUpdate=n:t.next=n,o.lastBaseUpdate=n}function Nl(t,n,o,u){var m=t.updateQueue;eo=!1;var M=m.firstBaseUpdate,K=m.lastBaseUpdate,e=m.shared.pending;if(e!==null){m.shared.pending=null;var r=e,s=r.next;r.next=null,K===null?M=s:K.next=s,K=r;var i=t.alternate;i!==null&&(i=i.updateQueue,e=i.lastBaseUpdate,e!==K&&(e===null?i.firstBaseUpdate=s:e.next=s,i.lastBaseUpdate=r))}if(M!==null){var a=m.baseState;K=0,i=s=r=null,e=M;do{var c=e.lane,l=e.eventTime;if((u&c)===c){i!==null&&(i=i.next={eventTime:l,lane:0,tag:e.tag,payload:e.payload,callback:e.callback,next:null});e:{var h=t,_=e;switch(c=n,l=o,_.tag){case 1:if(h=_.payload,typeof h=="function"){a=h.call(l,a,c);break e}a=h;break e;case 3:h.flags=h.flags&-65537|128;case 0:if(h=_.payload,c=typeof h=="function"?h.call(l,a,c):h,c==null)break e;a=ue({},a,c);break e;case 2:eo=!0}}e.callback!==null&&e.lane!==0&&(t.flags|=64,c=m.effects,c===null?m.effects=[e]:c.push(e))}else l={eventTime:l,lane:c,tag:e.tag,payload:e.payload,callback:e.callback,next:null},i===null?(s=i=l,r=a):i=i.next=l,K|=c;if(e=e.next,e===null){if(e=m.shared.pending,e===null)break;c=e,e=c.next,c.next=null,m.lastBaseUpdate=c,m.shared.pending=null}}while(!0);if(i===null&&(r=a),m.baseState=r,m.firstBaseUpdate=s,m.lastBaseUpdate=i,n=m.shared.interleaved,n!==null){m=n;do K|=m.lane,m=m.next;while(m!==n)}else M===null&&(m.shared.lanes=0);ut|=K,t.lanes=K,t.memoizedState=a}}function lc(t,n,o){if(t=n.effects,n.effects=null,t!==null)for(n=0;n<t.length;n++){var u=t[n],m=u.callback;if(m!==null){if(u.callback=null,u=o,typeof m!="function")throw Error(f(191,m));m.call(u)}}}var Ji={},ro=Qs(Ji),za=Qs(Ji),Zi=Qs(Ji);function Vo(t){if(t===Ji)throw Error(f(174));return t}function Wo(t,n){switch(Ur(Zi,n),Ur(za,t),Ur(ro,Ji),t=n.nodeType,t){case 9:case 11:n=(n=n.documentElement)?n.namespaceURI:ct(null,"");break;default:t=t===8?n.parentNode:n,n=t.namespaceURI||null,t=t.tagName,n=ct(n,t)}Zr(ro),Ur(ro,n)}function pi(){Zr(ro),Zr(za),Zr(Zi)}function uc(t){Vo(Zi.current);var n=Vo(ro.current),o=ct(n,t.type);n!==o&&(Ur(za,t),Ur(ro,o))}function cc(t){za.current===t&&(Zr(ro),Zr(za))}var Hr=Qs(0);function Go(t){for(var n=t;n!==null;){if(n.tag===13){var o=n.memoizedState;if(o!==null&&(o=o.dehydrated,o===null||o.data==="$?"||o.data==="$!"))return n}else if(n.tag===19&&n.memoizedProps.revealOrder!==void 0){if(n.flags&128)return n}else if(n.child!==null){n.child.return=n,n=n.child;continue}if(n===t)break;for(;n.sibling===null;){if(n.return===null||n.return===t)return null;n=n.return}n.sibling.return=n.return,n=n.sibling}return null}var fi=[];function dc(){for(var t=0;t<fi.length;t++)fi[t]._workInProgressVersionPrimary=null;fi.length=0}var Ba=X.ReactCurrentDispatcher,Ul=X.ReactCurrentBatchConfig,Ko=0,en=null,hn=null,mn=null,Ra=!1,ja=!1,hi=0,pc=0;function In(){throw Error(f(321))}function Na(t,n){if(n===null)return!1;for(var o=0;o<n.length&&o<t.length;o++)if(!_s(t[o],n[o]))return!1;return!0}function Vl(t,n,o,u,m,M){if(Ko=M,en=n,n.memoizedState=null,n.updateQueue=null,n.lanes=0,Ba.current=t===null||t.memoizedState===null?Nd:Ud,t=o(u,m),ja){M=0;do{if(ja=!1,hi=0,25<=M)throw Error(f(301));M+=1,mn=hn=null,n.updateQueue=null,Ba.current=Vd,t=o(u,m)}while(ja)}if(Ba.current=ra,n=hn!==null&&hn.next!==null,Ko=0,mn=hn=en=null,Ra=!1,n)throw Error(f(300));return t}function fc(){var t=hi!==0;return hi=0,t}function as(){var t={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};return mn===null?en.memoizedState=mn=t:mn=mn.next=t,mn}function ls(){if(hn===null){var t=en.alternate;t=t!==null?t.memoizedState:null}else t=hn.next;var n=mn===null?en.memoizedState:mn.next;if(n!==null)mn=n,hn=t;else{if(t===null)throw Error(f(310));hn=t,t={memoizedState:hn.memoizedState,baseState:hn.baseState,baseQueue:hn.baseQueue,queue:hn.queue,next:null},mn===null?en.memoizedState=mn=t:mn=mn.next=t}return mn}function Ua(t,n){return typeof n=="function"?n(t):n}function Wl(t){var n=ls(),o=n.queue;if(o===null)throw Error(f(311));o.lastRenderedReducer=t;var u=hn,m=u.baseQueue,M=o.pending;if(M!==null){if(m!==null){var K=m.next;m.next=M.next,M.next=K}u.baseQueue=m=M,o.pending=null}if(m!==null){M=m.next,u=u.baseState;var e=K=null,r=null,s=M;do{var i=s.lane;if((Ko&i)===i)r!==null&&(r=r.next={lane:0,action:s.action,hasEagerState:s.hasEagerState,eagerState:s.eagerState,next:null}),u=s.hasEagerState?s.eagerState:t(u,s.action);else{var a={lane:i,action:s.action,hasEagerState:s.hasEagerState,eagerState:s.eagerState,next:null};r===null?(e=r=a,K=u):r=r.next=a,en.lanes|=i,ut|=i}s=s.next}while(s!==null&&s!==M);r===null?K=u:r.next=e,_s(u,n.memoizedState)||(On=!0),n.memoizedState=u,n.baseState=K,n.baseQueue=r,o.lastRenderedState=u}if(t=o.interleaved,t!==null){m=t;do M=m.lane,en.lanes|=M,ut|=M,m=m.next;while(m!==t)}else m===null&&(o.lanes=0);return[n.memoizedState,o.dispatch]}function Gl(t){var n=ls(),o=n.queue;if(o===null)throw Error(f(311));o.lastRenderedReducer=t;var u=o.dispatch,m=o.pending,M=n.memoizedState;if(m!==null){o.pending=null;var K=m=m.next;do M=t(M,K.action),K=K.next;while(K!==m);_s(M,n.memoizedState)||(On=!0),n.memoizedState=M,n.baseQueue===null&&(n.baseState=M),o.lastRenderedState=M}return[M,u]}function Kl(){}function Va(t,n){var o=en,u=ls(),m=n(),M=!_s(u.memoizedState,m);if(M&&(u.memoizedState=m,On=!0),u=u.queue,yc(mc.bind(null,o,u,t),[t]),u.getSnapshot!==n||M||mn!==null&&mn.memoizedState.tag&1){if(o.flags|=2048,mi(9,hc.bind(null,o,u,m,n),void 0,null),T===null)throw Error(f(349));Ko&30||hp(o,n,m)}return m}function hp(t,n,o){t.flags|=16384,t={getSnapshot:n,value:o},n=en.updateQueue,n===null?(n={lastEffect:null,stores:null},en.updateQueue=n,n.stores=[t]):(o=n.stores,o===null?n.stores=[t]:o.push(t))}function hc(t,n,o,u){n.value=o,n.getSnapshot=u,Hl(n)&&_c(t)}function mc(t,n,o){return o(function(){Hl(n)&&_c(t)})}function Hl(t){var n=t.getSnapshot;t=t.value;try{var o=n();return!_s(t,o)}catch{return!0}}function _c(t){var n=Zs(t,1);n!==null&&ds(n,t,1,-1)}function zd(t){var n=as();return typeof t=="function"&&(t=t()),n.memoizedState=n.baseState=t,t={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:Ua,lastRenderedState:t},n.queue=t,t=t.dispatch=jd.bind(null,en,t),[n.memoizedState,t]}function mi(t,n,o,u){return t={tag:t,create:n,destroy:o,deps:u,next:null},n=en.updateQueue,n===null?(n={lastEffect:null,stores:null},en.updateQueue=n,n.lastEffect=t.next=t):(o=n.lastEffect,o===null?n.lastEffect=t.next=t:(u=o.next,o.next=t,t.next=u,n.lastEffect=t)),t}function gc(){return ls().memoizedState}function Wa(t,n,o,u){var m=as();en.flags|=t,m.memoizedState=mi(1|n,o,void 0,u===void 0?null:u)}function ea(t,n,o,u){var m=ls();u=u===void 0?null:u;var M=void 0;if(hn!==null){var K=hn.memoizedState;if(M=K.destroy,u!==null&&Na(u,K.deps)){m.memoizedState=mi(n,o,M,u);return}}en.flags|=t,m.memoizedState=mi(1|n,o,M,u)}function mp(t,n){return Wa(8390656,8,t,n)}function yc(t,n){return ea(2048,8,t,n)}function ql(t,n){return ea(4,2,t,n)}function Ql(t,n){return ea(4,4,t,n)}function wc(t,n){if(typeof n=="function")return t=t(),n(t),function(){n(null)};if(n!=null)return t=t(),n.current=t,function(){n.current=null}}function Bd(t,n,o){return o=o!=null?o.concat([t]):null,ea(4,4,wc.bind(null,n,t),o)}function xn(){}function vc(t,n){var o=ls();n=n===void 0?null:n;var u=o.memoizedState;return u!==null&&n!==null&&Na(n,u[1])?u[0]:(o.memoizedState=[t,n],t)}function Mc(t,n){var o=ls();n=n===void 0?null:n;var u=o.memoizedState;return u!==null&&n!==null&&Na(n,u[1])?u[0]:(t=t(),o.memoizedState=[t,n],t)}function Ga(t,n,o){return Ko&21?(_s(o,n)||(o=I(),en.lanes|=o,ut|=o,t.baseState=!0),n):(t.baseState&&(t.baseState=!1,On=!0),t.memoizedState=o)}function Rd(t,n){var o=Ge;Ge=o!==0&&4>o?o:4,t(!0);var u=Ul.transition;Ul.transition={};try{t(!1),n()}finally{Ge=o,Ul.transition=u}}function ta(){return ls().memoizedState}function xc(t,n,o){var u=xs(t);if(o={lane:u,action:o,hasEagerState:!1,eagerState:null,next:null},Xl(t))Tc(n,o);else if(o=ic(t,n,o,u),o!==null){var m=tn();ds(o,t,u,m),bc(o,n,u)}}function jd(t,n,o){var u=xs(t),m={lane:u,action:o,hasEagerState:!1,eagerState:null,next:null};if(Xl(t))Tc(n,m);else{var M=t.alternate;if(t.lanes===0&&(M===null||M.lanes===0)&&(M=n.lastRenderedReducer,M!==null))try{var K=n.lastRenderedState,e=M(K,o);if(m.hasEagerState=!0,m.eagerState=e,_s(e,K)){var r=n.interleaved;r===null?(m.next=m,Yi(n)):(m.next=r.next,r.next=m),n.interleaved=m;return}}catch{}finally{}o=ic(t,n,m,u),o!==null&&(m=tn(),ds(o,t,u,m),bc(o,n,u))}}function Xl(t){var n=t.alternate;return t===en||n!==null&&n===en}function Tc(t,n){ja=Ra=!0;var o=t.pending;o===null?n.next=n:(n.next=o.next,o.next=n),t.pending=n}function bc(t,n,o){if(o&4194240){var u=n.lanes;u&=t.pendingLanes,o|=u,n.lanes=o,De(t,o)}}var ra={readContext:Jn,useCallback:In,useContext:In,useEffect:In,useImperativeHandle:In,useInsertionEffect:In,useLayoutEffect:In,useMemo:In,useReducer:In,useRef:In,useState:In,useDebugValue:In,useDeferredValue:In,useTransition:In,useMutableSource:In,useSyncExternalStore:In,useId:In,unstable_isNewReconciler:!1},Nd={readContext:Jn,useCallback:function(t,n){return as().memoizedState=[t,n===void 0?null:n],t},useContext:Jn,useEffect:mp,useImperativeHandle:function(t,n,o){return o=o!=null?o.concat([t]):null,Wa(4194308,4,wc.bind(null,n,t),o)},useLayoutEffect:function(t,n){return Wa(4194308,4,t,n)},useInsertionEffect:function(t,n){return Wa(4,2,t,n)},useMemo:function(t,n){var o=as();return n=n===void 0?null:n,t=t(),o.memoizedState=[t,n],t},useReducer:function(t,n,o){var u=as();return n=o!==void 0?o(n):n,u.memoizedState=u.baseState=n,t={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:t,lastRenderedState:n},u.queue=t,t=t.dispatch=xc.bind(null,en,t),[u.memoizedState,t]},useRef:function(t){var n=as();return t={current:t},n.memoizedState=t},useState:zd,useDebugValue:xn,useDeferredValue:function(t){return as().memoizedState=t},useTransition:function(){var t=zd(!1),n=t[0];return t=Rd.bind(null,t[1]),as().memoizedState=t,[n,t]},useMutableSource:function(){},useSyncExternalStore:function(t,n,o){var u=en,m=as();if(Kr){if(o===void 0)throw Error(f(407));o=o()}else{if(o=n(),T===null)throw Error(f(349));Ko&30||hp(u,n,o)}m.memoizedState=o;var M={value:o,getSnapshot:n};return m.queue=M,mp(mc.bind(null,u,M,t),[t]),u.flags|=2048,mi(9,hc.bind(null,u,M,o,n),void 0,null),o},useId:function(){var t=as(),n=T.identifierPrefix;if(Kr){var o=Js,u=ys;o=(u&~(1<<32-Rt(u)-1)).toString(32)+o,n=":"+n+"R"+o,o=hi++,0<o&&(n+="H"+o.toString(32)),n+=":"}else o=pc++,n=":"+n+"r"+o.toString(32)+":";return t.memoizedState=n},unstable_isNewReconciler:!1},Ud={readContext:Jn,useCallback:vc,useContext:Jn,useEffect:yc,useImperativeHandle:Bd,useInsertionEffect:ql,useLayoutEffect:Ql,useMemo:Mc,useReducer:Wl,useRef:gc,useState:function(){return Wl(Ua)},useDebugValue:xn,useDeferredValue:function(t){var n=ls();return Ga(n,hn.memoizedState,t)},useTransition:function(){var t=Wl(Ua)[0],n=ls().memoizedState;return[t,n]},useMutableSource:Kl,useSyncExternalStore:Va,useId:ta,unstable_isNewReconciler:!1},Vd={readContext:Jn,useCallback:vc,useContext:Jn,useEffect:yc,useImperativeHandle:Bd,useInsertionEffect:ql,useLayoutEffect:Ql,useMemo:Mc,useReducer:Gl,useRef:gc,useState:function(){return Gl(Ua)},useDebugValue:xn,useDeferredValue:function(t){var n=ls();return hn===null?n.memoizedState=t:Ga(n,hn.memoizedState,t)},useTransition:function(){var t=Gl(Ua)[0],n=ls().memoizedState;return[t,n]},useMutableSource:Kl,useSyncExternalStore:Va,useId:ta,unstable_isNewReconciler:!1};function us(t,n){if(t&&t.defaultProps){n=ue({},n),t=t.defaultProps;for(var o in t)n[o]===void 0&&(n[o]=t[o]);return n}return n}function Ka(t,n,o,u){n=t.memoizedState,o=o(u,n),o=o==null?n:ue({},n,o),t.memoizedState=o,t.lanes===0&&(t.updateQueue.baseState=o)}var Ha={isMounted:function(t){return(t=t._reactInternals)?zr(t)===t:!1},enqueueSetState:function(t,n,o){t=t._reactInternals;var u=tn(),m=xs(t),M=to(u,m);M.payload=n,o!=null&&(M.callback=o),n=bo(t,M,m),n!==null&&(ds(n,t,m,u),La(n,t,m))},enqueueReplaceState:function(t,n,o){t=t._reactInternals;var u=tn(),m=xs(t),M=to(u,m);M.tag=1,M.payload=n,o!=null&&(M.callback=o),n=bo(t,M,m),n!==null&&(ds(n,t,m,u),La(n,t,m))},enqueueForceUpdate:function(t,n){t=t._reactInternals;var o=tn(),u=xs(t),m=to(o,u);m.tag=2,n!=null&&(m.callback=n),n=bo(t,m,u),n!==null&&(ds(n,t,u,o),La(n,t,u))}};function Yl(t,n,o,u,m,M,K){return t=t.stateNode,typeof t.shouldComponentUpdate=="function"?t.shouldComponentUpdate(u,M,K):n.prototype&&n.prototype.isPureReactComponent?!Do(o,u)||!Do(m,M):!0}function Jl(t,n,o){var u=!1,m=Xs,M=n.contextType;return typeof M=="object"&&M!==null?M=Jn(M):(m=Yn(n)?yo:kn.current,u=n.contextTypes,M=(u=u!=null)?ni(t,m):Xs),n=new n(o,M),t.memoizedState=n.state!==null&&n.state!==void 0?n.state:null,n.updater=Ha,t.stateNode=n,n._reactInternals=t,u&&(t=t.stateNode,t.__reactInternalMemoizedUnmaskedChildContext=m,t.__reactInternalMemoizedMaskedChildContext=M),n}function Wd(t,n,o,u){t=n.state,typeof n.componentWillReceiveProps=="function"&&n.componentWillReceiveProps(o,u),typeof n.UNSAFE_componentWillReceiveProps=="function"&&n.UNSAFE_componentWillReceiveProps(o,u),n.state!==t&&Ha.enqueueReplaceState(n,n.state,null)}function qa(t,n,o,u){var m=t.stateNode;m.props=o,m.state=t.memoizedState,m.refs={},di(t);var M=n.contextType;typeof M=="object"&&M!==null?m.context=Jn(M):(M=Yn(n)?yo:kn.current,m.context=ni(t,M)),m.state=t.memoizedState,M=n.getDerivedStateFromProps,typeof M=="function"&&(Ka(t,n,M,o),m.state=t.memoizedState),typeof n.getDerivedStateFromProps=="function"||typeof m.getSnapshotBeforeUpdate=="function"||typeof m.UNSAFE_componentWillMount!="function"&&typeof m.componentWillMount!="function"||(n=m.state,typeof m.componentWillMount=="function"&&m.componentWillMount(),typeof m.UNSAFE_componentWillMount=="function"&&m.UNSAFE_componentWillMount(),n!==m.state&&Ha.enqueueReplaceState(m,m.state,null),Nl(t,o,m,u),m.state=t.memoizedState),typeof m.componentDidMount=="function"&&(t.flags|=4194308)}function vr(t,n){try{var o="",u=n;do o+=tt(u),u=u.return;while(u);var m=o}catch(M){m=`
Error generating stack: `+M.message+`
`+M.stack}return{value:t,source:n,stack:m,digest:null}}function Ec(t,n,o){return{value:t,source:null,stack:o??null,digest:n??null}}function Pc(t,n){try{console.error(n.value)}catch(o){setTimeout(function(){throw o})}}var kp=typeof WeakMap=="function"?WeakMap:Map;function Zl(t,n,o){o=to(-1,o),o.tag=3,o.payload={element:null};var u=n.value;return o.callback=function(){dr||(dr=!0,sr=u),Pc(t,n)},o}function Cc(t,n,o){o=to(-1,o),o.tag=3;var u=t.type.getDerivedStateFromError;if(typeof u=="function"){var m=n.value;o.payload=function(){return u(m)},o.callback=function(){Pc(t,n)}}var M=t.stateNode;return M!==null&&typeof M.componentDidCatch=="function"&&(o.callback=function(){Pc(t,n),typeof u!="function"&&(pr===null?pr=new Set([this]):pr.add(this));var K=n.stack;this.componentDidCatch(n.value,{componentStack:K!==null?K:""})}),o}function Sc(t,n,o){var u=t.pingCache;if(u===null){u=t.pingCache=new kp;var m=new Set;u.set(n,m)}else m=u.get(n),m===void 0&&(m=new Set,u.set(n,m));m.has(o)||(m.add(o),t=yp.bind(null,t,n,o),n.then(t,t))}function Gd(t){do{var n;if((n=t.tag===13)&&(n=t.memoizedState,n=n!==null?n.dehydrated!==null:!0),n)return t;t=t.return}while(t!==null);return null}function kc(t,n,o,u,m){return t.mode&1?(t.flags|=65536,t.lanes=m,t):(t===n?t.flags|=65536:(t.flags|=128,o.flags|=131072,o.flags&=-52805,o.tag===1&&(o.alternate===null?o.tag=17:(n=to(-1,1),n.tag=2,bo(o,n,1))),o.lanes|=1),t)}var $c=X.ReactCurrentOwner,On=!1;function Kn(t,n,o,u){n.child=t===null?Rl(n,null,o,u):No(n,t.child,o,u)}function Ic(t,n,o,u,m){o=o.render;var M=n.ref;return ui(n,m),u=Vl(t,n,o,u,M,m),o=fc(),t!==null&&!On?(n.updateQueue=t.updateQueue,n.flags&=-2053,t.lanes&=~m,Os(t,n,m)):(Kr&&o&&$a(n),n.flags|=1,Kn(t,n,u,m),n.child)}function Kd(t,n,o,u,m){if(t===null){var M=o.type;return typeof M=="function"&&!np(M)&&M.defaultProps===void 0&&o.compare===null&&o.defaultProps===void 0?(n.tag=15,n.type=M,eu(t,n,M,u,m)):(t=Xc(o.type,null,u,n,n.mode,m),t.ref=n.ref,t.return=n,n.child=t)}if(M=t.child,!(t.lanes&m)){var K=M.memoizedProps;if(o=o.compare,o=o!==null?o:Do,o(K,u)&&t.ref===n.ref)return Os(t,n,m)}return n.flags|=1,t=vi(M,u),t.ref=n.ref,t.return=n,n.child=t}function eu(t,n,o,u,m){if(t!==null){var M=t.memoizedProps;if(Do(M,u)&&t.ref===n.ref)if(On=!1,n.pendingProps=u=M,(t.lanes&m)!==0)t.flags&131072&&(On=!0);else return n.lanes=t.lanes,Os(t,n,m)}return tu(t,n,o,u,m)}function Hd(t,n,o){var u=n.pendingProps,m=u.children,M=t!==null?t.memoizedState:null;if(u.mode==="hidden")if(!(n.mode&1))n.memoizedState={baseLanes:0,cachePool:null,transitions:null},Ur(Ue,$e),$e|=o;else{if(!(o&1073741824))return t=M!==null?M.baseLanes|o:o,n.lanes=n.childLanes=1073741824,n.memoizedState={baseLanes:t,cachePool:null,transitions:null},n.updateQueue=null,Ur(Ue,$e),$e|=t,null;n.memoizedState={baseLanes:0,cachePool:null,transitions:null},u=M!==null?M.baseLanes:o,Ur(Ue,$e),$e|=u}else M!==null?(u=M.baseLanes|o,n.memoizedState=null):u=o,Ur(Ue,$e),$e|=u;return Kn(t,n,m,o),n.child}function qd(t,n){var o=n.ref;(t===null&&o!==null||t!==null&&t.ref!==o)&&(n.flags|=512,n.flags|=2097152)}function tu(t,n,o,u,m){var M=Yn(o)?yo:kn.current;return M=ni(n,M),ui(n,m),o=Vl(t,n,o,u,M,m),u=fc(),t!==null&&!On?(n.updateQueue=t.updateQueue,n.flags&=-2053,t.lanes&=~m,Os(t,n,m)):(Kr&&u&&$a(n),n.flags|=1,Kn(t,n,o,m),n.child)}function Ac(t,n,o,u,m){if(Yn(o)){var M=!0;si(n)}else M=!1;if(ui(n,m),n.stateNode===null)oa(t,n),Jl(n,o,u),qa(n,o,u,m),u=!0;else if(t===null){var K=n.stateNode,e=n.memoizedProps;K.props=e;var r=K.context,s=o.contextType;typeof s=="object"&&s!==null?s=Jn(s):(s=Yn(o)?yo:kn.current,s=ni(n,s));var i=o.getDerivedStateFromProps,a=typeof i=="function"||typeof K.getSnapshotBeforeUpdate=="function";a||typeof K.UNSAFE_componentWillReceiveProps!="function"&&typeof K.componentWillReceiveProps!="function"||(e!==u||r!==s)&&Wd(n,K,u,s),eo=!1;var c=n.memoizedState;K.state=c,Nl(n,u,K,m),r=n.memoizedState,e!==u||c!==r||Vn.current||eo?(typeof i=="function"&&(Ka(n,o,i,u),r=n.memoizedState),(e=eo||Yl(n,o,e,u,c,r,s))?(a||typeof K.UNSAFE_componentWillMount!="function"&&typeof K.componentWillMount!="function"||(typeof K.componentWillMount=="function"&&K.componentWillMount(),typeof K.UNSAFE_componentWillMount=="function"&&K.UNSAFE_componentWillMount()),typeof K.componentDidMount=="function"&&(n.flags|=4194308)):(typeof K.componentDidMount=="function"&&(n.flags|=4194308),n.memoizedProps=u,n.memoizedState=r),K.props=u,K.state=r,K.context=s,u=e):(typeof K.componentDidMount=="function"&&(n.flags|=4194308),u=!1)}else{K=n.stateNode,ac(t,n),e=n.memoizedProps,s=n.type===n.elementType?e:us(n.type,e),K.props=s,a=n.pendingProps,c=K.context,r=o.contextType,typeof r=="object"&&r!==null?r=Jn(r):(r=Yn(o)?yo:kn.current,r=ni(n,r));var l=o.getDerivedStateFromProps;(i=typeof l=="function"||typeof K.getSnapshotBeforeUpdate=="function")||typeof K.UNSAFE_componentWillReceiveProps!="function"&&typeof K.componentWillReceiveProps!="function"||(e!==a||c!==r)&&Wd(n,K,u,r),eo=!1,c=n.memoizedState,K.state=c,Nl(n,u,K,m);var h=n.memoizedState;e!==a||c!==h||Vn.current||eo?(typeof l=="function"&&(Ka(n,o,l,u),h=n.memoizedState),(s=eo||Yl(n,o,s,u,c,h,r)||!1)?(i||typeof K.UNSAFE_componentWillUpdate!="function"&&typeof K.componentWillUpdate!="function"||(typeof K.componentWillUpdate=="function"&&K.componentWillUpdate(u,h,r),typeof K.UNSAFE_componentWillUpdate=="function"&&K.UNSAFE_componentWillUpdate(u,h,r)),typeof K.componentDidUpdate=="function"&&(n.flags|=4),typeof K.getSnapshotBeforeUpdate=="function"&&(n.flags|=1024)):(typeof K.componentDidUpdate!="function"||e===t.memoizedProps&&c===t.memoizedState||(n.flags|=4),typeof K.getSnapshotBeforeUpdate!="function"||e===t.memoizedProps&&c===t.memoizedState||(n.flags|=1024),n.memoizedProps=u,n.memoizedState=h),K.props=u,K.state=h,K.context=r,u=s):(typeof K.componentDidUpdate!="function"||e===t.memoizedProps&&c===t.memoizedState||(n.flags|=4),typeof K.getSnapshotBeforeUpdate!="function"||e===t.memoizedProps&&c===t.memoizedState||(n.flags|=1024),u=!1)}return ru(t,n,o,u,M,m)}function ru(t,n,o,u,m,M){qd(t,n);var K=(n.flags&128)!==0;if(!u&&!K)return m&&Mo(n,o,!1),Os(t,n,M);u=n.stateNode,$c.current=n;var e=K&&typeof o.getDerivedStateFromError!="function"?null:u.render();return n.flags|=1,t!==null&&K?(n.child=No(n,t.child,null,M),n.child=No(n,null,e,M)):Kn(t,n,e,M),n.memoizedState=u.state,m&&Mo(n,o,!0),n.child}function Fc(t){var n=t.stateNode;n.pendingContext?wo(t,n.pendingContext,n.pendingContext!==n.context):n.context&&wo(t,n.context,!1),Wo(t,n.containerInfo)}function Oc(t,n,o,u,m){return ii(),Bl(m),n.flags|=256,Kn(t,n,o,u),n.child}var nu={dehydrated:null,treeContext:null,retryLane:0};function Lc(t){return{baseLanes:t,cachePool:null,transitions:null}}function na(t,n,o){var u=n.pendingProps,m=Hr.current,M=!1,K=(n.flags&128)!==0,e;if((e=K)||(e=t!==null&&t.memoizedState===null?!1:(m&2)!==0),e?(M=!0,n.flags&=-129):(t===null||t.memoizedState!==null)&&(m|=1),Ur(Hr,m&1),t===null)return Aa(n),t=n.memoizedState,t!==null&&(t=t.dehydrated,t!==null)?(n.mode&1?t.data==="$!"?n.lanes=8:n.lanes=1073741824:n.lanes=1,null):(K=u.children,t=u.fallback,M?(u=n.mode,M=n.child,K={mode:"hidden",children:K},!(u&1)&&M!==null?(M.childLanes=0,M.pendingProps=K):M=Yc(K,u,0,null),t=ca(t,u,o,null),M.return=n,t.return=n,M.sibling=t,n.child=M,n.child.memoizedState=Lc(o),n.memoizedState=nu,t):Qa(n,K));if(m=t.memoizedState,m!==null&&(e=m.dehydrated,e!==null))return Dc(t,n,K,u,e,m,o);if(M){M=u.fallback,K=n.mode,m=t.child,e=m.sibling;var r={mode:"hidden",children:u.children};return!(K&1)&&n.child!==m?(u=n.child,u.childLanes=0,u.pendingProps=r,n.deletions=null):(u=vi(m,r),u.subtreeFlags=m.subtreeFlags&14680064),e!==null?M=vi(e,M):(M=ca(M,K,o,null),M.flags|=2),M.return=n,u.return=n,u.sibling=M,n.child=u,u=M,M=n.child,K=t.child.memoizedState,K=K===null?Lc(o):{baseLanes:K.baseLanes|o,cachePool:null,transitions:K.transitions},M.memoizedState=K,M.childLanes=t.childLanes&~o,n.memoizedState=nu,u}return M=t.child,t=M.sibling,u=vi(M,{mode:"visible",children:u.children}),!(n.mode&1)&&(u.lanes=o),u.return=n,u.sibling=null,t!==null&&(o=n.deletions,o===null?(n.deletions=[t],n.flags|=16):o.push(t)),n.child=u,n.memoizedState=null,u}function Qa(t,n){return n=Yc({mode:"visible",children:n},t.mode,0,null),n.return=t,t.child=n}function sa(t,n,o,u){return u!==null&&Bl(u),No(n,t.child,null,o),t=Qa(n,n.pendingProps.children),t.flags|=2,n.memoizedState=null,t}function Dc(t,n,o,u,m,M,K){if(o)return n.flags&256?(n.flags&=-257,u=Ec(Error(f(422))),sa(t,n,K,u)):n.memoizedState!==null?(n.child=t.child,n.flags|=128,null):(M=u.fallback,m=n.mode,u=Yc({mode:"visible",children:u.children},m,0,null),M=ca(M,m,K,null),M.flags|=2,u.return=n,M.return=n,u.sibling=M,n.child=u,n.mode&1&&No(n,t.child,null,K),n.child.memoizedState=Lc(K),n.memoizedState=nu,M);if(!(n.mode&1))return sa(t,n,K,null);if(m.data==="$!"){if(u=m.nextSibling&&m.nextSibling.dataset,u)var e=u.dgst;return u=e,M=Error(f(419)),u=Ec(M,u,void 0),sa(t,n,K,u)}if(e=(K&t.childLanes)!==0,On||e){if(u=T,u!==null){switch(K&-K){case 4:m=2;break;case 16:m=8;break;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:m=32;break;case 536870912:m=268435456;break;default:m=0}m=m&(u.suspendedLanes|K)?0:m,m!==0&&m!==M.retryLane&&(M.retryLane=m,Zs(t,m),ds(u,t,m,-1))}return la(),u=Ec(Error(f(421))),sa(t,n,K,u)}return m.data==="$?"?(n.flags|=128,n.child=t.child,n=Bs.bind(null,t),m._reactRetry=n,null):(t=M.treeContext,Gn=go(m.nextSibling),$n=n,Kr=!0,ws=null,t!==null&&(Wn[is++]=ys,Wn[is++]=Js,Wn[is++]=Ys,ys=t.id,Js=t.overflow,Ys=n),n=Qa(n,u.children),n.flags|=4096,n)}function su(t,n,o){t.lanes|=n;var u=t.alternate;u!==null&&(u.lanes|=n),oc(t.return,n,o)}function zc(t,n,o,u,m){var M=t.memoizedState;M===null?t.memoizedState={isBackwards:n,rendering:null,renderingStartTime:0,last:u,tail:o,tailMode:m}:(M.isBackwards=n,M.rendering=null,M.renderingStartTime=0,M.last=u,M.tail=o,M.tailMode=m)}function Bc(t,n,o){var u=n.pendingProps,m=u.revealOrder,M=u.tail;if(Kn(t,n,u.children,o),u=Hr.current,u&2)u=u&1|2,n.flags|=128;else{if(t!==null&&t.flags&128)e:for(t=n.child;t!==null;){if(t.tag===13)t.memoizedState!==null&&su(t,o,n);else if(t.tag===19)su(t,o,n);else if(t.child!==null){t.child.return=t,t=t.child;continue}if(t===n)break e;for(;t.sibling===null;){if(t.return===null||t.return===n)break e;t=t.return}t.sibling.return=t.return,t=t.sibling}u&=1}if(Ur(Hr,u),!(n.mode&1))n.memoizedState=null;else switch(m){case"forwards":for(o=n.child,m=null;o!==null;)t=o.alternate,t!==null&&Go(t)===null&&(m=o),o=o.sibling;o=m,o===null?(m=n.child,n.child=null):(m=o.sibling,o.sibling=null),zc(n,!1,m,o,M);break;case"backwards":for(o=null,m=n.child,n.child=null;m!==null;){if(t=m.alternate,t!==null&&Go(t)===null){n.child=m;break}t=m.sibling,m.sibling=o,o=m,m=t}zc(n,!0,o,null,M);break;case"together":zc(n,!1,null,null,void 0);break;default:n.memoizedState=null}return n.child}function oa(t,n){!(n.mode&1)&&t!==null&&(t.alternate=null,n.alternate=null,n.flags|=2)}function Os(t,n,o){if(t!==null&&(n.dependencies=t.dependencies),ut|=n.lanes,!(o&n.childLanes))return null;if(t!==null&&n.child!==t.child)throw Error(f(153));if(n.child!==null){for(t=n.child,o=vi(t,t.pendingProps),n.child=o,o.return=n;t.sibling!==null;)t=t.sibling,o=o.sibling=vi(t,t.pendingProps),o.return=n;o.sibling=null}return n.child}function Qd(t,n,o){switch(n.tag){case 3:Fc(n),ii();break;case 5:uc(n);break;case 1:Yn(n.type)&&si(n);break;case 4:Wo(n,n.stateNode.containerInfo);break;case 10:var u=n.type._context,m=n.memoizedProps.value;Ur(Fs,u._currentValue),u._currentValue=m;break;case 13:if(u=n.memoizedState,u!==null)return u.dehydrated!==null?(Ur(Hr,Hr.current&1),n.flags|=128,null):o&n.child.childLanes?na(t,n,o):(Ur(Hr,Hr.current&1),t=Os(t,n,o),t!==null?t.sibling:null);Ur(Hr,Hr.current&1);break;case 19:if(u=(o&n.childLanes)!==0,t.flags&128){if(u)return Bc(t,n,o);n.flags|=128}if(m=n.memoizedState,m!==null&&(m.rendering=null,m.tail=null,m.lastEffect=null),Ur(Hr,Hr.current),u)break;return null;case 22:case 23:return n.lanes=0,Hd(t,n,o)}return Os(t,n,o)}var Rc,Xa,Xd,ou;Rc=function(t,n){for(var o=n.child;o!==null;){if(o.tag===5||o.tag===6)t.appendChild(o.stateNode);else if(o.tag!==4&&o.child!==null){o.child.return=o,o=o.child;continue}if(o===n)break;for(;o.sibling===null;){if(o.return===null||o.return===n)return;o=o.return}o.sibling.return=o.return,o=o.sibling}},Xa=function(){},Xd=function(t,n,o,u){var m=t.memoizedProps;if(m!==u){t=n.stateNode,Vo(ro.current);var M=null;switch(o){case"input":m=st(t,m),u=st(t,u),M=[];break;case"select":m=ue({},m,{value:void 0}),u=ue({},u,{value:void 0}),M=[];break;case"textarea":m=_e(t,m),u=_e(t,u),M=[];break;default:typeof m.onClick!="function"&&typeof u.onClick=="function"&&(t.onclick=Ui)}an(o,u);var K;o=null;for(s in m)if(!u.hasOwnProperty(s)&&m.hasOwnProperty(s)&&m[s]!=null)if(s==="style"){var e=m[s];for(K in e)e.hasOwnProperty(K)&&(o||(o={}),o[K]="")}else s!=="dangerouslySetInnerHTML"&&s!=="children"&&s!=="suppressContentEditableWarning"&&s!=="suppressHydrationWarning"&&s!=="autoFocus"&&(R.hasOwnProperty(s)?M||(M=[]):(M=M||[]).push(s,null));for(s in u){var r=u[s];if(e=m!=null?m[s]:void 0,u.hasOwnProperty(s)&&r!==e&&(r!=null||e!=null))if(s==="style")if(e){for(K in e)!e.hasOwnProperty(K)||r&&r.hasOwnProperty(K)||(o||(o={}),o[K]="");for(K in r)r.hasOwnProperty(K)&&e[K]!==r[K]&&(o||(o={}),o[K]=r[K])}else o||(M||(M=[]),M.push(s,o)),o=r;else s==="dangerouslySetInnerHTML"?(r=r?r.__html:void 0,e=e?e.__html:void 0,r!=null&&e!==r&&(M=M||[]).push(s,r)):s==="children"?typeof r!="string"&&typeof r!="number"||(M=M||[]).push(s,""+r):s!=="suppressContentEditableWarning"&&s!=="suppressHydrationWarning"&&(R.hasOwnProperty(s)?(r!=null&&s==="onScroll"&&Gr("scroll",t),M||e===r||(M=[])):(M=M||[]).push(s,r))}o&&(M=M||[]).push("style",o);var s=M;(n.updateQueue=s)&&(n.flags|=4)}},ou=function(t,n,o,u){o!==u&&(n.flags|=4)};function _i(t,n){if(!Kr)switch(t.tailMode){case"hidden":n=t.tail;for(var o=null;n!==null;)n.alternate!==null&&(o=n),n=n.sibling;o===null?t.tail=null:o.sibling=null;break;case"collapsed":o=t.tail;for(var u=null;o!==null;)o.alternate!==null&&(u=o),o=o.sibling;u===null?n||t.tail===null?t.tail=null:t.tail.sibling=null:u.sibling=null}}function An(t){var n=t.alternate!==null&&t.alternate.child===t.child,o=0,u=0;if(n)for(var m=t.child;m!==null;)o|=m.lanes|m.childLanes,u|=m.subtreeFlags&14680064,u|=m.flags&14680064,m.return=t,m=m.sibling;else for(m=t.child;m!==null;)o|=m.lanes|m.childLanes,u|=m.subtreeFlags,u|=m.flags,m.return=t,m=m.sibling;return t.subtreeFlags|=u,t.childLanes=o,n}function Yd(t,n,o){var u=n.pendingProps;switch(Ia(n),n.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return An(n),null;case 1:return Yn(n.type)&&gs(),An(n),null;case 3:return u=n.stateNode,pi(),Zr(Vn),Zr(kn),dc(),u.pendingContext&&(u.context=u.pendingContext,u.pendingContext=null),(t===null||t.child===null)&&(Dl(n)?n.flags|=4:t===null||t.memoizedState.isDehydrated&&!(n.flags&256)||(n.flags|=1024,ws!==null&&(aa(ws),ws=null))),Xa(t,n),An(n),null;case 5:cc(n);var m=Vo(Zi.current);if(o=n.type,t!==null&&n.stateNode!=null)Xd(t,n,o,u,m),t.ref!==n.ref&&(n.flags|=512,n.flags|=2097152);else{if(!u){if(n.stateNode===null)throw Error(f(166));return An(n),null}if(t=Vo(ro.current),Dl(n)){u=n.stateNode,o=n.type;var M=n.memoizedProps;switch(u[As]=n,u[ei]=M,t=(n.mode&1)!==0,o){case"dialog":Gr("cancel",u),Gr("close",u);break;case"iframe":case"object":case"embed":Gr("load",u);break;case"video":case"audio":for(m=0;m<Di.length;m++)Gr(Di[m],u);break;case"source":Gr("error",u);break;case"img":case"image":case"link":Gr("error",u),Gr("load",u);break;case"details":Gr("toggle",u);break;case"input":Xe(u,M),Gr("invalid",u);break;case"select":u._wrapperState={wasMultiple:!!M.multiple},Gr("invalid",u);break;case"textarea":Z(u,M),Gr("invalid",u)}an(o,M),m=null;for(var K in M)if(M.hasOwnProperty(K)){var e=M[K];K==="children"?typeof e=="string"?u.textContent!==e&&(M.suppressHydrationWarning!==!0&&Ni(u.textContent,e,t),m=["children",e]):typeof e=="number"&&u.textContent!==""+e&&(M.suppressHydrationWarning!==!0&&Ni(u.textContent,e,t),m=["children",""+e]):R.hasOwnProperty(K)&&e!=null&&K==="onScroll"&&Gr("scroll",u)}switch(o){case"input":Re(u),Et(u,M,!0);break;case"textarea":Re(u),Ne(u);break;case"select":case"option":break;default:typeof M.onClick=="function"&&(u.onclick=Ui)}u=m,n.updateQueue=u,u!==null&&(n.flags|=4)}else{K=m.nodeType===9?m:m.ownerDocument,t==="http://www.w3.org/1999/xhtml"&&(t=at(o)),t==="http://www.w3.org/1999/xhtml"?o==="script"?(t=K.createElement("div"),t.innerHTML="<script><\/script>",t=t.removeChild(t.firstChild)):typeof u.is=="string"?t=K.createElement(o,{is:u.is}):(t=K.createElement(o),o==="select"&&(K=t,u.multiple?K.multiple=!0:u.size&&(K.size=u.size))):t=K.createElementNS(t,o),t[As]=n,t[ei]=u,Rc(t,n,!1,!1),n.stateNode=t;e:{switch(K=Pn(o,u),o){case"dialog":Gr("cancel",t),Gr("close",t),m=u;break;case"iframe":case"object":case"embed":Gr("load",t),m=u;break;case"video":case"audio":for(m=0;m<Di.length;m++)Gr(Di[m],t);m=u;break;case"source":Gr("error",t),m=u;break;case"img":case"image":case"link":Gr("error",t),Gr("load",t),m=u;break;case"details":Gr("toggle",t),m=u;break;case"input":Xe(t,u),m=st(t,u),Gr("invalid",t);break;case"option":m=u;break;case"select":t._wrapperState={wasMultiple:!!u.multiple},m=ue({},u,{value:void 0}),Gr("invalid",t);break;case"textarea":Z(t,u),m=_e(t,u),Gr("invalid",t);break;default:m=u}an(o,m),e=m;for(M in e)if(e.hasOwnProperty(M)){var r=e[M];M==="style"?Cr(t,r):M==="dangerouslySetInnerHTML"?(r=r?r.__html:void 0,r!=null&&zt(t,r)):M==="children"?typeof r=="string"?(o!=="textarea"||r!=="")&&$t(t,r):typeof r=="number"&&$t(t,""+r):M!=="suppressContentEditableWarning"&&M!=="suppressHydrationWarning"&&M!=="autoFocus"&&(R.hasOwnProperty(M)?r!=null&&M==="onScroll"&&Gr("scroll",t):r!=null&&pe(t,M,r,K))}switch(o){case"input":Re(t),Et(t,u,!1);break;case"textarea":Re(t),Ne(t);break;case"option":u.value!=null&&t.setAttribute("value",""+Je(u.value));break;case"select":t.multiple=!!u.multiple,M=u.value,M!=null?U(t,!!u.multiple,M,!1):u.defaultValue!=null&&U(t,!!u.multiple,u.defaultValue,!0);break;default:typeof m.onClick=="function"&&(t.onclick=Ui)}switch(o){case"button":case"input":case"select":case"textarea":u=!!u.autoFocus;break e;case"img":u=!0;break e;default:u=!1}}u&&(n.flags|=4)}n.ref!==null&&(n.flags|=512,n.flags|=2097152)}return An(n),null;case 6:if(t&&n.stateNode!=null)ou(t,n,t.memoizedProps,u);else{if(typeof u!="string"&&n.stateNode===null)throw Error(f(166));if(o=Vo(Zi.current),Vo(ro.current),Dl(n)){if(u=n.stateNode,o=n.memoizedProps,u[As]=n,(M=u.nodeValue!==o)&&(t=$n,t!==null))switch(t.tag){case 3:Ni(u.nodeValue,o,(t.mode&1)!==0);break;case 5:t.memoizedProps.suppressHydrationWarning!==!0&&Ni(u.nodeValue,o,(t.mode&1)!==0)}M&&(n.flags|=4)}else u=(o.nodeType===9?o:o.ownerDocument).createTextNode(u),u[As]=n,n.stateNode=u}return An(n),null;case 13:if(Zr(Hr),u=n.memoizedState,t===null||t.memoizedState!==null&&t.memoizedState.dehydrated!==null){if(Kr&&Gn!==null&&n.mode&1&&!(n.flags&128))zl(),ii(),n.flags|=98560,M=!1;else if(M=Dl(n),u!==null&&u.dehydrated!==null){if(t===null){if(!M)throw Error(f(318));if(M=n.memoizedState,M=M!==null?M.dehydrated:null,!M)throw Error(f(317));M[As]=n}else ii(),!(n.flags&128)&&(n.memoizedState=null),n.flags|=4;An(n),M=!1}else ws!==null&&(aa(ws),ws=null),M=!0;if(!M)return n.flags&65536?n:null}return n.flags&128?(n.lanes=o,n):(u=u!==null,u!==(t!==null&&t.memoizedState!==null)&&u&&(n.child.flags|=8192,n.mode&1&&(t===null||Hr.current&1?ze===0&&(ze=3):la())),n.updateQueue!==null&&(n.flags|=4),An(n),null);case 4:return pi(),Xa(t,n),t===null&&Bi(n.stateNode.containerInfo),An(n),null;case 10:return Oa(n.type._context),An(n),null;case 17:return Yn(n.type)&&gs(),An(n),null;case 19:if(Zr(Hr),M=n.memoizedState,M===null)return An(n),null;if(u=(n.flags&128)!==0,K=M.rendering,K===null)if(u)_i(M,!1);else{if(ze!==0||t!==null&&t.flags&128)for(t=n.child;t!==null;){if(K=Go(t),K!==null){for(n.flags|=128,_i(M,!1),u=K.updateQueue,u!==null&&(n.updateQueue=u,n.flags|=4),n.subtreeFlags=0,u=o,o=n.child;o!==null;)M=o,t=u,M.flags&=14680066,K=M.alternate,K===null?(M.childLanes=0,M.lanes=t,M.child=null,M.subtreeFlags=0,M.memoizedProps=null,M.memoizedState=null,M.updateQueue=null,M.dependencies=null,M.stateNode=null):(M.childLanes=K.childLanes,M.lanes=K.lanes,M.child=K.child,M.subtreeFlags=0,M.deletions=null,M.memoizedProps=K.memoizedProps,M.memoizedState=K.memoizedState,M.updateQueue=K.updateQueue,M.type=K.type,t=K.dependencies,M.dependencies=t===null?null:{lanes:t.lanes,firstContext:t.firstContext}),o=o.sibling;return Ur(Hr,Hr.current&1|2),n.child}t=t.sibling}M.tail!==null&&Yr()>Vt&&(n.flags|=128,u=!0,_i(M,!1),n.lanes=4194304)}else{if(!u)if(t=Go(K),t!==null){if(n.flags|=128,u=!0,o=t.updateQueue,o!==null&&(n.updateQueue=o,n.flags|=4),_i(M,!0),M.tail===null&&M.tailMode==="hidden"&&!K.alternate&&!Kr)return An(n),null}else 2*Yr()-M.renderingStartTime>Vt&&o!==1073741824&&(n.flags|=128,u=!0,_i(M,!1),n.lanes=4194304);M.isBackwards?(K.sibling=n.child,n.child=K):(o=M.last,o!==null?o.sibling=K:n.child=K,M.last=K)}return M.tail!==null?(n=M.tail,M.rendering=n,M.tail=n.sibling,M.renderingStartTime=Yr(),n.sibling=null,o=Hr.current,Ur(Hr,u?o&1|2:o&1),n):(An(n),null);case 22:case 23:return Co(),u=n.memoizedState!==null,t!==null&&t.memoizedState!==null!==u&&(n.flags|=8192),u&&n.mode&1?$e&1073741824&&(An(n),n.subtreeFlags&6&&(n.flags|=8192)):An(n),null;case 24:return null;case 25:return null}throw Error(f(156,n.tag))}function Jd(t,n){switch(Ia(n),n.tag){case 1:return Yn(n.type)&&gs(),t=n.flags,t&65536?(n.flags=t&-65537|128,n):null;case 3:return pi(),Zr(Vn),Zr(kn),dc(),t=n.flags,t&65536&&!(t&128)?(n.flags=t&-65537|128,n):null;case 5:return cc(n),null;case 13:if(Zr(Hr),t=n.memoizedState,t!==null&&t.dehydrated!==null){if(n.alternate===null)throw Error(f(340));ii()}return t=n.flags,t&65536?(n.flags=t&-65537|128,n):null;case 19:return Zr(Hr),null;case 4:return pi(),null;case 10:return Oa(n.type._context),null;case 22:case 23:return Co(),null;case 24:return null;default:return null}}var Ya=!1,Ln=!1,Zd=typeof WeakSet=="function"?WeakSet:Set,Dt=null;function gi(t,n){var o=t.ref;if(o!==null)if(typeof o=="function")try{o(null)}catch(u){dn(t,n,u)}else o.current=null}function iu(t,n,o){try{o()}catch(u){dn(t,n,u)}}var ep=!1;function tp(t,n){if(Ca=ns,t=Du(),xl(t)){if("selectionStart"in t)var o={start:t.selectionStart,end:t.selectionEnd};else e:{o=(o=t.ownerDocument)&&o.defaultView||window;var u=o.getSelection&&o.getSelection();if(u&&u.rangeCount!==0){o=u.anchorNode;var m=u.anchorOffset,M=u.focusNode;u=u.focusOffset;try{o.nodeType,M.nodeType}catch{o=null;break e}var K=0,e=-1,r=-1,s=0,i=0,a=t,c=null;t:for(;;){for(var l;a!==o||m!==0&&a.nodeType!==3||(e=K+m),a!==M||u!==0&&a.nodeType!==3||(r=K+u),a.nodeType===3&&(K+=a.nodeValue.length),(l=a.firstChild)!==null;)c=a,a=l;for(;;){if(a===t)break t;if(c===o&&++s===m&&(e=K),c===M&&++i===u&&(r=K),(l=a.nextSibling)!==null)break;a=c,c=a.parentNode}a=l}o=e===-1||r===-1?null:{start:e,end:r}}else o=null}o=o||{start:0,end:0}}else o=null;for(Sa={focusedElem:t,selectionRange:o},ns=!1,Dt=n;Dt!==null;)if(n=Dt,t=n.child,(n.subtreeFlags&1028)!==0&&t!==null)t.return=n,Dt=t;else for(;Dt!==null;){n=Dt;try{var h=n.alternate;if(n.flags&1024)switch(n.tag){case 0:case 11:case 15:break;case 1:if(h!==null){var _=h.memoizedProps,w=h.memoizedState,v=n.stateNode,y=v.getSnapshotBeforeUpdate(n.elementType===n.type?_:us(n.type,_),w);v.__reactInternalSnapshotBeforeUpdate=y}break;case 3:var d=n.stateNode.containerInfo;d.nodeType===1?d.textContent="":d.nodeType===9&&d.documentElement&&d.removeChild(d.documentElement);break;case 5:case 6:case 4:case 17:break;default:throw Error(f(163))}}catch(S){dn(n,n.return,S)}if(t=n.sibling,t!==null){t.return=n.return,Dt=t;break}Dt=n.return}return h=ep,ep=!1,h}function ia(t,n,o){var u=n.updateQueue;if(u=u!==null?u.lastEffect:null,u!==null){var m=u=u.next;do{if((m.tag&t)===t){var M=m.destroy;m.destroy=void 0,M!==void 0&&iu(n,o,M)}m=m.next}while(m!==u)}}function Ja(t,n){if(n=n.updateQueue,n=n!==null?n.lastEffect:null,n!==null){var o=n=n.next;do{if((o.tag&t)===t){var u=o.create;o.destroy=u()}o=o.next}while(o!==n)}}function jc(t){var n=t.ref;if(n!==null){var o=t.stateNode;switch(t.tag){case 5:t=o;break;default:t=o}typeof n=="function"?n(t):n.current=t}}function Nc(t){var n=t.alternate;n!==null&&(t.alternate=null,Nc(n)),t.child=null,t.deletions=null,t.sibling=null,t.tag===5&&(n=t.stateNode,n!==null&&(delete n[As],delete n[ei],delete n[Fl],delete n[Fd],delete n[Zu])),t.stateNode=null,t.return=null,t.dependencies=null,t.memoizedProps=null,t.memoizedState=null,t.pendingProps=null,t.stateNode=null,t.updateQueue=null}function Uc(t){return t.tag===5||t.tag===3||t.tag===4}function Vc(t){e:for(;;){for(;t.sibling===null;){if(t.return===null||Uc(t.return))return null;t=t.return}for(t.sibling.return=t.return,t=t.sibling;t.tag!==5&&t.tag!==6&&t.tag!==18;){if(t.flags&2||t.child===null||t.tag===4)continue e;t.child.return=t,t=t.child}if(!(t.flags&2))return t.stateNode}}function au(t,n,o){var u=t.tag;if(u===5||u===6)t=t.stateNode,n?o.nodeType===8?o.parentNode.insertBefore(t,n):o.insertBefore(t,n):(o.nodeType===8?(n=o.parentNode,n.insertBefore(t,o)):(n=o,n.appendChild(t)),o=o._reactRootContainer,o!=null||n.onclick!==null||(n.onclick=Ui));else if(u!==4&&(t=t.child,t!==null))for(au(t,n,o),t=t.sibling;t!==null;)au(t,n,o),t=t.sibling}function lu(t,n,o){var u=t.tag;if(u===5||u===6)t=t.stateNode,n?o.insertBefore(t,n):o.appendChild(t);else if(u!==4&&(t=t.child,t!==null))for(lu(t,n,o),t=t.sibling;t!==null;)lu(t,n,o),t=t.sibling}var Tn=null,vs=!1;function Eo(t,n,o){for(o=o.child;o!==null;)Wc(t,n,o),o=o.sibling}function Wc(t,n,o){if(jn&&typeof jn.onCommitFiberUnmount=="function")try{jn.onCommitFiberUnmount(co,o)}catch{}switch(o.tag){case 5:Ln||gi(o,n);case 6:var u=Tn,m=vs;Tn=null,Eo(t,n,o),Tn=u,vs=m,Tn!==null&&(vs?(t=Tn,o=o.stateNode,t.nodeType===8?t.parentNode.removeChild(o):t.removeChild(o)):Tn.removeChild(o.stateNode));break;case 18:Tn!==null&&(vs?(t=Tn,o=o.stateNode,t.nodeType===8?Il(t.parentNode,o):t.nodeType===1&&Il(t,o),Jt(t)):Il(Tn,o.stateNode));break;case 4:u=Tn,m=vs,Tn=o.stateNode.containerInfo,vs=!0,Eo(t,n,o),Tn=u,vs=m;break;case 0:case 11:case 14:case 15:if(!Ln&&(u=o.updateQueue,u!==null&&(u=u.lastEffect,u!==null))){m=u=u.next;do{var M=m,K=M.destroy;M=M.tag,K!==void 0&&(M&2||M&4)&&iu(o,n,K),m=m.next}while(m!==u)}Eo(t,n,o);break;case 1:if(!Ln&&(gi(o,n),u=o.stateNode,typeof u.componentWillUnmount=="function"))try{u.props=o.memoizedProps,u.state=o.memoizedState,u.componentWillUnmount()}catch(e){dn(o,n,e)}Eo(t,n,o);break;case 21:Eo(t,n,o);break;case 22:o.mode&1?(Ln=(u=Ln)||o.memoizedState!==null,Eo(t,n,o),Ln=u):Eo(t,n,o);break;default:Eo(t,n,o)}}function Gc(t){var n=t.updateQueue;if(n!==null){t.updateQueue=null;var o=t.stateNode;o===null&&(o=t.stateNode=new Zd),n.forEach(function(u){var m=$p.bind(null,t,u);o.has(u)||(o.add(u),u.then(m,m))})}}function Ms(t,n){var o=n.deletions;if(o!==null)for(var u=0;u<o.length;u++){var m=o[u];try{var M=t,K=n,e=K;e:for(;e!==null;){switch(e.tag){case 5:Tn=e.stateNode,vs=!1;break e;case 3:Tn=e.stateNode.containerInfo,vs=!0;break e;case 4:Tn=e.stateNode.containerInfo,vs=!0;break e}e=e.return}if(Tn===null)throw Error(f(160));Wc(M,K,m),Tn=null,vs=!1;var r=m.alternate;r!==null&&(r.return=null),m.return=null}catch(s){dn(m,n,s)}}if(n.subtreeFlags&12854)for(n=n.child;n!==null;)uu(n,t),n=n.sibling}function uu(t,n){var o=t.alternate,u=t.flags;switch(t.tag){case 0:case 11:case 14:case 15:if(Ms(n,t),Ls(t),u&4){try{ia(3,t,t.return),Ja(3,t)}catch(_){dn(t,t.return,_)}try{ia(5,t,t.return)}catch(_){dn(t,t.return,_)}}break;case 1:Ms(n,t),Ls(t),u&512&&o!==null&&gi(o,o.return);break;case 5:if(Ms(n,t),Ls(t),u&512&&o!==null&&gi(o,o.return),t.flags&32){var m=t.stateNode;try{$t(m,"")}catch(_){dn(t,t.return,_)}}if(u&4&&(m=t.stateNode,m!=null)){var M=t.memoizedProps,K=o!==null?o.memoizedProps:M,e=t.type,r=t.updateQueue;if(t.updateQueue=null,r!==null)try{e==="input"&&M.type==="radio"&&M.name!=null&&pt(m,M),Pn(e,K);var s=Pn(e,M);for(K=0;K<r.length;K+=2){var i=r[K],a=r[K+1];i==="style"?Cr(m,a):i==="dangerouslySetInnerHTML"?zt(m,a):i==="children"?$t(m,a):pe(m,i,a,s)}switch(e){case"input":_t(m,M);break;case"textarea":xe(m,M);break;case"select":var c=m._wrapperState.wasMultiple;m._wrapperState.wasMultiple=!!M.multiple;var l=M.value;l!=null?U(m,!!M.multiple,l,!1):c!==!!M.multiple&&(M.defaultValue!=null?U(m,!!M.multiple,M.defaultValue,!0):U(m,!!M.multiple,M.multiple?[]:"",!1))}m[ei]=M}catch(_){dn(t,t.return,_)}}break;case 6:if(Ms(n,t),Ls(t),u&4){if(t.stateNode===null)throw Error(f(162));m=t.stateNode,M=t.memoizedProps;try{m.nodeValue=M}catch(_){dn(t,t.return,_)}}break;case 3:if(Ms(n,t),Ls(t),u&4&&o!==null&&o.memoizedState.isDehydrated)try{Jt(n.containerInfo)}catch(_){dn(t,t.return,_)}break;case 4:Ms(n,t),Ls(t);break;case 13:Ms(n,t),Ls(t),m=t.child,m.flags&8192&&(M=m.memoizedState!==null,m.stateNode.isHidden=M,!M||m.alternate!==null&&m.alternate.memoizedState!==null||(Qt=Yr())),u&4&&Gc(t);break;case 22:if(i=o!==null&&o.memoizedState!==null,t.mode&1?(Ln=(s=Ln)||i,Ms(n,t),Ln=s):Ms(n,t),Ls(t),u&8192){if(s=t.memoizedState!==null,(t.stateNode.isHidden=s)&&!i&&t.mode&1)for(Dt=t,i=t.child;i!==null;){for(a=Dt=i;Dt!==null;){switch(c=Dt,l=c.child,c.tag){case 0:case 11:case 14:case 15:ia(4,c,c.return);break;case 1:gi(c,c.return);var h=c.stateNode;if(typeof h.componentWillUnmount=="function"){u=c,o=c.return;try{n=u,h.props=n.memoizedProps,h.state=n.memoizedState,h.componentWillUnmount()}catch(_){dn(u,o,_)}}break;case 5:gi(c,c.return);break;case 22:if(c.memoizedState!==null){wn(a);continue}}l!==null?(l.return=c,Dt=l):wn(a)}i=i.sibling}e:for(i=null,a=t;;){if(a.tag===5){if(i===null){i=a;try{m=a.stateNode,s?(M=m.style,typeof M.setProperty=="function"?M.setProperty("display","none","important"):M.display="none"):(e=a.stateNode,r=a.memoizedProps.style,K=r!=null&&r.hasOwnProperty("display")?r.display:null,e.style.display=gr("display",K))}catch(_){dn(t,t.return,_)}}}else if(a.tag===6){if(i===null)try{a.stateNode.nodeValue=s?"":a.memoizedProps}catch(_){dn(t,t.return,_)}}else if((a.tag!==22&&a.tag!==23||a.memoizedState===null||a===t)&&a.child!==null){a.child.return=a,a=a.child;continue}if(a===t)break e;for(;a.sibling===null;){if(a.return===null||a.return===t)break e;i===a&&(i=null),a=a.return}i===a&&(i=null),a.sibling.return=a.return,a=a.sibling}}break;case 19:Ms(n,t),Ls(t),u&4&&Gc(t);break;case 21:break;default:Ms(n,t),Ls(t)}}function Ls(t){var n=t.flags;if(n&2){try{e:{for(var o=t.return;o!==null;){if(Uc(o)){var u=o;break e}o=o.return}throw Error(f(160))}switch(u.tag){case 5:var m=u.stateNode;u.flags&32&&($t(m,""),u.flags&=-33);var M=Vc(t);lu(t,M,m);break;case 3:case 4:var K=u.stateNode.containerInfo,e=Vc(t);au(t,e,K);break;default:throw Error(f(161))}}catch(r){dn(t,t.return,r)}t.flags&=-3}n&4096&&(t.flags&=-4097)}function _p(t,n,o){Dt=t,lr(t)}function lr(t,n,o){for(var u=(t.mode&1)!==0;Dt!==null;){var m=Dt,M=m.child;if(m.tag===22&&u){var K=m.memoizedState!==null||Ya;if(!K){var e=m.alternate,r=e!==null&&e.memoizedState!==null||Ln;e=Ya;var s=Ln;if(Ya=K,(Ln=r)&&!s)for(Dt=m;Dt!==null;)K=Dt,r=K.child,K.tag===22&&K.memoizedState!==null?bn(m):r!==null?(r.return=K,Dt=r):bn(m);for(;M!==null;)Dt=M,lr(M),M=M.sibling;Dt=m,Ya=e,Ln=s}Kc(t)}else m.subtreeFlags&8772&&M!==null?(M.return=m,Dt=M):Kc(t)}}function Kc(t){for(;Dt!==null;){var n=Dt;if(n.flags&8772){var o=n.alternate;try{if(n.flags&8772)switch(n.tag){case 0:case 11:case 15:Ln||Ja(5,n);break;case 1:var u=n.stateNode;if(n.flags&4&&!Ln)if(o===null)u.componentDidMount();else{var m=n.elementType===n.type?o.memoizedProps:us(n.type,o.memoizedProps);u.componentDidUpdate(m,o.memoizedState,u.__reactInternalSnapshotBeforeUpdate)}var M=n.updateQueue;M!==null&&lc(n,M,u);break;case 3:var K=n.updateQueue;if(K!==null){if(o=null,n.child!==null)switch(n.child.tag){case 5:o=n.child.stateNode;break;case 1:o=n.child.stateNode}lc(n,K,o)}break;case 5:var e=n.stateNode;if(o===null&&n.flags&4){o=e;var r=n.memoizedProps;switch(n.type){case"button":case"input":case"select":case"textarea":r.autoFocus&&o.focus();break;case"img":r.src&&(o.src=r.src)}}break;case 6:break;case 4:break;case 12:break;case 13:if(n.memoizedState===null){var s=n.alternate;if(s!==null){var i=s.memoizedState;if(i!==null){var a=i.dehydrated;a!==null&&Jt(a)}}}break;case 19:case 17:case 21:case 22:case 23:case 25:break;default:throw Error(f(163))}Ln||n.flags&512&&jc(n)}catch(c){dn(n,n.return,c)}}if(n===t){Dt=null;break}if(o=n.sibling,o!==null){o.return=n.return,Dt=o;break}Dt=n.return}}function wn(t){for(;Dt!==null;){var n=Dt;if(n===t){Dt=null;break}var o=n.sibling;if(o!==null){o.return=n.return,Dt=o;break}Dt=n.return}}function bn(t){for(;Dt!==null;){var n=Dt;try{switch(n.tag){case 0:case 11:case 15:var o=n.return;try{Ja(4,n)}catch(r){dn(n,o,r)}break;case 1:var u=n.stateNode;if(typeof u.componentDidMount=="function"){var m=n.return;try{u.componentDidMount()}catch(r){dn(n,m,r)}}var M=n.return;try{jc(n)}catch(r){dn(n,M,r)}break;case 5:var K=n.return;try{jc(n)}catch(r){dn(n,K,r)}}}catch(r){dn(n,n.return,r)}if(n===t){Dt=null;break}var e=n.sibling;if(e!==null){e.return=n.return,Dt=e;break}Dt=n.return}}var Dn=Math.ceil,Po=X.ReactCurrentDispatcher,Hc=X.ReactCurrentOwner,cs=X.ReactCurrentBatchConfig,Tr=0,T=null,O=null,G=0,$e=0,Ue=Qs(0),ze=0,rt=null,ut=0,Mt=0,At=0,Kt=null,Ot=null,Qt=0,Vt=1/0,nr=null,dr=!1,sr=null,pr=null,sn=!1,br=null,Br=0,Or=0,qr=null,_n=-1,un=0;function tn(){return Tr&6?Yr():_n!==-1?_n:_n=Yr()}function xs(t){return t.mode&1?Tr&2&&G!==0?G&-G:Dd.transition!==null?(un===0&&(un=I()),un):(t=Ge,t!==0||(t=window.event,t=t===void 0?16:al(t.type)),t):1}function ds(t,n,o,u){if(50<Or)throw Or=0,qr=null,Error(f(185));we(t,o,u),(!(Tr&2)||t!==T)&&(t===T&&(!(Tr&2)&&(Mt|=o),ze===4&&zs(t,G)),Qr(t,u),o===1&&Tr===0&&!(n.mode&1)&&(Vt=Yr()+500,Gi&&xo()))}function Qr(t,n){var o=t.callbackNode;kr(t,n);var u=Ks(t,t===T?G:0);if(u===0)o!==null&&Ci(o),t.callbackNode=null,t.callbackPriority=0;else if(n=u&-u,t.callbackPriority!==n){if(o!=null&&Ci(o),n===1)t.tag===0?Od(Xr.bind(null,t)):Hi(Xr.bind(null,t)),Ad(function(){!(Tr&6)&&xo()}),o=null;else{switch(mt(u)){case 1:o=Gs;break;case 4:o=ms;break;case 16:o=Rn;break;case 536870912:o=Ao;break;default:o=Rn}o=ua(o,Ds.bind(null,t))}t.callbackPriority=n,t.callbackNode=o}}function Ds(t,n){if(_n=-1,un=0,Tr&6)throw Error(f(327));var o=t.callbackNode;if(So()&&t.callbackNode!==o)return null;var u=Ks(t,t===T?G:0);if(u===0)return null;if(u&30||u&t.expiredLanes||n)n=yi(t,u);else{n=u;var m=Tr;Tr|=2;var M=pu();(T!==t||G!==n)&&(nr=null,Vt=Yr()+500,Ts(t,n));do try{Qc();break}catch(e){du(t,e)}while(!0);jl(),Po.current=M,Tr=m,O!==null?n=0:(T=null,G=0,n=ze)}if(n!==0){if(n===2&&(m=Oe(t),m!==0&&(u=m,n=cu(t,m))),n===1)throw o=rt,Ts(t,0),zs(t,u),Qr(t,Yr()),o;if(n===6)zs(t,u);else{if(m=t.current.alternate,!(u&30)&&!qc(m)&&(n=yi(t,u),n===2&&(M=Oe(t),M!==0&&(u=M,n=cu(t,M))),n===1))throw o=rt,Ts(t,0),zs(t,u),Qr(t,Yr()),o;switch(t.finishedWork=m,t.finishedLanes=u,n){case 0:case 1:throw Error(f(345));case 2:Ho(t,Ot,nr);break;case 3:if(zs(t,u),(u&130023424)===u&&(n=Qt+500-Yr(),10<n)){if(Ks(t,0)!==0)break;if(m=t.suspendedLanes,(m&u)!==u){tn(),t.pingedLanes|=t.suspendedLanes&m;break}t.timeoutHandle=$l(Ho.bind(null,t,Ot,nr),n);break}Ho(t,Ot,nr);break;case 4:if(zs(t,u),(u&4194240)===u)break;for(n=t.eventTimes,m=-1;0<u;){var K=31-Rt(u);M=1<<K,K=n[K],K>m&&(m=K),u&=~M}if(u=m,u=Yr()-u,u=(120>u?120:480>u?480:1080>u?1080:1920>u?1920:3e3>u?3e3:4320>u?4320:1960*Dn(u/1960))-u,10<u){t.timeoutHandle=$l(Ho.bind(null,t,Ot,nr),u);break}Ho(t,Ot,nr);break;case 5:Ho(t,Ot,nr);break;default:throw Error(f(329))}}}return Qr(t,Yr()),t.callbackNode===o?Ds.bind(null,t):null}function cu(t,n){var o=Kt;return t.current.memoizedState.isDehydrated&&(Ts(t,n).flags|=256),t=yi(t,n),t!==2&&(n=Ot,Ot=o,n!==null&&aa(n)),t}function aa(t){Ot===null?Ot=t:Ot.push.apply(Ot,t)}function qc(t){for(var n=t;;){if(n.flags&16384){var o=n.updateQueue;if(o!==null&&(o=o.stores,o!==null))for(var u=0;u<o.length;u++){var m=o[u],M=m.getSnapshot;m=m.value;try{if(!_s(M(),m))return!1}catch{return!1}}}if(o=n.child,n.subtreeFlags&16384&&o!==null)o.return=n,n=o;else{if(n===t)break;for(;n.sibling===null;){if(n.return===null||n.return===t)return!0;n=n.return}n.sibling.return=n.return,n=n.sibling}}return!0}function zs(t,n){for(n&=~At,n&=~Mt,t.suspendedLanes|=n,t.pingedLanes&=~n,t=t.expirationTimes;0<n;){var o=31-Rt(n),u=1<<o;t[o]=-1,n&=~u}}function Xr(t){if(Tr&6)throw Error(f(327));So();var n=Ks(t,0);if(!(n&1))return Qr(t,Yr()),null;var o=yi(t,n);if(t.tag!==0&&o===2){var u=Oe(t);u!==0&&(n=u,o=cu(t,u))}if(o===1)throw o=rt,Ts(t,0),zs(t,n),Qr(t,Yr()),o;if(o===6)throw Error(f(345));return t.finishedWork=t.current.alternate,t.finishedLanes=n,Ho(t,Ot,nr),Qr(t,Yr()),null}function cn(t,n){var o=Tr;Tr|=1;try{return t(n)}finally{Tr=o,Tr===0&&(Vt=Yr()+500,Gi&&xo())}}function Zn(t){br!==null&&br.tag===0&&!(Tr&6)&&So();var n=Tr;Tr|=1;var o=cs.transition,u=Ge;try{if(cs.transition=null,Ge=1,t)return t()}finally{Ge=u,cs.transition=o,Tr=n,!(Tr&6)&&xo()}}function Co(){$e=Ue.current,Zr(Ue)}function Ts(t,n){t.finishedWork=null,t.finishedLanes=0;var o=t.timeoutHandle;if(o!==-1&&(t.timeoutHandle=-1,Yu(o)),O!==null)for(o=O.return;o!==null;){var u=o;switch(Ia(u),u.tag){case 1:u=u.type.childContextTypes,u!=null&&gs();break;case 3:pi(),Zr(Vn),Zr(kn),dc();break;case 5:cc(u);break;case 4:pi();break;case 13:Zr(Hr);break;case 19:Zr(Hr);break;case 10:Oa(u.type._context);break;case 22:case 23:Co()}o=o.return}if(T=t,O=t=vi(t.current,null),G=$e=n,ze=0,rt=null,At=Mt=ut=0,Ot=Kt=null,ci!==null){for(n=0;n<ci.length;n++)if(o=ci[n],u=o.interleaved,u!==null){o.interleaved=null;var m=u.next,M=o.pending;if(M!==null){var K=M.next;M.next=m,u.next=K}o.pending=u}ci=null}return t}function du(t,n){do{var o=O;try{if(jl(),Ba.current=ra,Ra){for(var u=en.memoizedState;u!==null;){var m=u.queue;m!==null&&(m.pending=null),u=u.next}Ra=!1}if(Ko=0,mn=hn=en=null,ja=!1,hi=0,Hc.current=null,o===null||o.return===null){ze=1,rt=n,O=null;break}e:{var M=t,K=o.return,e=o,r=n;if(n=G,e.flags|=32768,r!==null&&typeof r=="object"&&typeof r.then=="function"){var s=r,i=e,a=i.tag;if(!(i.mode&1)&&(a===0||a===11||a===15)){var c=i.alternate;c?(i.updateQueue=c.updateQueue,i.memoizedState=c.memoizedState,i.lanes=c.lanes):(i.updateQueue=null,i.memoizedState=null)}var l=Gd(K);if(l!==null){l.flags&=-257,kc(l,K,e,M,n),l.mode&1&&Sc(M,s,n),n=l,r=s;var h=n.updateQueue;if(h===null){var _=new Set;_.add(r),n.updateQueue=_}else h.add(r);break e}else{if(!(n&1)){Sc(M,s,n),la();break e}r=Error(f(426))}}else if(Kr&&e.mode&1){var w=Gd(K);if(w!==null){!(w.flags&65536)&&(w.flags|=256),kc(w,K,e,M,n),Bl(vr(r,e));break e}}M=r=vr(r,e),ze!==4&&(ze=2),Kt===null?Kt=[M]:Kt.push(M),M=K;do{switch(M.tag){case 3:M.flags|=65536,n&=-n,M.lanes|=n;var v=Zl(M,r,n);Da(M,v);break e;case 1:e=r;var y=M.type,d=M.stateNode;if(!(M.flags&128)&&(typeof y.getDerivedStateFromError=="function"||d!==null&&typeof d.componentDidCatch=="function"&&(pr===null||!pr.has(d)))){M.flags|=65536,n&=-n,M.lanes|=n;var S=Cc(M,e,n);Da(M,S);break e}}M=M.return}while(M!==null)}Za(o)}catch(B){n=B,O===o&&o!==null&&(O=o=o.return);continue}break}while(!0)}function pu(){var t=Po.current;return Po.current=ra,t===null?ra:t}function la(){(ze===0||ze===3||ze===2)&&(ze=4),T===null||!(ut&268435455)&&!(Mt&268435455)||zs(T,G)}function yi(t,n){var o=Tr;Tr|=2;var u=pu();(T!==t||G!==n)&&(nr=null,Ts(t,n));do try{gp();break}catch(m){du(t,m)}while(!0);if(jl(),Tr=o,Po.current=u,O!==null)throw Error(f(261));return T=null,G=0,ze}function gp(){for(;O!==null;)fu(O)}function Qc(){for(;O!==null&&!uo();)fu(O)}function fu(t){var n=wp(t.alternate,t,$e);t.memoizedProps=t.pendingProps,n===null?Za(t):O=n,Hc.current=null}function Za(t){var n=t;do{var o=n.alternate;if(t=n.return,n.flags&32768){if(o=Jd(o,n),o!==null){o.flags&=32767,O=o;return}if(t!==null)t.flags|=32768,t.subtreeFlags=0,t.deletions=null;else{ze=6,O=null;return}}else if(o=Yd(o,n,$e),o!==null){O=o;return}if(n=n.sibling,n!==null){O=n;return}O=n=t}while(n!==null);ze===0&&(ze=5)}function Ho(t,n,o){var u=Ge,m=cs.transition;try{cs.transition=null,Ge=1,rp(t,n,o,u)}finally{cs.transition=m,Ge=u}return null}function rp(t,n,o,u){do So();while(br!==null);if(Tr&6)throw Error(f(327));o=t.finishedWork;var m=t.finishedLanes;if(o===null)return null;if(t.finishedWork=null,t.finishedLanes=0,o===t.current)throw Error(f(177));t.callbackNode=null,t.callbackPriority=0;var M=o.lanes|o.childLanes;if(Ie(t,M),t===T&&(O=T=null,G=0),!(o.subtreeFlags&2064)&&!(o.flags&2064)||sn||(sn=!0,ua(Rn,function(){return So(),null})),M=(o.flags&15990)!==0,o.subtreeFlags&15990||M){M=cs.transition,cs.transition=null;var K=Ge;Ge=1;var e=Tr;Tr|=4,Hc.current=null,tp(t,o),uu(o,t),Sd(Sa),ns=!!Ca,Sa=Ca=null,t.current=o,_p(o),ma(),Tr=e,Ge=K,cs.transition=M}else t.current=o;if(sn&&(sn=!1,br=t,Br=m),M=t.pendingLanes,M===0&&(pr=null),po(o.stateNode),Qr(t,Yr()),n!==null)for(u=t.onRecoverableError,o=0;o<n.length;o++)m=n[o],u(m.value,{componentStack:m.stack,digest:m.digest});if(dr)throw dr=!1,t=sr,sr=null,t;return Br&1&&t.tag!==0&&So(),M=t.pendingLanes,M&1?t===qr?Or++:(Or=0,qr=t):Or=0,xo(),null}function So(){if(br!==null){var t=mt(Br),n=cs.transition,o=Ge;try{if(cs.transition=null,Ge=16>t?16:t,br===null)var u=!1;else{if(t=br,br=null,Br=0,Tr&6)throw Error(f(331));var m=Tr;for(Tr|=4,Dt=t.current;Dt!==null;){var M=Dt,K=M.child;if(Dt.flags&16){var e=M.deletions;if(e!==null){for(var r=0;r<e.length;r++){var s=e[r];for(Dt=s;Dt!==null;){var i=Dt;switch(i.tag){case 0:case 11:case 15:ia(8,i,M)}var a=i.child;if(a!==null)a.return=i,Dt=a;else for(;Dt!==null;){i=Dt;var c=i.sibling,l=i.return;if(Nc(i),i===s){Dt=null;break}if(c!==null){c.return=l,Dt=c;break}Dt=l}}}var h=M.alternate;if(h!==null){var _=h.child;if(_!==null){h.child=null;do{var w=_.sibling;_.sibling=null,_=w}while(_!==null)}}Dt=M}}if(M.subtreeFlags&2064&&K!==null)K.return=M,Dt=K;else e:for(;Dt!==null;){if(M=Dt,M.flags&2048)switch(M.tag){case 0:case 11:case 15:ia(9,M,M.return)}var v=M.sibling;if(v!==null){v.return=M.return,Dt=v;break e}Dt=M.return}}var y=t.current;for(Dt=y;Dt!==null;){K=Dt;var d=K.child;if(K.subtreeFlags&2064&&d!==null)d.return=K,Dt=d;else e:for(K=y;Dt!==null;){if(e=Dt,e.flags&2048)try{switch(e.tag){case 0:case 11:case 15:Ja(9,e)}}catch(B){dn(e,e.return,B)}if(e===K){Dt=null;break e}var S=e.sibling;if(S!==null){S.return=e.return,Dt=S;break e}Dt=e.return}}if(Tr=m,xo(),jn&&typeof jn.onPostCommitFiberRoot=="function")try{jn.onPostCommitFiberRoot(co,t)}catch{}u=!0}return u}finally{Ge=o,cs.transition=n}}return!1}function hu(t,n,o){n=vr(o,n),n=Zl(t,n,1),t=bo(t,n,1),n=tn(),t!==null&&(we(t,1,n),Qr(t,n))}function dn(t,n,o){if(t.tag===3)hu(t,t,o);else for(;n!==null;){if(n.tag===3){hu(n,t,o);break}else if(n.tag===1){var u=n.stateNode;if(typeof n.type.getDerivedStateFromError=="function"||typeof u.componentDidCatch=="function"&&(pr===null||!pr.has(u))){t=vr(o,t),t=Cc(n,t,1),n=bo(n,t,1),t=tn(),n!==null&&(we(n,1,t),Qr(n,t));break}}n=n.return}}function yp(t,n,o){var u=t.pingCache;u!==null&&u.delete(n),n=tn(),t.pingedLanes|=t.suspendedLanes&o,T===t&&(G&o)===o&&(ze===4||ze===3&&(G&130023424)===G&&500>Yr()-Qt?Ts(t,0):At|=o),Qr(t,n)}function wi(t,n){n===0&&(t.mode&1?(n=Fo,Fo<<=1,!(Fo&130023424)&&(Fo=4194304)):n=1);var o=tn();t=Zs(t,n),t!==null&&(we(t,n,o),Qr(t,o))}function Bs(t){var n=t.memoizedState,o=0;n!==null&&(o=n.retryLane),wi(t,o)}function $p(t,n){var o=0;switch(t.tag){case 13:var u=t.stateNode,m=t.memoizedState;m!==null&&(o=m.retryLane);break;case 19:u=t.stateNode;break;default:throw Error(f(314))}u!==null&&u.delete(n),wi(t,o)}var wp;wp=function(t,n,o){if(t!==null)if(t.memoizedProps!==n.pendingProps||Vn.current)On=!0;else{if(!(t.lanes&o)&&!(n.flags&128))return On=!1,Qd(t,n,o);On=!!(t.flags&131072)}else On=!1,Kr&&n.flags&1048576&&Ld(n,Qi,n.index);switch(n.lanes=0,n.tag){case 2:var u=n.type;oa(t,n),t=n.pendingProps;var m=ni(n,kn.current);ui(n,o),m=Vl(null,n,u,t,m,o);var M=fc();return n.flags|=1,typeof m=="object"&&m!==null&&typeof m.render=="function"&&m.$$typeof===void 0?(n.tag=1,n.memoizedState=null,n.updateQueue=null,Yn(u)?(M=!0,si(n)):M=!1,n.memoizedState=m.state!==null&&m.state!==void 0?m.state:null,di(n),m.updater=Ha,n.stateNode=m,m._reactInternals=n,qa(n,u,t,o),n=ru(null,n,u,!0,M,o)):(n.tag=0,Kr&&M&&$a(n),Kn(null,n,m,o),n=n.child),n;case 16:u=n.elementType;e:{switch(oa(t,n),t=n.pendingProps,m=u._init,u=m(u._payload),n.type=u,m=n.tag=Ip(u),t=us(u,t),m){case 0:n=tu(null,n,u,t,o);break e;case 1:n=Ac(null,n,u,t,o);break e;case 11:n=Ic(null,n,u,t,o);break e;case 14:n=Kd(null,n,u,us(u.type,t),o);break e}throw Error(f(306,u,""))}return n;case 0:return u=n.type,m=n.pendingProps,m=n.elementType===u?m:us(u,m),tu(t,n,u,m,o);case 1:return u=n.type,m=n.pendingProps,m=n.elementType===u?m:us(u,m),Ac(t,n,u,m,o);case 3:e:{if(Fc(n),t===null)throw Error(f(387));u=n.pendingProps,M=n.memoizedState,m=M.element,ac(t,n),Nl(n,u,null,o);var K=n.memoizedState;if(u=K.element,M.isDehydrated)if(M={element:u,isDehydrated:!1,cache:K.cache,pendingSuspenseBoundaries:K.pendingSuspenseBoundaries,transitions:K.transitions},n.updateQueue.baseState=M,n.memoizedState=M,n.flags&256){m=vr(Error(f(423)),n),n=Oc(t,n,u,o,m);break e}else if(u!==m){m=vr(Error(f(424)),n),n=Oc(t,n,u,o,m);break e}else for(Gn=go(n.stateNode.containerInfo.firstChild),$n=n,Kr=!0,ws=null,o=Rl(n,null,u,o),n.child=o;o;)o.flags=o.flags&-3|4096,o=o.sibling;else{if(ii(),u===m){n=Os(t,n,o);break e}Kn(t,n,u,o)}n=n.child}return n;case 5:return uc(n),t===null&&Aa(n),u=n.type,m=n.pendingProps,M=t!==null?t.memoizedProps:null,K=m.children,kl(u,m)?K=null:M!==null&&kl(u,M)&&(n.flags|=32),qd(t,n),Kn(t,n,K,o),n.child;case 6:return t===null&&Aa(n),null;case 13:return na(t,n,o);case 4:return Wo(n,n.stateNode.containerInfo),u=n.pendingProps,t===null?n.child=No(n,null,u,o):Kn(t,n,u,o),n.child;case 11:return u=n.type,m=n.pendingProps,m=n.elementType===u?m:us(u,m),Ic(t,n,u,m,o);case 7:return Kn(t,n,n.pendingProps,o),n.child;case 8:return Kn(t,n,n.pendingProps.children,o),n.child;case 12:return Kn(t,n,n.pendingProps.children,o),n.child;case 10:e:{if(u=n.type._context,m=n.pendingProps,M=n.memoizedProps,K=m.value,Ur(Fs,u._currentValue),u._currentValue=K,M!==null)if(_s(M.value,K)){if(M.children===m.children&&!Vn.current){n=Os(t,n,o);break e}}else for(M=n.child,M!==null&&(M.return=n);M!==null;){var e=M.dependencies;if(e!==null){K=M.child;for(var r=e.firstContext;r!==null;){if(r.context===u){if(M.tag===1){r=to(-1,o&-o),r.tag=2;var s=M.updateQueue;if(s!==null){s=s.shared;var i=s.pending;i===null?r.next=r:(r.next=i.next,i.next=r),s.pending=r}}M.lanes|=o,r=M.alternate,r!==null&&(r.lanes|=o),oc(M.return,o,n),e.lanes|=o;break}r=r.next}}else if(M.tag===10)K=M.type===n.type?null:M.child;else if(M.tag===18){if(K=M.return,K===null)throw Error(f(341));K.lanes|=o,e=K.alternate,e!==null&&(e.lanes|=o),oc(K,o,n),K=M.sibling}else K=M.child;if(K!==null)K.return=M;else for(K=M;K!==null;){if(K===n){K=null;break}if(M=K.sibling,M!==null){M.return=K.return,K=M;break}K=K.return}M=K}Kn(t,n,m.children,o),n=n.child}return n;case 9:return m=n.type,u=n.pendingProps.children,ui(n,o),m=Jn(m),u=u(m),n.flags|=1,Kn(t,n,u,o),n.child;case 14:return u=n.type,m=us(u,n.pendingProps),m=us(u.type,m),Kd(t,n,u,m,o);case 15:return eu(t,n,n.type,n.pendingProps,o);case 17:return u=n.type,m=n.pendingProps,m=n.elementType===u?m:us(u,m),oa(t,n),n.tag=1,Yn(u)?(t=!0,si(n)):t=!1,ui(n,o),Jl(n,u,m),qa(n,u,m,o),ru(null,n,u,!0,t,o);case 19:return Bc(t,n,o);case 22:return Hd(t,n,o)}throw Error(f(156,n.tag))};function ua(t,n){return Pi(t,n)}function Rp(t,n,o,u){this.tag=t,this.key=o,this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null,this.index=0,this.ref=null,this.pendingProps=n,this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null,this.mode=u,this.subtreeFlags=this.flags=0,this.deletions=null,this.childLanes=this.lanes=0,this.alternate=null}function bs(t,n,o,u){return new Rp(t,n,o,u)}function np(t){return t=t.prototype,!(!t||!t.isReactComponent)}function Ip(t){if(typeof t=="function")return np(t)?1:0;if(t!=null){if(t=t.$$typeof,t===Ee)return 11;if(t===Le)return 14}return 2}function vi(t,n){var o=t.alternate;return o===null?(o=bs(t.tag,n,t.key,t.mode),o.elementType=t.elementType,o.type=t.type,o.stateNode=t.stateNode,o.alternate=t,t.alternate=o):(o.pendingProps=n,o.type=t.type,o.flags=0,o.subtreeFlags=0,o.deletions=null),o.flags=t.flags&14680064,o.childLanes=t.childLanes,o.lanes=t.lanes,o.child=t.child,o.memoizedProps=t.memoizedProps,o.memoizedState=t.memoizedState,o.updateQueue=t.updateQueue,n=t.dependencies,o.dependencies=n===null?null:{lanes:n.lanes,firstContext:n.firstContext},o.sibling=t.sibling,o.index=t.index,o.ref=t.ref,o}function Xc(t,n,o,u,m,M){var K=2;if(u=t,typeof t=="function")np(t)&&(K=1);else if(typeof t=="string")K=5;else e:switch(t){case z:return ca(o.children,m,M,n);case L:K=8,m|=8;break;case de:return t=bs(12,o,n,m|2),t.elementType=de,t.lanes=M,t;case Se:return t=bs(13,o,n,m),t.elementType=Se,t.lanes=M,t;case Be:return t=bs(19,o,n,m),t.elementType=Be,t.lanes=M,t;case Me:return Yc(o,m,M,n);default:if(typeof t=="object"&&t!==null)switch(t.$$typeof){case ce:K=10;break e;case Pe:K=9;break e;case Ee:K=11;break e;case Le:K=14;break e;case He:K=16,u=null;break e}throw Error(f(130,t==null?t:typeof t,""))}return n=bs(K,o,n,m),n.elementType=t,n.type=u,n.lanes=M,n}function ca(t,n,o,u){return t=bs(7,t,u,n),t.lanes=o,t}function Yc(t,n,o,u){return t=bs(22,t,u,n),t.elementType=Me,t.lanes=o,t.stateNode={isHidden:!1},t}function vp(t,n,o){return t=bs(6,t,null,n),t.lanes=o,t}function Mi(t,n,o){return n=bs(4,t.children!==null?t.children:[],t.key,n),n.lanes=o,n.stateNode={containerInfo:t.containerInfo,pendingChildren:null,implementation:t.implementation},n}function Rs(t,n,o,u,m){this.tag=n,this.containerInfo=t,this.finishedWork=this.pingCache=this.current=this.pendingChildren=null,this.timeoutHandle=-1,this.callbackNode=this.pendingContext=this.context=null,this.callbackPriority=0,this.eventTimes=ne(0),this.expirationTimes=ne(-1),this.entangledLanes=this.finishedLanes=this.mutableReadLanes=this.expiredLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0,this.entanglements=ne(0),this.identifierPrefix=u,this.onRecoverableError=m,this.mutableSourceEagerHydrationData=null}function el(t,n,o,u,m,M,K,e,r){return t=new Rs(t,n,o,e,r),n===1?(n=1,M===!0&&(n|=8)):n=0,M=bs(3,null,null,n),t.current=M,M.stateNode=t,M.memoizedState={element:u,isDehydrated:o,cache:null,transitions:null,pendingSuspenseBoundaries:null},di(M),t}function sp(t,n,o){var u=3<arguments.length&&arguments[3]!==void 0?arguments[3]:null;return{$$typeof:b,key:u==null?null:""+u,children:t,containerInfo:n,implementation:o}}function Jc(t){if(!t)return Xs;t=t._reactInternals;e:{if(zr(t)!==t||t.tag!==1)throw Error(f(170));var n=t;do{switch(n.tag){case 3:n=n.stateNode.context;break e;case 1:if(Yn(n.type)){n=n.stateNode.__reactInternalMemoizedMergedChildContext;break e}}n=n.return}while(n!==null);throw Error(f(171))}if(t.tag===1){var o=t.type;if(Yn(o))return vo(t,o,n)}return n}function op(t,n,o,u,m,M,K,e,r){return t=el(o,u,!0,t,m,M,K,e,r),t.context=Jc(null),o=t.current,u=tn(),m=xs(o),M=to(u,m),M.callback=n??null,bo(o,M,m),t.current.lanes=m,we(t,m,u),Qr(t,u),t}function Zc(t,n,o,u){var m=n.current,M=tn(),K=xs(m);return o=Jc(o),n.context===null?n.context=o:n.pendingContext=o,n=to(M,K),n.payload={element:t},u=u===void 0?null:u,u!==null&&(n.callback=u),t=bo(m,n,K),t!==null&&(ds(t,m,K,M),La(t,m,K)),K}function mu(t){if(t=t.current,!t.child)return null;switch(t.child.tag){case 5:return t.child.stateNode;default:return t.child.stateNode}}function tl(t,n){if(t=t.memoizedState,t!==null&&t.dehydrated!==null){var o=t.retryLane;t.retryLane=o!==0&&o<n?o:n}}function da(t,n){tl(t,n),(t=t.alternate)&&tl(t,n)}function jp(){return null}var Ap=typeof reportError=="function"?reportError:function(t){console.error(t)};function Mp(t){this._internalRoot=t}ip.prototype.render=Mp.prototype.render=function(t){var n=this._internalRoot;if(n===null)throw Error(f(409));Zc(t,n,null,null)},ip.prototype.unmount=Mp.prototype.unmount=function(){var t=this._internalRoot;if(t!==null){this._internalRoot=null;var n=t.containerInfo;Zn(function(){Zc(null,t,null,null)}),n[yn]=null}};function ip(t){this._internalRoot=t}ip.prototype.unstable_scheduleHydration=function(t){if(t){var n=Zt();t={blockedOn:null,target:t,priority:n};for(var o=0;o<mr.length&&n!==0&&n<mr[o].priority;o++);mr.splice(o,0,t),o===0&&gn(t)}};function xp(t){return!(!t||t.nodeType!==1&&t.nodeType!==9&&t.nodeType!==11)}function ap(t){return!(!t||t.nodeType!==1&&t.nodeType!==9&&t.nodeType!==11&&(t.nodeType!==8||t.nodeValue!==" react-mount-point-unstable "))}function Fp(){}function Np(t,n,o,u,m){if(m){if(typeof u=="function"){var M=u;u=function(){var s=mu(K);M.call(s)}}var K=op(n,u,t,0,null,!1,!1,"",Fp);return t._reactRootContainer=K,t[yn]=K.current,Bi(t.nodeType===8?t.parentNode:t),Zn(),K}for(;m=t.lastChild;)t.removeChild(m);if(typeof u=="function"){var e=u;u=function(){var s=mu(r);e.call(s)}}var r=el(t,0,!1,null,null,!1,!1,"",Fp);return t._reactRootContainer=r,t[yn]=r.current,Bi(t.nodeType===8?t.parentNode:t),Zn(function(){Zc(n,r,o,u)}),r}function lp(t,n,o,u,m){var M=o._reactRootContainer;if(M){var K=M;if(typeof m=="function"){var e=m;m=function(){var r=mu(K);e.call(r)}}Zc(n,K,t,m)}else K=Np(o,n,t,m,u);return mu(K)}bt=function(t){switch(t.tag){case 3:var n=t.stateNode;if(n.current.memoizedState.isDehydrated){var o=ho(n.pendingLanes);o!==0&&(De(n,o|1),Qr(n,Yr()),!(Tr&6)&&(Vt=Yr()+500,xo()))}break;case 13:Zn(function(){var u=Zs(t,1);if(u!==null){var m=tn();ds(u,t,1,m)}}),da(t,1)}},yt=function(t){if(t.tag===13){var n=Zs(t,134217728);if(n!==null){var o=tn();ds(n,t,134217728,o)}da(t,134217728)}},kt=function(t){if(t.tag===13){var n=xs(t),o=Zs(t,n);if(o!==null){var u=tn();ds(o,t,n,u)}da(t,n)}},Zt=function(){return Ge},xr=function(t,n){var o=Ge;try{return Ge=t,n()}finally{Ge=o}},Ps=function(t,n,o){switch(n){case"input":if(_t(t,o),n=o.name,o.type==="radio"&&n!=null){for(o=t;o.parentNode;)o=o.parentNode;for(o=o.querySelectorAll("input[name="+JSON.stringify(""+n)+'][type="radio"]'),n=0;n<o.length;n++){var u=o[n];if(u!==t&&u.form===t.form){var m=Wi(u);if(!m)throw Error(f(90));lt(u),_t(u,m)}}}break;case"textarea":xe(t,o);break;case"select":n=o.value,n!=null&&U(t,!!o.multiple,n,!1)}},Io=cn,ts=Zn;var Op={usingClientEntryPoint:!1,Events:[Vi,ti,Wi,Vs,so,cn]},ed={findFiberByHostInstance:Ro,bundleType:0,version:"18.3.1",rendererPackageName:"react-dom"},Up={bundleType:ed.bundleType,version:ed.version,rendererPackageName:ed.rendererPackageName,rendererConfig:ed.rendererConfig,overrideHookState:null,overrideHookStateDeletePath:null,overrideHookStateRenamePath:null,overrideProps:null,overridePropsDeletePath:null,overridePropsRenamePath:null,setErrorHandler:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:X.ReactCurrentDispatcher,findHostInstanceByFiber:function(t){return t=Ei(t),t===null?null:t.stateNode},findFiberByHostInstance:ed.findFiberByHostInstance||jp,findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null,reconcilerVersion:"18.3.1-next-f1338f8080-20240426"};if(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__<"u"){var Tp=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(!Tp.isDisabled&&Tp.supportsFiber)try{co=Tp.inject(Up),jn=Tp}catch{}}return ko.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=Op,ko.createPortal=function(t,n){var o=2<arguments.length&&arguments[2]!==void 0?arguments[2]:null;if(!xp(n))throw Error(f(200));return sp(t,n,null,o)},ko.createRoot=function(t,n){if(!xp(t))throw Error(f(299));var o=!1,u="",m=Ap;return n!=null&&(n.unstable_strictMode===!0&&(o=!0),n.identifierPrefix!==void 0&&(u=n.identifierPrefix),n.onRecoverableError!==void 0&&(m=n.onRecoverableError)),n=el(t,1,!1,null,null,o,!1,u,m),t[yn]=n.current,Bi(t.nodeType===8?t.parentNode:t),new Mp(n)},ko.findDOMNode=function(t){if(t==null)return null;if(t.nodeType===1)return t;var n=t._reactInternals;if(n===void 0)throw typeof t.render=="function"?Error(f(188)):(t=Object.keys(t).join(","),Error(f(268,t)));return t=Ei(n),t=t===null?null:t.stateNode,t},ko.flushSync=function(t){return Zn(t)},ko.hydrate=function(t,n,o){if(!ap(n))throw Error(f(200));return lp(null,t,n,!0,o)},ko.hydrateRoot=function(t,n,o){if(!xp(t))throw Error(f(405));var u=o!=null&&o.hydratedSources||null,m=!1,M="",K=Ap;if(o!=null&&(o.unstable_strictMode===!0&&(m=!0),o.identifierPrefix!==void 0&&(M=o.identifierPrefix),o.onRecoverableError!==void 0&&(K=o.onRecoverableError)),n=op(n,null,t,1,o??null,m,!1,M,K),t[yn]=n.current,Bi(t),u)for(t=0;t<u.length;t++)o=u[t],m=o._getVersion,m=m(o._source),n.mutableSourceEagerHydrationData==null?n.mutableSourceEagerHydrationData=[o,m]:n.mutableSourceEagerHydrationData.push(o,m);return new ip(n)},ko.render=function(t,n,o){if(!ap(n))throw Error(f(200));return lp(null,t,n,!1,o)},ko.unmountComponentAtNode=function(t){if(!ap(t))throw Error(f(40));return t._reactRootContainer?(Zn(function(){lp(null,null,t,!1,function(){t._reactRootContainer=null,t[yn]=null})}),!0):!1},ko.unstable_batchedUpdates=cn,ko.unstable_renderSubtreeIntoContainer=function(t,n,o,u){if(!ap(o))throw Error(f(200));if(t==null||t._reactInternals===void 0)throw Error(f(38));return lp(t,n,o,!1,u)},ko.version="18.3.1-next-f1338f8080-20240426",ko}var pm;function q_(){if(pm)return Ff.exports;pm=1;function ke(){if(!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__>"u"||typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE!="function"))try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(ke)}catch(V){console.error(V)}}return ke(),Ff.exports=H_(),Ff.exports}var fm;function Q_(){if(fm)return nf;fm=1;var ke=q_();return nf.createRoot=ke.createRoot,nf.hydrateRoot=ke.hydrateRoot,nf}var X_=Q_(),fa=jf(),hm=function(ke,V,f,P){function R(Q){return Q instanceof f?Q:new f(function(se){se(Q)})}return new(f||(f=Promise))(function(Q,se){function oe(k){try{C(P.next(k))}catch(A){se(A)}}function E(k){try{C(P.throw(k))}catch(A){se(A)}}function C(k){k.done?Q(k.value):R(k.value).then(oe,E)}C((P=P.apply(ke,V||[])).next())})};const Y_=ke=>{const[V,f,P]=ke.split(":");return{process_name:V,package_name:f,publisher_node:P}};function mm(ke){const V=document.cookie.split(";");for(let f=0;f<V.length;f++){const P=V[f].trim();if(P.startsWith(ke))return P.substring(ke.length+1)}}function J_(ke){const V=JSON.stringify(ke);return new TextEncoder().encode(V)}class Z_{constructor({nodeId:V,processId:f,channelId:P,uri:R=`${window.location.protocol.replace("http","ws")}//${window.location.host}/${f}/`,onMessage:Q=()=>null,onOpen:se=()=>null,onClose:oe=()=>null,onError:E=()=>null}){this._encrypt=C=>null,this._decrypt=C=>{},this.send=({data:C})=>{mm(`kinode-auth_${this.nodeId}`),mm(`kinode-ws-auth_${this.nodeId}`),this._ws.send(J_(C))},this.fetchJson=(C,k)=>hm(this,void 0,void 0,function*(){return console.log("Fetching JSON:",C),yield(yield fetch(C,k)).json()}),this._secret=void 0,this.processId=Y_(f),this.channelId=P,this.nodeId=V,this._ws=new WebSocket(R),this._ws.onmessage=C=>hm(this,void 0,void 0,function*(){Q(C.data,this)}),this._ws.onopen=C=>{se(C,this)},this._ws.onclose=oe,this._ws.onerror=E}}const Rf="provider:provider:heiligtum.os";var yu={},wm={"./node_modules/onnxruntime-web/dist/ort-wasm-simd-threaded.jsep.wasm":(ke,V,f)=>{ke.exports=f.p+"ort-wasm-simd-threaded.jsep.wasm"},"?2ce3":()=>{},"?7a2c":()=>{},"?a42a":()=>{},"?2b25":()=>{},"?569f":()=>{},"?3f59":()=>{},"?154a":()=>{},"./node_modules/@huggingface/jinja/dist/index.js":(ke,V,f)=>{f.r(V),f.d(V,{Environment:()=>pt,Interpreter:()=>_t,Template:()=>vt,parse:()=>ee,tokenize:()=>A});var P=Object.freeze({Text:"Text",NumericLiteral:"NumericLiteral",BooleanLiteral:"BooleanLiteral",NullLiteral:"NullLiteral",StringLiteral:"StringLiteral",Identifier:"Identifier",Equals:"Equals",OpenParen:"OpenParen",CloseParen:"CloseParen",OpenStatement:"OpenStatement",CloseStatement:"CloseStatement",OpenExpression:"OpenExpression",CloseExpression:"CloseExpression",OpenSquareBracket:"OpenSquareBracket",CloseSquareBracket:"CloseSquareBracket",OpenCurlyBracket:"OpenCurlyBracket",CloseCurlyBracket:"CloseCurlyBracket",Comma:"Comma",Dot:"Dot",Colon:"Colon",Pipe:"Pipe",CallOperator:"CallOperator",AdditiveBinaryOperator:"AdditiveBinaryOperator",MultiplicativeBinaryOperator:"MultiplicativeBinaryOperator",ComparisonBinaryOperator:"ComparisonBinaryOperator",UnaryOperator:"UnaryOperator",Set:"Set",If:"If",For:"For",In:"In",Is:"Is",NotIn:"NotIn",Else:"Else",EndIf:"EndIf",ElseIf:"ElseIf",EndFor:"EndFor",And:"And",Or:"Or",Not:"UnaryOperator",Macro:"Macro",EndMacro:"EndMacro"}),R=Object.freeze({set:P.Set,for:P.For,in:P.In,is:P.Is,if:P.If,else:P.Else,endif:P.EndIf,elif:P.ElseIf,endfor:P.EndFor,and:P.And,or:P.Or,not:P.Not,"not in":P.NotIn,macro:P.Macro,endmacro:P.EndMacro,true:P.BooleanLiteral,false:P.BooleanLiteral,none:P.NullLiteral,True:P.BooleanLiteral,False:P.BooleanLiteral,None:P.NullLiteral}),Q=class{constructor(U,_e){this.value=U,this.type=_e}};function se(U){return/\w/.test(U)}function oe(U){return/[0-9]/.test(U)}var E=[["{%",P.OpenStatement],["%}",P.CloseStatement],["{{",P.OpenExpression],["}}",P.CloseExpression],["(",P.OpenParen],[")",P.CloseParen],["{",P.OpenCurlyBracket],["}",P.CloseCurlyBracket],["[",P.OpenSquareBracket],["]",P.CloseSquareBracket],[",",P.Comma],[".",P.Dot],[":",P.Colon],["|",P.Pipe],["<=",P.ComparisonBinaryOperator],[">=",P.ComparisonBinaryOperator],["==",P.ComparisonBinaryOperator],["!=",P.ComparisonBinaryOperator],["<",P.ComparisonBinaryOperator],[">",P.ComparisonBinaryOperator],["+",P.AdditiveBinaryOperator],["-",P.AdditiveBinaryOperator],["*",P.MultiplicativeBinaryOperator],["/",P.MultiplicativeBinaryOperator],["%",P.MultiplicativeBinaryOperator],["=",P.Equals]],C=new Map([["n",`
`],["t","	"],["r","\r"],["b","\b"],["f","\f"],["v","\v"],["'","'"],['"','"'],["\\","\\"]]);function k(U,_e={}){return U.endsWith(`
`)&&(U=U.slice(0,-1)),U=U.replace(/{#.*?#}/gs,"{##}"),_e.lstrip_blocks&&(U=U.replace(/^[ \t]*({[#%])/gm,"$1")),_e.trim_blocks&&(U=U.replace(/([#%]})\n/g,"$1")),U.replace(/{##}/g,"").replace(/-%}\s*/g,"%}").replace(/\s*{%-/g,"{%").replace(/-}}\s*/g,"}}").replace(/\s*{{-/g,"{{")}function A(U,_e={}){var ct,gt,zt;const Z=[],xe=k(U,_e);let Ne=0;const at=$t=>{let St="";for(;$t(xe[Ne]);){if(xe[Ne]==="\\"){if(++Ne,Ne>=xe.length)throw new SyntaxError("Unexpected end of input");const Ft=xe[Ne++],gr=C.get(Ft);if(gr===void 0)throw new SyntaxError(`Unexpected escaped character: ${Ft}`);St+=gr;continue}if(St+=xe[Ne++],Ne>=xe.length)throw new SyntaxError("Unexpected end of input")}return St};e:for(;Ne<xe.length;){const $t=(ct=Z.at(-1))==null?void 0:ct.type;if($t===void 0||$t===P.CloseStatement||$t===P.CloseExpression){let Ft="";for(;Ne<xe.length&&!(xe[Ne]==="{"&&(xe[Ne+1]==="%"||xe[Ne+1]==="{"));)Ft+=xe[Ne++];if(Ft.length>0){Z.push(new Q(Ft,P.Text));continue}}at(Ft=>/\s/.test(Ft));const St=xe[Ne];if(St==="-"||St==="+"){const Ft=(gt=Z.at(-1))==null?void 0:gt.type;if(Ft===P.Text||Ft===void 0)throw new SyntaxError(`Unexpected character: ${St}`);switch(Ft){case P.Identifier:case P.NumericLiteral:case P.BooleanLiteral:case P.NullLiteral:case P.StringLiteral:case P.CloseParen:case P.CloseSquareBracket:break;default:{++Ne;const gr=at(oe);Z.push(new Q(`${St}${gr}`,gr.length>0?P.NumericLiteral:P.UnaryOperator));continue}}}for(const[Ft,gr]of E)if(xe.slice(Ne,Ne+Ft.length)===Ft){Z.push(new Q(Ft,gr)),Ne+=Ft.length;continue e}if(St==="'"||St==='"'){++Ne;const Ft=at(gr=>gr!==St);Z.push(new Q(Ft,P.StringLiteral)),++Ne;continue}if(oe(St)){const Ft=at(oe);Z.push(new Q(Ft,P.NumericLiteral));continue}if(se(St)){const Ft=at(se),gr=Object.hasOwn(R,Ft)?R[Ft]:P.Identifier;gr===P.In&&((zt=Z.at(-1))==null?void 0:zt.type)===P.Not?(Z.pop(),Z.push(new Q("not in",P.NotIn))):Z.push(new Q(Ft,gr));continue}throw new SyntaxError(`Unexpected character: ${St}`)}return Z}var $=class{constructor(){Fe(this,"type","Statement")}},ae=class extends ${constructor(_e){super();Fe(this,"type","Program");this.body=_e}},fe=class extends ${constructor(_e,Z,xe){super();Fe(this,"type","If");this.test=_e,this.body=Z,this.alternate=xe}},ge=class extends ${constructor(_e,Z,xe,Ne){super();Fe(this,"type","For");this.loopvar=_e,this.iterable=Z,this.body=xe,this.defaultBlock=Ne}},le=class extends ${constructor(_e,Z){super();Fe(this,"type","Set");this.assignee=_e,this.value=Z}},q=class extends ${constructor(_e,Z,xe){super();Fe(this,"type","Macro");this.name=_e,this.args=Z,this.body=xe}},ie=class extends ${constructor(){super(...arguments);Fe(this,"type","Expression")}},pe=class extends ie{constructor(_e,Z,xe){super();Fe(this,"type","MemberExpression");this.object=_e,this.property=Z,this.computed=xe}},X=class extends ie{constructor(_e,Z){super();Fe(this,"type","CallExpression");this.callee=_e,this.args=Z}},W=class extends ie{constructor(_e){super();Fe(this,"type","Identifier");this.value=_e}},b=class extends ie{constructor(_e){super();Fe(this,"type","Literal");this.value=_e}},z=class extends b{constructor(){super(...arguments);Fe(this,"type","NumericLiteral")}},L=class extends b{constructor(){super(...arguments);Fe(this,"type","StringLiteral")}},de=class extends b{constructor(){super(...arguments);Fe(this,"type","BooleanLiteral")}},ce=class extends b{constructor(){super(...arguments);Fe(this,"type","NullLiteral")}},Pe=class extends b{constructor(){super(...arguments);Fe(this,"type","ArrayLiteral")}},Ee=class extends b{constructor(){super(...arguments);Fe(this,"type","TupleLiteral")}},Se=class extends b{constructor(){super(...arguments);Fe(this,"type","ObjectLiteral")}},Be=class extends ie{constructor(_e,Z,xe){super();Fe(this,"type","BinaryExpression");this.operator=_e,this.left=Z,this.right=xe}},Le=class extends ie{constructor(_e,Z){super();Fe(this,"type","FilterExpression");this.operand=_e,this.filter=Z}},He=class extends ie{constructor(_e,Z){super();Fe(this,"type","SelectExpression");this.iterable=_e,this.test=Z}},Me=class extends ie{constructor(_e,Z,xe){super();Fe(this,"type","TestExpression");this.operand=_e,this.negate=Z,this.test=xe}},N=class extends ie{constructor(_e,Z){super();Fe(this,"type","UnaryExpression");this.operator=_e,this.argument=Z}},me=class extends ie{constructor(_e=void 0,Z=void 0,xe=void 0){super();Fe(this,"type","SliceExpression");this.start=_e,this.stop=Z,this.step=xe}},ue=class extends ie{constructor(_e,Z){super();Fe(this,"type","KeywordArgumentExpression");this.key=_e,this.value=Z}};function ee(U){const _e=new ae([]);let Z=0;function xe(dt,Pt){const jt=U[Z++];if(!jt||jt.type!==dt)throw new Error(`Parser Error: ${Pt}. ${jt.type} !== ${dt}.`);return jt}function Ne(){switch(U[Z].type){case P.Text:return gt();case P.OpenStatement:return zt();case P.OpenExpression:return $t();default:throw new SyntaxError(`Unexpected token type: ${U[Z].type}`)}}function at(...dt){return Z+dt.length<=U.length&&dt.some((Pt,jt)=>Pt!==U[Z+jt].type)}function ct(...dt){return Z+dt.length<=U.length&&dt.every((Pt,jt)=>Pt===U[Z+jt].type)}function gt(){return new L(xe(P.Text,"Expected text token").value)}function zt(){xe(P.OpenStatement,"Expected opening statement token");let dt;switch(U[Z].type){case P.Set:++Z,dt=St(),xe(P.CloseStatement,"Expected closing statement token");break;case P.If:++Z,dt=Ft(),xe(P.OpenStatement,"Expected {% token"),xe(P.EndIf,"Expected endif token"),xe(P.CloseStatement,"Expected %} token");break;case P.Macro:++Z,dt=gr(),xe(P.OpenStatement,"Expected {% token"),xe(P.EndMacro,"Expected endmacro token"),xe(P.CloseStatement,"Expected %} token");break;case P.For:++Z,dt=rn(),xe(P.OpenStatement,"Expected {% token"),xe(P.EndFor,"Expected endfor token"),xe(P.CloseStatement,"Expected %} token");break;default:throw new SyntaxError(`Unknown statement type: ${U[Z].type}`)}return dt}function $t(){xe(P.OpenExpression,"Expected opening expression token");const dt=an();return xe(P.CloseExpression,"Expected closing expression token"),dt}function St(){const dt=an();if(ct(P.Equals)){++Z;const Pt=St();return new le(dt,Pt)}return dt}function Ft(){var ln,Ws,ao,Dr,rs,zr,Ss,Sr;const dt=an();xe(P.CloseStatement,"Expected closing statement token");const Pt=[],jt=[];for(;!(((ln=U[Z])==null?void 0:ln.type)===P.OpenStatement&&(((Ws=U[Z+1])==null?void 0:Ws.type)===P.ElseIf||((ao=U[Z+1])==null?void 0:ao.type)===P.Else||((Dr=U[Z+1])==null?void 0:Dr.type)===P.EndIf));)Pt.push(Ne());if(((rs=U[Z])==null?void 0:rs.type)===P.OpenStatement&&((zr=U[Z+1])==null?void 0:zr.type)!==P.EndIf)if(++Z,ct(P.ElseIf))xe(P.ElseIf,"Expected elseif token"),jt.push(Ft());else for(xe(P.Else,"Expected else token"),xe(P.CloseStatement,"Expected closing statement token");!(((Ss=U[Z])==null?void 0:Ss.type)===P.OpenStatement&&((Sr=U[Z+1])==null?void 0:Sr.type)===P.EndIf);)jt.push(Ne());return new fe(dt,Pt,jt)}function gr(){const dt=Cn();if(dt.type!=="Identifier")throw new SyntaxError("Expected identifier following macro statement");const Pt=so();xe(P.CloseStatement,"Expected closing statement token");const jt=[];for(;at(P.OpenStatement,P.EndMacro);)jt.push(Ne());return new q(dt,Pt,jt)}function Cr(dt=!1){const Pt=dt?Cn:an,jt=[Pt()],ln=ct(P.Comma);for(;ln&&(++Z,jt.push(Pt()),!!ct(P.Comma)););return ln?new Ee(jt):jt[0]}function rn(){const dt=Cr(!0);if(!(dt instanceof W||dt instanceof Ee))throw new SyntaxError(`Expected identifier/tuple for the loop variable, got ${dt.type} instead`);xe(P.In,"Expected `in` keyword following loop variable");const Pt=an();xe(P.CloseStatement,"Expected closing statement token");const jt=[];for(;at(P.OpenStatement,P.EndFor)&&at(P.OpenStatement,P.Else);)jt.push(Ne());const ln=[];if(ct(P.OpenStatement,P.Else))for(++Z,++Z,xe(P.CloseStatement,"Expected closing statement token");at(P.OpenStatement,P.EndFor);)ln.push(Ne());return new ge(dt,Pt,jt,ln)}function an(){return Pn()}function Pn(){const dt=Ns();if(ct(P.If)){++Z;const Pt=Ns();if(ct(P.Else)){++Z;const jt=Ns();return new fe(Pt,[dt],[jt])}else return new He(dt,Pt)}return dt}function Ns(){let dt=Us();for(;ct(P.Or);){const Pt=U[Z];++Z;const jt=Us();dt=new Be(Pt,dt,jt)}return dt}function Us(){let dt=Ps();for(;ct(P.And);){const Pt=U[Z];++Z;const jt=Ps();dt=new Be(Pt,dt,jt)}return dt}function Ps(){let dt;for(;ct(P.Not);){const Pt=U[Z];++Z;const jt=Ps();dt=new N(Pt,jt)}return dt??Bn()}function Bn(){let dt=Gt();for(;ct(P.ComparisonBinaryOperator)||ct(P.In)||ct(P.NotIn);){const Pt=U[Z];++Z;const jt=Gt();dt=new Be(Pt,dt,jt)}return dt}function Gt(){let dt=io();for(;ct(P.AdditiveBinaryOperator);){const Pt=U[Z];++Z;const jt=io();dt=new Be(Pt,dt,jt)}return dt}function fs(){const dt=oo();return ct(P.OpenParen)?Vs(dt):dt}function Vs(dt){let Pt=new X(dt,so());return ct(P.OpenParen)&&(Pt=Vs(Pt)),Pt}function so(){xe(P.OpenParen,"Expected opening parenthesis for arguments list");const dt=Io();return xe(P.CloseParen,"Expected closing parenthesis for arguments list"),dt}function Io(){const dt=[];for(;!ct(P.CloseParen);){let Pt=an();if(ct(P.Equals)){if(++Z,!(Pt instanceof W))throw new SyntaxError("Expected identifier for keyword argument");const jt=an();Pt=new ue(Pt,jt)}dt.push(Pt),ct(P.Comma)&&++Z}return dt}function ts(){const dt=[];let Pt=!1;for(;!ct(P.CloseSquareBracket);)ct(P.Colon)?(dt.push(void 0),++Z,Pt=!0):(dt.push(an()),ct(P.Colon)&&(++Z,Pt=!0));if(dt.length===0)throw new SyntaxError("Expected at least one argument for member/slice expression");if(Pt){if(dt.length>3)throw new SyntaxError("Expected 0-3 arguments for slice expression");return new me(...dt)}return dt[0]}function oo(){let dt=Cn();for(;ct(P.Dot)||ct(P.OpenSquareBracket);){const Pt=U[Z];++Z;let jt;const ln=Pt.type!==P.Dot;if(ln)jt=ts(),xe(P.CloseSquareBracket,"Expected closing square bracket");else if(jt=Cn(),jt.type!=="Identifier")throw new SyntaxError("Expected identifier following dot operator");dt=new pe(dt,jt,ln)}return dt}function io(){let dt=hs();for(;ct(P.MultiplicativeBinaryOperator);){const Pt=U[Z];++Z;const jt=hs();dt=new Be(Pt,dt,jt)}return dt}function hs(){let dt=Cs();for(;ct(P.Is);){++Z;const Pt=ct(P.Not);Pt&&++Z;let jt=Cn();if(jt instanceof de?jt=new W(jt.value.toString()):jt instanceof ce&&(jt=new W("none")),!(jt instanceof W))throw new SyntaxError("Expected identifier for the test");dt=new Me(dt,Pt,jt)}return dt}function Cs(){let dt=fs();for(;ct(P.Pipe);){++Z;let Pt=Cn();if(!(Pt instanceof W))throw new SyntaxError("Expected identifier for the filter");ct(P.OpenParen)&&(Pt=Vs(Pt)),dt=new Le(dt,Pt)}return dt}function Cn(){const dt=U[Z];switch(dt.type){case P.NumericLiteral:return++Z,new z(Number(dt.value));case P.StringLiteral:return++Z,new L(dt.value);case P.BooleanLiteral:return++Z,new de(dt.value.toLowerCase()==="true");case P.NullLiteral:return++Z,new ce(null);case P.Identifier:return++Z,new W(dt.value);case P.OpenParen:{++Z;const Pt=Cr();if(U[Z].type!==P.CloseParen)throw new SyntaxError(`Expected closing parenthesis, got ${U[Z].type} instead`);return++Z,Pt}case P.OpenSquareBracket:{++Z;const Pt=[];for(;!ct(P.CloseSquareBracket);)Pt.push(an()),ct(P.Comma)&&++Z;return++Z,new Pe(Pt)}case P.OpenCurlyBracket:{++Z;const Pt=new Map;for(;!ct(P.CloseCurlyBracket);){const jt=an();xe(P.Colon,"Expected colon between key and value in object literal");const ln=an();Pt.set(jt,ln),ct(P.Comma)&&++Z}return++Z,new Se(Pt)}default:throw new SyntaxError(`Unexpected token: ${dt.type}`)}}for(;Z<U.length;)_e.body.push(Ne());return _e}function Te(U,_e,Z=1){_e===void 0&&(_e=U,U=0);const xe=[];for(let Ne=U;Ne<_e;Ne+=Z)xe.push(Ne);return xe}function je(U,_e,Z,xe=1){const Ne=Math.sign(xe);Ne>=0?(_e=(_e??(_e=0))<0?Math.max(U.length+_e,0):Math.min(_e,U.length),Z=(Z??(Z=U.length))<0?Math.max(U.length+Z,0):Math.min(Z,U.length)):(_e=(_e??(_e=U.length-1))<0?Math.max(U.length+_e,-1):Math.min(_e,U.length-1),Z=(Z??(Z=-1))<-1?Math.max(U.length+Z,-1):Math.min(Z,U.length-1));const at=[];for(let ct=_e;Ne*ct<Ne*Z;ct+=xe)at.push(U[ct]);return at}function qe(U){return U.replace(/\b\w/g,_e=>_e.toUpperCase())}var tt=class{constructor(U=void 0){Fe(this,"type","RuntimeValue");Fe(this,"value");Fe(this,"builtins",new Map);this.value=U}__bool__(){return new Je(!!this.value)}},he=class extends tt{constructor(){super(...arguments);Fe(this,"type","NumericValue")}},Ve=class extends tt{constructor(){super(...arguments);Fe(this,"type","StringValue");Fe(this,"builtins",new Map([["upper",new ot(()=>new Ve(this.value.toUpperCase()))],["lower",new ot(()=>new Ve(this.value.toLowerCase()))],["strip",new ot(()=>new Ve(this.value.trim()))],["title",new ot(()=>new Ve(qe(this.value)))],["length",new he(this.value.length)],["rstrip",new ot(()=>new Ve(this.value.trimEnd()))],["lstrip",new ot(()=>new Ve(this.value.trimStart()))]]))}},Je=class extends tt{constructor(){super(...arguments);Fe(this,"type","BooleanValue")}},We=class extends tt{constructor(){super(...arguments);Fe(this,"type","ObjectValue");Fe(this,"builtins",new Map([["get",new ot(([_e,Z])=>{if(!(_e instanceof Ve))throw new Error(`Object key must be a string: got ${_e.type}`);return this.value.get(_e.value)??Z??new st})],["items",new ot(()=>new Re(Array.from(this.value.entries()).map(([_e,Z])=>new Re([new Ve(_e),Z]))))]]))}__bool__(){return new Je(this.value.size>0)}},be=class extends We{constructor(){super(...arguments);Fe(this,"type","KeywordArgumentsValue")}},Re=class extends tt{constructor(){super(...arguments);Fe(this,"type","ArrayValue");Fe(this,"builtins",new Map([["length",new he(this.value.length)]]))}__bool__(){return new Je(this.value.length>0)}},lt=class extends Re{constructor(){super(...arguments);Fe(this,"type","TupleValue")}},ot=class extends tt{constructor(){super(...arguments);Fe(this,"type","FunctionValue")}},st=class extends tt{constructor(){super(...arguments);Fe(this,"type","NullValue")}},Xe=class extends tt{constructor(){super(...arguments);Fe(this,"type","UndefinedValue")}},pt=class{constructor(U){Fe(this,"variables",new Map([["namespace",new ot(U=>{if(U.length===0)return new We(new Map);if(U.length!==1||!(U[0]instanceof We))throw new Error("`namespace` expects either zero arguments or a single object argument");return U[0]})]]));Fe(this,"tests",new Map([["boolean",U=>U.type==="BooleanValue"],["callable",U=>U instanceof ot],["odd",U=>{if(U.type!=="NumericValue")throw new Error(`Cannot apply test "odd" to type: ${U.type}`);return U.value%2!==0}],["even",U=>{if(U.type!=="NumericValue")throw new Error(`Cannot apply test "even" to type: ${U.type}`);return U.value%2===0}],["false",U=>U.type==="BooleanValue"&&!U.value],["true",U=>U.type==="BooleanValue"&&U.value],["none",U=>U.type==="NullValue"],["string",U=>U.type==="StringValue"],["number",U=>U.type==="NumericValue"],["integer",U=>U.type==="NumericValue"&&Number.isInteger(U.value)],["iterable",U=>U.type==="ArrayValue"||U.type==="StringValue"],["mapping",U=>U.type==="ObjectValue"],["lower",U=>{const _e=U.value;return U.type==="StringValue"&&_e===_e.toLowerCase()}],["upper",U=>{const _e=U.value;return U.type==="StringValue"&&_e===_e.toUpperCase()}],["none",U=>U.type==="NullValue"],["defined",U=>U.type!=="UndefinedValue"],["undefined",U=>U.type==="UndefinedValue"],["equalto",(U,_e)=>U.value===_e.value],["eq",(U,_e)=>U.value===_e.value]]));this.parent=U}set(U,_e){return this.declareVariable(U,Et(_e))}declareVariable(U,_e){if(this.variables.has(U))throw new SyntaxError(`Variable already declared: ${U}`);return this.variables.set(U,_e),_e}setVariable(U,_e){return this.variables.set(U,_e),_e}resolve(U){if(this.variables.has(U))return this;if(this.parent)return this.parent.resolve(U);throw new Error(`Unknown variable: ${U}`)}lookupVariable(U){try{return this.resolve(U).variables.get(U)??new Xe}catch{return new Xe}}},_t=class{constructor(U){Fe(this,"global");this.global=U??new pt}run(U){return this.evaluate(U,this.global)}evaluateBinaryExpression(U,_e){const Z=this.evaluate(U.left,_e);switch(U.operator.value){case"and":return Z.__bool__().value?this.evaluate(U.right,_e):Z;case"or":return Z.__bool__().value?Z:this.evaluate(U.right,_e)}const xe=this.evaluate(U.right,_e);switch(U.operator.value){case"==":return new Je(Z.value==xe.value);case"!=":return new Je(Z.value!=xe.value)}if(Z instanceof Xe||xe instanceof Xe)throw new Error("Cannot perform operation on undefined values");if(Z instanceof st||xe instanceof st)throw new Error("Cannot perform operation on null values");if(Z instanceof he&&xe instanceof he)switch(U.operator.value){case"+":return new he(Z.value+xe.value);case"-":return new he(Z.value-xe.value);case"*":return new he(Z.value*xe.value);case"/":return new he(Z.value/xe.value);case"%":return new he(Z.value%xe.value);case"<":return new Je(Z.value<xe.value);case">":return new Je(Z.value>xe.value);case">=":return new Je(Z.value>=xe.value);case"<=":return new Je(Z.value<=xe.value)}else if(Z instanceof Re&&xe instanceof Re)switch(U.operator.value){case"+":return new Re(Z.value.concat(xe.value))}else if(xe instanceof Re){const Ne=xe.value.find(at=>at.value===Z.value)!==void 0;switch(U.operator.value){case"in":return new Je(Ne);case"not in":return new Je(!Ne)}}if(Z instanceof Ve||xe instanceof Ve)switch(U.operator.value){case"+":return new Ve(Z.value.toString()+xe.value.toString())}if(Z instanceof Ve&&xe instanceof Ve)switch(U.operator.value){case"in":return new Je(xe.value.includes(Z.value));case"not in":return new Je(!xe.value.includes(Z.value))}if(Z instanceof Ve&&xe instanceof We)switch(U.operator.value){case"in":return new Je(xe.value.has(Z.value));case"not in":return new Je(!xe.value.has(Z.value))}throw new SyntaxError(`Unknown operator "${U.operator.value}" between ${Z.type} and ${xe.type}`)}evaluateArguments(U,_e){const Z=[],xe=new Map;for(const Ne of U)if(Ne.type==="KeywordArgumentExpression"){const at=Ne;xe.set(at.key.value,this.evaluate(at.value,_e))}else{if(xe.size>0)throw new Error("Positional arguments must come before keyword arguments");Z.push(this.evaluate(Ne,_e))}return[Z,xe]}evaluateFilterExpression(U,_e){const Z=this.evaluate(U.operand,_e);if(U.filter.type==="Identifier"){const xe=U.filter;if(xe.value==="tojson")return new Ve(wt(Z));if(Z instanceof Re)switch(xe.value){case"list":return Z;case"first":return Z.value[0];case"last":return Z.value[Z.value.length-1];case"length":return new he(Z.value.length);case"reverse":return new Re(Z.value.reverse());case"sort":return new Re(Z.value.sort((Ne,at)=>{if(Ne.type!==at.type)throw new Error(`Cannot compare different types: ${Ne.type} and ${at.type}`);switch(Ne.type){case"NumericValue":return Ne.value-at.value;case"StringValue":return Ne.value.localeCompare(at.value);default:throw new Error(`Cannot compare type: ${Ne.type}`)}}));default:throw new Error(`Unknown ArrayValue filter: ${xe.value}`)}else if(Z instanceof Ve)switch(xe.value){case"length":return new he(Z.value.length);case"upper":return new Ve(Z.value.toUpperCase());case"lower":return new Ve(Z.value.toLowerCase());case"title":return new Ve(qe(Z.value));case"capitalize":return new Ve(Z.value.charAt(0).toUpperCase()+Z.value.slice(1));case"trim":return new Ve(Z.value.trim());case"indent":return new Ve(Z.value.split(`
`).map((Ne,at)=>at===0||Ne.length===0?Ne:"    "+Ne).join(`
`));case"string":return Z;default:throw new Error(`Unknown StringValue filter: ${xe.value}`)}else if(Z instanceof he)switch(xe.value){case"abs":return new he(Math.abs(Z.value));default:throw new Error(`Unknown NumericValue filter: ${xe.value}`)}else if(Z instanceof We)switch(xe.value){case"items":return new Re(Array.from(Z.value.entries()).map(([Ne,at])=>new Re([new Ve(Ne),at])));case"length":return new he(Z.value.size);default:throw new Error(`Unknown ObjectValue filter: ${xe.value}`)}throw new Error(`Cannot apply filter "${xe.value}" to type: ${Z.type}`)}else if(U.filter.type==="CallExpression"){const xe=U.filter;if(xe.callee.type!=="Identifier")throw new Error(`Unknown filter: ${xe.callee.type}`);const Ne=xe.callee.value;if(Ne==="tojson"){const[,at]=this.evaluateArguments(xe.args,_e),ct=at.get("indent")??new st;if(!(ct instanceof he||ct instanceof st))throw new Error("If set, indent must be a number");return new Ve(wt(Z,ct.value))}if(Z instanceof Re){switch(Ne){case"selectattr":case"rejectattr":{const at=Ne==="selectattr";if(Z.value.some(Ft=>!(Ft instanceof We)))throw new Error(`\`${Ne}\` can only be applied to array of objects`);if(xe.args.some(Ft=>Ft.type!=="StringLiteral"))throw new Error(`arguments of \`${Ne}\` must be strings`);const[ct,gt,zt]=xe.args.map(Ft=>this.evaluate(Ft,_e));let $t;if(gt){const Ft=_e.tests.get(gt.value);if(!Ft)throw new Error(`Unknown test: ${gt.value}`);$t=Ft}else $t=(...Ft)=>Ft[0].__bool__().value;const St=Z.value.filter(Ft=>{const gr=Ft.value.get(ct.value),Cr=gr?$t(gr,zt):!1;return at?Cr:!Cr});return new Re(St)}case"map":{const[,at]=this.evaluateArguments(xe.args,_e);if(at.has("attribute")){const ct=at.get("attribute");if(!(ct instanceof Ve))throw new Error("attribute must be a string");const gt=at.get("default"),zt=Z.value.map($t=>{if(!($t instanceof We))throw new Error("items in map must be an object");return $t.value.get(ct.value)??gt??new Xe});return new Re(zt)}else throw new Error("`map` expressions without `attribute` set are not currently supported.")}}throw new Error(`Unknown ArrayValue filter: ${Ne}`)}else if(Z instanceof Ve){switch(Ne){case"indent":{const[at,ct]=this.evaluateArguments(xe.args,_e),gt=at.at(0)??ct.get("width")??new he(4);if(!(gt instanceof he))throw new Error("width must be a number");const zt=at.at(1)??ct.get("first")??new Je(!1),$t=at.at(2)??ct.get("blank")??new Je(!1),St=Z.value.split(`
`),Ft=" ".repeat(gt.value),gr=St.map((Cr,rn)=>!zt.value&&rn===0||!$t.value&&Cr.length===0?Cr:Ft+Cr);return new Ve(gr.join(`
`))}}throw new Error(`Unknown StringValue filter: ${Ne}`)}else throw new Error(`Cannot apply filter "${Ne}" to type: ${Z.type}`)}throw new Error(`Unknown filter: ${U.filter.type}`)}evaluateTestExpression(U,_e){const Z=this.evaluate(U.operand,_e),xe=_e.tests.get(U.test.value);if(!xe)throw new Error(`Unknown test: ${U.test.value}`);const Ne=xe(Z);return new Je(U.negate?!Ne:Ne)}evaluateUnaryExpression(U,_e){const Z=this.evaluate(U.argument,_e);switch(U.operator.value){case"not":return new Je(!Z.value);default:throw new SyntaxError(`Unknown operator: ${U.operator.value}`)}}evalProgram(U,_e){return this.evaluateBlock(U.body,_e)}evaluateBlock(U,_e){let Z="";for(const xe of U){const Ne=this.evaluate(xe,_e);Ne.type!=="NullValue"&&Ne.type!=="UndefinedValue"&&(Z+=Ne.value)}return new Ve(Z)}evaluateIdentifier(U,_e){return _e.lookupVariable(U.value)}evaluateCallExpression(U,_e){const[Z,xe]=this.evaluateArguments(U.args,_e);xe.size>0&&Z.push(new be(xe));const Ne=this.evaluate(U.callee,_e);if(Ne.type!=="FunctionValue")throw new Error(`Cannot call something that is not a function: got ${Ne.type}`);return Ne.value(Z,_e)}evaluateSliceExpression(U,_e,Z){if(!(U instanceof Re||U instanceof Ve))throw new Error("Slice object must be an array or string");const xe=this.evaluate(_e.start,Z),Ne=this.evaluate(_e.stop,Z),at=this.evaluate(_e.step,Z);if(!(xe instanceof he||xe instanceof Xe))throw new Error("Slice start must be numeric or undefined");if(!(Ne instanceof he||Ne instanceof Xe))throw new Error("Slice stop must be numeric or undefined");if(!(at instanceof he||at instanceof Xe))throw new Error("Slice step must be numeric or undefined");return U instanceof Re?new Re(je(U.value,xe.value,Ne.value,at.value)):new Ve(je(Array.from(U.value),xe.value,Ne.value,at.value).join(""))}evaluateMemberExpression(U,_e){const Z=this.evaluate(U.object,_e);let xe;if(U.computed){if(U.property.type==="SliceExpression")return this.evaluateSliceExpression(Z,U.property,_e);xe=this.evaluate(U.property,_e)}else xe=new Ve(U.property.value);let Ne;if(Z instanceof We){if(!(xe instanceof Ve))throw new Error(`Cannot access property with non-string: got ${xe.type}`);Ne=Z.value.get(xe.value)??Z.builtins.get(xe.value)}else if(Z instanceof Re||Z instanceof Ve)if(xe instanceof he)Ne=Z.value.at(xe.value),Z instanceof Ve&&(Ne=new Ve(Z.value.at(xe.value)));else if(xe instanceof Ve)Ne=Z.builtins.get(xe.value);else throw new Error(`Cannot access property with non-string/non-number: got ${xe.type}`);else{if(!(xe instanceof Ve))throw new Error(`Cannot access property with non-string: got ${xe.type}`);Ne=Z.builtins.get(xe.value)}return Ne instanceof tt?Ne:new Xe}evaluateSet(U,_e){const Z=this.evaluate(U.value,_e);if(U.assignee.type==="Identifier"){const xe=U.assignee.value;_e.setVariable(xe,Z)}else if(U.assignee.type==="MemberExpression"){const xe=U.assignee,Ne=this.evaluate(xe.object,_e);if(!(Ne instanceof We))throw new Error("Cannot assign to member of non-object");if(xe.property.type!=="Identifier")throw new Error("Cannot assign to member with non-identifier property");Ne.value.set(xe.property.value,Z)}else throw new Error(`Invalid LHS inside assignment expression: ${JSON.stringify(U.assignee)}`);return new st}evaluateIf(U,_e){const Z=this.evaluate(U.test,_e);return this.evaluateBlock(Z.__bool__().value?U.body:U.alternate,_e)}evaluateFor(U,_e){const Z=new pt(_e);let xe,Ne;if(U.iterable.type==="SelectExpression"){const $t=U.iterable;Ne=this.evaluate($t.iterable,Z),xe=$t.test}else Ne=this.evaluate(U.iterable,Z);if(!(Ne instanceof Re))throw new Error(`Expected iterable type in for loop: got ${Ne.type}`);const at=[],ct=[];for(let $t=0;$t<Ne.value.length;++$t){const St=new pt(Z),Ft=Ne.value[$t];let gr;if(U.loopvar.type==="Identifier")gr=Cr=>Cr.setVariable(U.loopvar.value,Ft);else if(U.loopvar.type==="TupleLiteral"){const Cr=U.loopvar;if(Ft.type!=="ArrayValue")throw new Error(`Cannot unpack non-iterable type: ${Ft.type}`);const rn=Ft;if(Cr.value.length!==rn.value.length)throw new Error(`Too ${Cr.value.length>rn.value.length?"few":"many"} items to unpack`);gr=an=>{for(let Pn=0;Pn<Cr.value.length;++Pn){if(Cr.value[Pn].type!=="Identifier")throw new Error(`Cannot unpack non-identifier type: ${Cr.value[Pn].type}`);an.setVariable(Cr.value[Pn].value,rn.value[Pn])}}}else throw new Error(`Invalid loop variable(s): ${U.loopvar.type}`);xe&&(gr(St),!this.evaluate(xe,St).__bool__().value)||(at.push(Ft),ct.push(gr))}let gt="",zt=!0;for(let $t=0;$t<at.length;++$t){const St=new Map([["index",new he($t+1)],["index0",new he($t)],["revindex",new he(at.length-$t)],["revindex0",new he(at.length-$t-1)],["first",new Je($t===0)],["last",new Je($t===at.length-1)],["length",new he(at.length)],["previtem",$t>0?at[$t-1]:new Xe],["nextitem",$t<at.length-1?at[$t+1]:new Xe]]);Z.setVariable("loop",new We(St)),ct[$t](Z);const Ft=this.evaluateBlock(U.body,Z);gt+=Ft.value,zt=!1}if(zt){const $t=this.evaluateBlock(U.defaultBlock,Z);gt+=$t.value}return new Ve(gt)}evaluateMacro(U,_e){return _e.setVariable(U.name.value,new ot((Z,xe)=>{var ct;const Ne=new pt(xe);Z=Z.slice();let at;((ct=Z.at(-1))==null?void 0:ct.type)==="KeywordArgumentsValue"&&(at=Z.pop());for(let gt=0;gt<U.args.length;++gt){const zt=U.args[gt],$t=Z[gt];if(zt.type==="Identifier"){const St=zt;if(!$t)throw new Error(`Missing positional argument: ${St.value}`);Ne.setVariable(St.value,$t)}else if(zt.type==="KeywordArgumentExpression"){const St=zt,Ft=$t??(at==null?void 0:at.value.get(St.key.value))??this.evaluate(St.value,Ne);Ne.setVariable(St.key.value,Ft)}else throw new Error(`Unknown argument type: ${zt.type}`)}return this.evaluateBlock(U.body,Ne)})),new st}evaluate(U,_e){if(U===void 0)return new Xe;switch(U.type){case"Program":return this.evalProgram(U,_e);case"Set":return this.evaluateSet(U,_e);case"If":return this.evaluateIf(U,_e);case"For":return this.evaluateFor(U,_e);case"Macro":return this.evaluateMacro(U,_e);case"NumericLiteral":return new he(Number(U.value));case"StringLiteral":return new Ve(U.value);case"BooleanLiteral":return new Je(U.value);case"NullLiteral":return new st(U.value);case"ArrayLiteral":return new Re(U.value.map(Z=>this.evaluate(Z,_e)));case"TupleLiteral":return new lt(U.value.map(Z=>this.evaluate(Z,_e)));case"ObjectLiteral":{const Z=new Map;for(const[xe,Ne]of U.value){const at=this.evaluate(xe,_e);if(!(at instanceof Ve))throw new Error(`Object keys must be strings: got ${at.type}`);Z.set(at.value,this.evaluate(Ne,_e))}return new We(Z)}case"Identifier":return this.evaluateIdentifier(U,_e);case"CallExpression":return this.evaluateCallExpression(U,_e);case"MemberExpression":return this.evaluateMemberExpression(U,_e);case"UnaryExpression":return this.evaluateUnaryExpression(U,_e);case"BinaryExpression":return this.evaluateBinaryExpression(U,_e);case"FilterExpression":return this.evaluateFilterExpression(U,_e);case"TestExpression":return this.evaluateTestExpression(U,_e);default:throw new SyntaxError(`Unknown node type: ${U.type}`)}}};function Et(U){switch(typeof U){case"number":return new he(U);case"string":return new Ve(U);case"boolean":return new Je(U);case"undefined":return new Xe;case"object":return U===null?new st:Array.isArray(U)?new Re(U.map(Et)):new We(new Map(Object.entries(U).map(([_e,Z])=>[_e,Et(Z)])));case"function":return new ot((_e,Z)=>{const xe=U(..._e.map(Ne=>Ne.value))??null;return Et(xe)});default:throw new Error(`Cannot convert to runtime value: ${U}`)}}function wt(U,_e,Z){const xe=Z??0;switch(U.type){case"NullValue":case"UndefinedValue":return"null";case"NumericValue":case"StringValue":case"BooleanValue":return JSON.stringify(U.value);case"ArrayValue":case"ObjectValue":{const Ne=_e?" ".repeat(_e):"",at=`
`+Ne.repeat(xe),ct=at+Ne;if(U.type==="ArrayValue"){const gt=U.value.map(zt=>wt(zt,_e,xe+1));return _e?`[${ct}${gt.join(`,${ct}`)}${at}]`:`[${gt.join(", ")}]`}else{const gt=Array.from(U.value.entries()).map(([zt,$t])=>{const St=`"${zt}": ${wt($t,_e,xe+1)}`;return _e?`${ct}${St}`:St});return _e?`{${gt.join(",")}${at}}`:`{${gt.join(", ")}}`}}default:throw new Error(`Cannot convert to JSON: ${U.type}`)}}var vt=class{constructor(U){Fe(this,"parsed");const _e=A(U,{lstrip_blocks:!0,trim_blocks:!0});this.parsed=ee(_e)}render(U){const _e=new pt;_e.set("false",!1),_e.set("true",!0),_e.set("raise_exception",Ne=>{throw new Error(Ne)}),_e.set("range",Te);for(const[Ne,at]of Object.entries(U))_e.set(Ne,at);return new _t(_e).run(this.parsed).value}}},"./node_modules/onnxruntime-common/dist/esm/backend-impl.js":(ke,V,f)=>{f.r(V),f.d(V,{registerBackend:()=>Q,resolveBackendAndExecutionProviders:()=>oe});const P=new Map,R=[],Q=(E,C,k)=>{if(C&&typeof C.init=="function"&&typeof C.createInferenceSessionHandler=="function"){const A=P.get(E);if(A===void 0)P.set(E,{backend:C,priority:k});else{if(A.priority>k)return;if(A.priority===k&&A.backend!==C)throw new Error(`cannot register backend "${E}" using priority ${k}`)}if(k>=0){const $=R.indexOf(E);$!==-1&&R.splice($,1);for(let ae=0;ae<R.length;ae++)if(P.get(R[ae]).priority<=k){R.splice(ae,0,E);return}R.push(E)}return}throw new TypeError("not a valid backend")},se=async E=>{const C=P.get(E);if(!C)return"backend not found.";if(C.initialized)return C.backend;if(C.aborted)return C.error;{const k=!!C.initPromise;try{return k||(C.initPromise=C.backend.init(E)),await C.initPromise,C.initialized=!0,C.backend}catch(A){return k||(C.error=`${A}`,C.aborted=!0),C.error}finally{delete C.initPromise}}},oe=async E=>{const C=E.executionProviders||[],k=C.map(le=>typeof le=="string"?le:le.name),A=k.length===0?R:k;let $;const ae=[],fe=new Set;for(const le of A){const q=await se(le);typeof q=="string"?ae.push({name:le,err:q}):($||($=q),$===q&&fe.add(le))}if(!$)throw new Error(`no available backend found. ERR: ${ae.map(le=>`[${le.name}] ${le.err}`).join(", ")}`);for(const{name:le,err:q}of ae)k.includes(le)&&console.warn(`removing requested execution provider "${le}" from session options because it is not available: ${q}`);const ge=C.filter(le=>fe.has(typeof le=="string"?le:le.name));return[$,new Proxy(E,{get:(le,q)=>q==="executionProviders"?ge:Reflect.get(le,q)})]}},"./node_modules/onnxruntime-common/dist/esm/backend.js":(ke,V,f)=>{f.r(V),f.d(V,{registerBackend:()=>P.registerBackend});var P=f("./node_modules/onnxruntime-common/dist/esm/backend-impl.js")},"./node_modules/onnxruntime-common/dist/esm/env-impl.js":(ke,V,f)=>{f.r(V),f.d(V,{env:()=>Q});var P=f("./node_modules/onnxruntime-common/dist/esm/version.js");let R="warning";const Q={wasm:{},webgl:{},webgpu:{},versions:{common:P.version},set logLevel(se){if(se!==void 0){if(typeof se!="string"||["verbose","info","warning","error","fatal"].indexOf(se)===-1)throw new Error(`Unsupported logging level: ${se}`);R=se}},get logLevel(){return R}};Object.defineProperty(Q,"logLevel",{enumerable:!0})},"./node_modules/onnxruntime-common/dist/esm/env.js":(ke,V,f)=>{f.r(V),f.d(V,{env:()=>R});var P=f("./node_modules/onnxruntime-common/dist/esm/env-impl.js");const R=P.env},"./node_modules/onnxruntime-common/dist/esm/index.js":(ke,V,f)=>{f.r(V),f.d(V,{InferenceSession:()=>Q.InferenceSession,TRACE:()=>oe.TRACE,TRACE_FUNC_BEGIN:()=>oe.TRACE_FUNC_BEGIN,TRACE_FUNC_END:()=>oe.TRACE_FUNC_END,Tensor:()=>se.Tensor,TrainingSession:()=>E.TrainingSession,env:()=>R.env,registerBackend:()=>P.registerBackend});var P=f("./node_modules/onnxruntime-common/dist/esm/backend.js"),R=f("./node_modules/onnxruntime-common/dist/esm/env.js"),Q=f("./node_modules/onnxruntime-common/dist/esm/inference-session.js"),se=f("./node_modules/onnxruntime-common/dist/esm/tensor.js");f("./node_modules/onnxruntime-common/dist/esm/tensor-conversion.js"),f("./node_modules/onnxruntime-common/dist/esm/tensor-factory.js");var oe=f("./node_modules/onnxruntime-common/dist/esm/trace.js");f("./node_modules/onnxruntime-common/dist/esm/onnx-model.js"),f("./node_modules/onnxruntime-common/dist/esm/onnx-value.js");var E=f("./node_modules/onnxruntime-common/dist/esm/training-session.js")},"./node_modules/onnxruntime-common/dist/esm/inference-session-impl.js":(ke,V,f)=>{f.r(V),f.d(V,{InferenceSession:()=>se});var P=f("./node_modules/onnxruntime-common/dist/esm/backend-impl.js"),R=f("./node_modules/onnxruntime-common/dist/esm/tensor.js"),Q=f("./node_modules/onnxruntime-common/dist/esm/trace.js");class se{constructor(E){this.handler=E}async run(E,C,k){(0,Q.TRACE_FUNC_BEGIN)();const A={};let $={};if(typeof E!="object"||E===null||E instanceof R.Tensor||Array.isArray(E))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let ae=!0;if(typeof C=="object"){if(C===null)throw new TypeError("Unexpected argument[1]: cannot be null.");if(C instanceof R.Tensor)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(C)){if(C.length===0)throw new TypeError("'fetches' cannot be an empty array.");ae=!1;for(const le of C){if(typeof le!="string")throw new TypeError("'fetches' must be a string array or an object.");if(this.outputNames.indexOf(le)===-1)throw new RangeError(`'fetches' contains invalid output name: ${le}.`);A[le]=null}if(typeof k=="object"&&k!==null)$=k;else if(typeof k<"u")throw new TypeError("'options' must be an object.")}else{let le=!1;const q=Object.getOwnPropertyNames(C);for(const ie of this.outputNames)if(q.indexOf(ie)!==-1){const pe=C[ie];(pe===null||pe instanceof R.Tensor)&&(le=!0,ae=!1,A[ie]=pe)}if(le){if(typeof k=="object"&&k!==null)$=k;else if(typeof k<"u")throw new TypeError("'options' must be an object.")}else $=C}}else if(typeof C<"u")throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(const le of this.inputNames)if(typeof E[le]>"u")throw new Error(`input '${le}' is missing in 'feeds'.`);if(ae)for(const le of this.outputNames)A[le]=null;const fe=await this.handler.run(E,A,$),ge={};for(const le in fe)if(Object.hasOwnProperty.call(fe,le)){const q=fe[le];q instanceof R.Tensor?ge[le]=q:ge[le]=new R.Tensor(q.type,q.data,q.dims)}return(0,Q.TRACE_FUNC_END)(),ge}async release(){return this.handler.dispose()}static async create(E,C,k,A){(0,Q.TRACE_FUNC_BEGIN)();let $,ae={};if(typeof E=="string"){if($=E,typeof C=="object"&&C!==null)ae=C;else if(typeof C<"u")throw new TypeError("'options' must be an object.")}else if(E instanceof Uint8Array){if($=E,typeof C=="object"&&C!==null)ae=C;else if(typeof C<"u")throw new TypeError("'options' must be an object.")}else if(E instanceof ArrayBuffer||typeof SharedArrayBuffer<"u"&&E instanceof SharedArrayBuffer){const q=E;let ie=0,pe=E.byteLength;if(typeof C=="object"&&C!==null)ae=C;else if(typeof C=="number"){if(ie=C,!Number.isSafeInteger(ie))throw new RangeError("'byteOffset' must be an integer.");if(ie<0||ie>=q.byteLength)throw new RangeError(`'byteOffset' is out of range [0, ${q.byteLength}).`);if(pe=E.byteLength-ie,typeof k=="number"){if(pe=k,!Number.isSafeInteger(pe))throw new RangeError("'byteLength' must be an integer.");if(pe<=0||ie+pe>q.byteLength)throw new RangeError(`'byteLength' is out of range (0, ${q.byteLength-ie}].`);if(typeof A=="object"&&A!==null)ae=A;else if(typeof A<"u")throw new TypeError("'options' must be an object.")}else if(typeof k<"u")throw new TypeError("'byteLength' must be a number.")}else if(typeof C<"u")throw new TypeError("'options' must be an object.");$=new Uint8Array(q,ie,pe)}else throw new TypeError("Unexpected argument[0]: must be 'path' or 'buffer'.");const[fe,ge]=await(0,P.resolveBackendAndExecutionProviders)(ae),le=await fe.createInferenceSessionHandler($,ge);return(0,Q.TRACE_FUNC_END)(),new se(le)}startProfiling(){this.handler.startProfiling()}endProfiling(){this.handler.endProfiling()}get inputNames(){return this.handler.inputNames}get outputNames(){return this.handler.outputNames}}},"./node_modules/onnxruntime-common/dist/esm/inference-session.js":(ke,V,f)=>{f.r(V),f.d(V,{InferenceSession:()=>R});var P=f("./node_modules/onnxruntime-common/dist/esm/inference-session-impl.js");const R=P.InferenceSession},"./node_modules/onnxruntime-common/dist/esm/onnx-model.js":(ke,V,f)=>{f.r(V)},"./node_modules/onnxruntime-common/dist/esm/onnx-value.js":(ke,V,f)=>{f.r(V)},"./node_modules/onnxruntime-common/dist/esm/tensor-conversion-impl.js":(ke,V,f)=>{f.r(V),f.d(V,{tensorToDataURL:()=>P,tensorToImageData:()=>R});const P=(Q,se)=>{const oe=typeof document<"u"?document.createElement("canvas"):new OffscreenCanvas(1,1);oe.width=Q.dims[3],oe.height=Q.dims[2];const E=oe.getContext("2d");if(E!=null){let C,k;(se==null?void 0:se.tensorLayout)!==void 0&&se.tensorLayout==="NHWC"?(C=Q.dims[2],k=Q.dims[3]):(C=Q.dims[3],k=Q.dims[2]);const A=(se==null?void 0:se.format)!==void 0?se.format:"RGB",$=se==null?void 0:se.norm;let ae,fe;$===void 0||$.mean===void 0?ae=[255,255,255,255]:typeof $.mean=="number"?ae=[$.mean,$.mean,$.mean,$.mean]:(ae=[$.mean[0],$.mean[1],$.mean[2],0],$.mean[3]!==void 0&&(ae[3]=$.mean[3])),$===void 0||$.bias===void 0?fe=[0,0,0,0]:typeof $.bias=="number"?fe=[$.bias,$.bias,$.bias,$.bias]:(fe=[$.bias[0],$.bias[1],$.bias[2],0],$.bias[3]!==void 0&&(fe[3]=$.bias[3]));const ge=k*C;let le=0,q=ge,ie=ge*2,pe=-1;A==="RGBA"?(le=0,q=ge,ie=ge*2,pe=ge*3):A==="RGB"?(le=0,q=ge,ie=ge*2):A==="RBG"&&(le=0,ie=ge,q=ge*2);for(let X=0;X<k;X++)for(let W=0;W<C;W++){const b=(Q.data[le++]-fe[0])*ae[0],z=(Q.data[q++]-fe[1])*ae[1],L=(Q.data[ie++]-fe[2])*ae[2],de=pe===-1?255:(Q.data[pe++]-fe[3])*ae[3];E.fillStyle="rgba("+b+","+z+","+L+","+de+")",E.fillRect(W,X,1,1)}if("toDataURL"in oe)return oe.toDataURL();throw new Error("toDataURL is not supported")}else throw new Error("Can not access image data")},R=(Q,se)=>{const oe=typeof document<"u"?document.createElement("canvas").getContext("2d"):new OffscreenCanvas(1,1).getContext("2d");let E;if(oe!=null){let C,k,A;(se==null?void 0:se.tensorLayout)!==void 0&&se.tensorLayout==="NHWC"?(C=Q.dims[2],k=Q.dims[1],A=Q.dims[3]):(C=Q.dims[3],k=Q.dims[2],A=Q.dims[1]);const $=se!==void 0&&se.format!==void 0?se.format:"RGB",ae=se==null?void 0:se.norm;let fe,ge;ae===void 0||ae.mean===void 0?fe=[255,255,255,255]:typeof ae.mean=="number"?fe=[ae.mean,ae.mean,ae.mean,ae.mean]:(fe=[ae.mean[0],ae.mean[1],ae.mean[2],255],ae.mean[3]!==void 0&&(fe[3]=ae.mean[3])),ae===void 0||ae.bias===void 0?ge=[0,0,0,0]:typeof ae.bias=="number"?ge=[ae.bias,ae.bias,ae.bias,ae.bias]:(ge=[ae.bias[0],ae.bias[1],ae.bias[2],0],ae.bias[3]!==void 0&&(ge[3]=ae.bias[3]));const le=k*C;if(se!==void 0&&(se.format!==void 0&&A===4&&se.format!=="RGBA"||A===3&&se.format!=="RGB"&&se.format!=="BGR"))throw new Error("Tensor format doesn't match input tensor dims");const q=4;let ie=0,pe=1,X=2,W=3,b=0,z=le,L=le*2,de=-1;$==="RGBA"?(b=0,z=le,L=le*2,de=le*3):$==="RGB"?(b=0,z=le,L=le*2):$==="RBG"&&(b=0,L=le,z=le*2),E=oe.createImageData(C,k);for(let ce=0;ce<k*C;ie+=q,pe+=q,X+=q,W+=q,ce++)E.data[ie]=(Q.data[b++]-ge[0])*fe[0],E.data[pe]=(Q.data[z++]-ge[1])*fe[1],E.data[X]=(Q.data[L++]-ge[2])*fe[2],E.data[W]=de===-1?255:(Q.data[de++]-ge[3])*fe[3]}else throw new Error("Can not access image data");return E}},"./node_modules/onnxruntime-common/dist/esm/tensor-conversion.js":(ke,V,f)=>{f.r(V)},"./node_modules/onnxruntime-common/dist/esm/tensor-factory-impl.js":(ke,V,f)=>{f.r(V),f.d(V,{bufferToTensor:()=>R,tensorFromGpuBuffer:()=>oe,tensorFromImage:()=>Q,tensorFromMLTensor:()=>E,tensorFromPinnedBuffer:()=>C,tensorFromTexture:()=>se});var P=f("./node_modules/onnxruntime-common/dist/esm/tensor-impl.js");const R=(k,A)=>{if(k===void 0)throw new Error("Image buffer must be defined");if(A.height===void 0||A.width===void 0)throw new Error("Image height and width must be defined");if(A.tensorLayout==="NHWC")throw new Error("NHWC Tensor layout is not supported yet");const{height:$,width:ae}=A,fe=A.norm??{mean:255,bias:0};let ge,le;typeof fe.mean=="number"?ge=[fe.mean,fe.mean,fe.mean,fe.mean]:ge=[fe.mean[0],fe.mean[1],fe.mean[2],fe.mean[3]??255],typeof fe.bias=="number"?le=[fe.bias,fe.bias,fe.bias,fe.bias]:le=[fe.bias[0],fe.bias[1],fe.bias[2],fe.bias[3]??0];const q=A.format!==void 0?A.format:"RGBA",ie=A.tensorFormat!==void 0&&A.tensorFormat!==void 0?A.tensorFormat:"RGB",pe=$*ae,X=ie==="RGBA"?new Float32Array(pe*4):new Float32Array(pe*3);let W=4,b=0,z=1,L=2,de=3,ce=0,Pe=pe,Ee=pe*2,Se=-1;q==="RGB"&&(W=3,b=0,z=1,L=2,de=-1),ie==="RGBA"?Se=pe*3:ie==="RBG"?(ce=0,Ee=pe,Pe=pe*2):ie==="BGR"&&(Ee=0,Pe=pe,ce=pe*2);for(let Le=0;Le<pe;Le++,b+=W,L+=W,z+=W,de+=W)X[ce++]=(k[b]+le[0])/ge[0],X[Pe++]=(k[z]+le[1])/ge[1],X[Ee++]=(k[L]+le[2])/ge[2],Se!==-1&&de!==-1&&(X[Se++]=(k[de]+le[3])/ge[3]);return ie==="RGBA"?new P.Tensor("float32",X,[1,4,$,ae]):new P.Tensor("float32",X,[1,3,$,ae])},Q=async(k,A)=>{const $=typeof HTMLImageElement<"u"&&k instanceof HTMLImageElement,ae=typeof ImageData<"u"&&k instanceof ImageData,fe=typeof ImageBitmap<"u"&&k instanceof ImageBitmap,ge=typeof k=="string";let le,q=A??{};const ie=()=>{if(typeof document<"u")return document.createElement("canvas");if(typeof OffscreenCanvas<"u")return new OffscreenCanvas(1,1);throw new Error("Canvas is not supported")},pe=X=>typeof HTMLCanvasElement<"u"&&X instanceof HTMLCanvasElement||X instanceof OffscreenCanvas?X.getContext("2d"):null;if($){const X=ie();X.width=k.width,X.height=k.height;const W=pe(X);if(W!=null){let b=k.height,z=k.width;if(A!==void 0&&A.resizedHeight!==void 0&&A.resizedWidth!==void 0&&(b=A.resizedHeight,z=A.resizedWidth),A!==void 0){if(q=A,A.tensorFormat!==void 0)throw new Error("Image input config format must be RGBA for HTMLImageElement");q.tensorFormat="RGBA",q.height=b,q.width=z}else q.tensorFormat="RGBA",q.height=b,q.width=z;W.drawImage(k,0,0),le=W.getImageData(0,0,z,b).data}else throw new Error("Can not access image data")}else if(ae){let X,W;if(A!==void 0&&A.resizedWidth!==void 0&&A.resizedHeight!==void 0?(X=A.resizedHeight,W=A.resizedWidth):(X=k.height,W=k.width),A!==void 0&&(q=A),q.format="RGBA",q.height=X,q.width=W,A!==void 0){const b=ie();b.width=W,b.height=X;const z=pe(b);if(z!=null)z.putImageData(k,0,0),le=z.getImageData(0,0,W,X).data;else throw new Error("Can not access image data")}else le=k.data}else if(fe){if(A===void 0)throw new Error("Please provide image config with format for Imagebitmap");const X=ie();X.width=k.width,X.height=k.height;const W=pe(X);if(W!=null){const b=k.height,z=k.width;return W.drawImage(k,0,0,z,b),le=W.getImageData(0,0,z,b).data,q.height=b,q.width=z,R(le,q)}else throw new Error("Can not access image data")}else{if(ge)return new Promise((X,W)=>{const b=ie(),z=pe(b);if(!k||!z)return W();const L=new Image;L.crossOrigin="Anonymous",L.src=k,L.onload=()=>{b.width=L.width,b.height=L.height,z.drawImage(L,0,0,b.width,b.height);const de=z.getImageData(0,0,b.width,b.height);q.height=b.height,q.width=b.width,X(R(de.data,q))}});throw new Error("Input data provided is not supported - aborted tensor creation")}if(le!==void 0)return R(le,q);throw new Error("Input data provided is not supported - aborted tensor creation")},se=(k,A)=>{const{width:$,height:ae,download:fe,dispose:ge}=A,le=[1,ae,$,4];return new P.Tensor({location:"texture",type:"float32",texture:k,dims:le,download:fe,dispose:ge})},oe=(k,A)=>{const{dataType:$,dims:ae,download:fe,dispose:ge}=A;return new P.Tensor({location:"gpu-buffer",type:$??"float32",gpuBuffer:k,dims:ae,download:fe,dispose:ge})},E=(k,A)=>{const{dataType:$,dims:ae,download:fe,dispose:ge}=A;return new P.Tensor({location:"ml-tensor",type:$??"float32",mlTensor:k,dims:ae,download:fe,dispose:ge})},C=(k,A,$)=>new P.Tensor({location:"cpu-pinned",type:k,data:A,dims:$??[A.length]})},"./node_modules/onnxruntime-common/dist/esm/tensor-factory.js":(ke,V,f)=>{f.r(V)},"./node_modules/onnxruntime-common/dist/esm/tensor-impl-type-mapping.js":(ke,V,f)=>{f.r(V),f.d(V,{NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP:()=>R,NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP:()=>P,checkTypedArray:()=>se});const P=new Map([["float32",Float32Array],["uint8",Uint8Array],["int8",Int8Array],["uint16",Uint16Array],["int16",Int16Array],["int32",Int32Array],["bool",Uint8Array],["float64",Float64Array],["uint32",Uint32Array],["int4",Uint8Array],["uint4",Uint8Array]]),R=new Map([[Float32Array,"float32"],[Uint8Array,"uint8"],[Int8Array,"int8"],[Uint16Array,"uint16"],[Int16Array,"int16"],[Int32Array,"int32"],[Float64Array,"float64"],[Uint32Array,"uint32"]]);let Q=!1;const se=()=>{if(!Q){Q=!0;const oe=typeof BigInt64Array<"u"&&BigInt64Array.from,E=typeof BigUint64Array<"u"&&BigUint64Array.from,C=typeof Float16Array<"u"&&Float16Array.from;oe&&(P.set("int64",BigInt64Array),R.set(BigInt64Array,"int64")),E&&(P.set("uint64",BigUint64Array),R.set(BigUint64Array,"uint64")),C?(P.set("float16",Float16Array),R.set(Float16Array,"float16")):P.set("float16",Uint16Array)}}},"./node_modules/onnxruntime-common/dist/esm/tensor-impl.js":(ke,V,f)=>{f.r(V),f.d(V,{Tensor:()=>oe});var P=f("./node_modules/onnxruntime-common/dist/esm/tensor-conversion-impl.js"),R=f("./node_modules/onnxruntime-common/dist/esm/tensor-factory-impl.js"),Q=f("./node_modules/onnxruntime-common/dist/esm/tensor-impl-type-mapping.js"),se=f("./node_modules/onnxruntime-common/dist/esm/tensor-utils-impl.js");class oe{constructor(C,k,A){(0,Q.checkTypedArray)();let $,ae;if(typeof C=="object"&&"location"in C)switch(this.dataLocation=C.location,$=C.type,ae=C.dims,C.location){case"cpu-pinned":{const ge=Q.NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.get($);if(!ge)throw new TypeError(`unsupported type "${$}" to create tensor from pinned buffer`);if(!(C.data instanceof ge))throw new TypeError(`buffer should be of type ${ge.name}`);this.cpuData=C.data;break}case"texture":{if($!=="float32")throw new TypeError(`unsupported type "${$}" to create tensor from texture`);this.gpuTextureData=C.texture,this.downloader=C.download,this.disposer=C.dispose;break}case"gpu-buffer":{if($!=="float32"&&$!=="float16"&&$!=="int32"&&$!=="int64"&&$!=="uint32"&&$!=="uint8"&&$!=="bool"&&$!=="uint4"&&$!=="int4")throw new TypeError(`unsupported type "${$}" to create tensor from gpu buffer`);this.gpuBufferData=C.gpuBuffer,this.downloader=C.download,this.disposer=C.dispose;break}case"ml-tensor":{if($!=="float32"&&$!=="float16"&&$!=="int32"&&$!=="int64"&&$!=="uint32"&&$!=="uint64"&&$!=="int8"&&$!=="uint8"&&$!=="bool")throw new TypeError(`unsupported type "${$}" to create tensor from MLTensor`);this.mlTensorData=C.mlTensor,this.downloader=C.download,this.disposer=C.dispose;break}default:throw new Error(`Tensor constructor: unsupported location '${this.dataLocation}'`)}else{let ge,le;if(typeof C=="string")if($=C,le=A,C==="string"){if(!Array.isArray(k))throw new TypeError("A string tensor's data must be a string array.");ge=k}else{const q=Q.NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.get(C);if(q===void 0)throw new TypeError(`Unsupported tensor type: ${C}.`);if(Array.isArray(k)){if(C==="float16"&&q===Uint16Array||C==="uint4"||C==="int4")throw new TypeError(`Creating a ${C} tensor from number array is not supported. Please use ${q.name} as data.`);C==="uint64"||C==="int64"?ge=q.from(k,BigInt):ge=q.from(k)}else if(k instanceof q)ge=k;else if(k instanceof Uint8ClampedArray)if(C==="uint8")ge=Uint8Array.from(k);else throw new TypeError("A Uint8ClampedArray tensor's data must be type of uint8");else throw new TypeError(`A ${$} tensor's data must be type of ${q}`)}else if(le=k,Array.isArray(C)){if(C.length===0)throw new TypeError("Tensor type cannot be inferred from an empty array.");const q=typeof C[0];if(q==="string")$="string",ge=C;else if(q==="boolean")$="bool",ge=Uint8Array.from(C);else throw new TypeError(`Invalid element type of data array: ${q}.`)}else if(C instanceof Uint8ClampedArray)$="uint8",ge=Uint8Array.from(C);else{const q=Q.NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.get(C.constructor);if(q===void 0)throw new TypeError(`Unsupported type for tensor data: ${C.constructor}.`);$=q,ge=C}if(le===void 0)le=[ge.length];else if(!Array.isArray(le))throw new TypeError("A tensor's dims must be a number array");ae=le,this.cpuData=ge,this.dataLocation="cpu"}const fe=(0,se.calculateSize)(ae);if(this.cpuData&&fe!==this.cpuData.length&&!(($==="uint4"||$==="int4")&&Math.ceil(fe/2)===this.cpuData.length))throw new Error(`Tensor's size(${fe}) does not match data length(${this.cpuData.length}).`);this.type=$,this.dims=ae,this.size=fe}static async fromImage(C,k){return(0,R.tensorFromImage)(C,k)}static fromTexture(C,k){return(0,R.tensorFromTexture)(C,k)}static fromGpuBuffer(C,k){return(0,R.tensorFromGpuBuffer)(C,k)}static fromMLTensor(C,k){return(0,R.tensorFromMLTensor)(C,k)}static fromPinnedBuffer(C,k,A){return(0,R.tensorFromPinnedBuffer)(C,k,A)}toDataURL(C){return(0,P.tensorToDataURL)(this,C)}toImageData(C){return(0,P.tensorToImageData)(this,C)}get data(){if(this.ensureValid(),!this.cpuData)throw new Error("The data is not on CPU. Use `getData()` to download GPU data to CPU, or use `texture` or `gpuBuffer` property to access the GPU data directly.");return this.cpuData}get location(){return this.dataLocation}get texture(){if(this.ensureValid(),!this.gpuTextureData)throw new Error("The data is not stored as a WebGL texture.");return this.gpuTextureData}get gpuBuffer(){if(this.ensureValid(),!this.gpuBufferData)throw new Error("The data is not stored as a WebGPU buffer.");return this.gpuBufferData}get mlTensor(){if(this.ensureValid(),!this.mlTensorData)throw new Error("The data is not stored as a WebNN MLTensor.");return this.mlTensorData}async getData(C){switch(this.ensureValid(),this.dataLocation){case"cpu":case"cpu-pinned":return this.data;case"texture":case"gpu-buffer":case"ml-tensor":{if(!this.downloader)throw new Error("The current tensor is not created with a specified data downloader.");if(this.isDownloading)throw new Error("The current tensor is being downloaded.");try{this.isDownloading=!0;const k=await this.downloader();return this.downloader=void 0,this.dataLocation="cpu",this.cpuData=k,C&&this.disposer&&(this.disposer(),this.disposer=void 0),k}finally{this.isDownloading=!1}}default:throw new Error(`cannot get data from location: ${this.dataLocation}`)}}dispose(){if(this.isDownloading)throw new Error("The current tensor is being downloaded.");this.disposer&&(this.disposer(),this.disposer=void 0),this.cpuData=void 0,this.gpuTextureData=void 0,this.gpuBufferData=void 0,this.mlTensorData=void 0,this.downloader=void 0,this.isDownloading=void 0,this.dataLocation="none"}ensureValid(){if(this.dataLocation==="none")throw new Error("The tensor is disposed.")}reshape(C){if(this.ensureValid(),this.downloader||this.disposer)throw new Error("Cannot reshape a tensor that owns GPU resource.");return(0,se.tensorReshape)(this,C)}}},"./node_modules/onnxruntime-common/dist/esm/tensor-utils-impl.js":(ke,V,f)=>{f.r(V),f.d(V,{calculateSize:()=>R,tensorReshape:()=>Q});var P=f("./node_modules/onnxruntime-common/dist/esm/tensor-impl.js");const R=se=>{let oe=1;for(let E=0;E<se.length;E++){const C=se[E];if(typeof C!="number"||!Number.isSafeInteger(C))throw new TypeError(`dims[${E}] must be an integer, got: ${C}`);if(C<0)throw new RangeError(`dims[${E}] must be a non-negative integer, got: ${C}`);oe*=C}return oe},Q=(se,oe)=>{switch(se.location){case"cpu":return new P.Tensor(se.type,se.data,oe);case"cpu-pinned":return new P.Tensor({location:"cpu-pinned",data:se.data,type:se.type,dims:oe});case"texture":return new P.Tensor({location:"texture",texture:se.texture,type:se.type,dims:oe});case"gpu-buffer":return new P.Tensor({location:"gpu-buffer",gpuBuffer:se.gpuBuffer,type:se.type,dims:oe});case"ml-tensor":return new P.Tensor({location:"ml-tensor",mlTensor:se.mlTensor,type:se.type,dims:oe});default:throw new Error(`tensorReshape: tensor location ${se.location} is not supported`)}}},"./node_modules/onnxruntime-common/dist/esm/tensor.js":(ke,V,f)=>{f.r(V),f.d(V,{Tensor:()=>R});var P=f("./node_modules/onnxruntime-common/dist/esm/tensor-impl.js");const R=P.Tensor},"./node_modules/onnxruntime-common/dist/esm/trace.js":(ke,V,f)=>{f.r(V),f.d(V,{TRACE:()=>R,TRACE_FUNC_BEGIN:()=>se,TRACE_FUNC_END:()=>oe});var P=f("./node_modules/onnxruntime-common/dist/esm/env-impl.js");const R=(E,C)=>{(typeof P.env.trace>"u"?!P.env.wasm.trace:!P.env.trace)||console.timeStamp(`${E}::ORT::${C}`)},Q=(E,C)=>{var $;const k=(($=new Error().stack)==null?void 0:$.split(/\r\n|\r|\n/g))||[];let A=!1;for(let ae=0;ae<k.length;ae++){if(A&&!k[ae].includes("TRACE_FUNC")){let fe=`FUNC_${E}::${k[ae].trim().split(" ")[1]}`;C&&(fe+=`::${C}`),R("CPU",fe);return}k[ae].includes("TRACE_FUNC")&&(A=!0)}},se=E=>{(typeof P.env.trace>"u"?!P.env.wasm.trace:!P.env.trace)||Q("BEGIN",E)},oe=E=>{(typeof P.env.trace>"u"?!P.env.wasm.trace:!P.env.trace)||Q("END",E)}},"./node_modules/onnxruntime-common/dist/esm/training-session-impl.js":(ke,V,f)=>{f.r(V),f.d(V,{TrainingSession:()=>se});var P=f("./node_modules/onnxruntime-common/dist/esm/backend-impl.js"),R=f("./node_modules/onnxruntime-common/dist/esm/tensor.js");const Q="Training backend could not be resolved. Make sure you're using the correct configuration & WebAssembly files.";class se{constructor(E,C,k){this.handler=E,this.hasOptimizerModel=C,this.hasEvalModel=k}get trainingInputNames(){return this.handler.inputNames}get trainingOutputNames(){return this.handler.outputNames}get evalInputNames(){if(this.hasEvalModel)return this.handler.evalInputNames;throw new Error("This training session has no evalModel loaded.")}get evalOutputNames(){if(this.hasEvalModel)return this.handler.evalOutputNames;throw new Error("This training session has no evalModel loaded.")}static async create(E,C){const k=E.evalModel||"",A=E.optimizerModel||"",$=C||{},[ae,fe]=await(0,P.resolveBackendAndExecutionProviders)($);if(ae.createTrainingSessionHandler){const ge=await ae.createTrainingSessionHandler(E.checkpointState,E.trainModel,k,A,fe);return new se(ge,!!E.optimizerModel,!!E.evalModel)}else throw new Error(Q)}typeNarrowingForRunStep(E,C,k,A,$){const ae={};let fe={};if(typeof k!="object"||k===null||k instanceof R.Tensor||Array.isArray(k))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let ge=!0;if(typeof A=="object"){if(A===null)throw new TypeError("Unexpected argument[1]: cannot be null.");if(A instanceof R.Tensor)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(A)){if(A.length===0)throw new TypeError("'fetches' cannot be an empty array.");ge=!1;for(const le of A){if(typeof le!="string")throw new TypeError("'fetches' must be a string array or an object.");if(C.indexOf(le)===-1)throw new RangeError(`'fetches' contains invalid output name: ${le}.`);ae[le]=null}if(typeof $=="object"&&$!==null)fe=$;else if(typeof $<"u")throw new TypeError("'options' must be an object.")}else{let le=!1;const q=Object.getOwnPropertyNames(A);for(const ie of C)if(q.indexOf(ie)!==-1){const pe=A[ie];(pe===null||pe instanceof R.Tensor)&&(le=!0,ge=!1,ae[ie]=pe)}if(le){if(typeof $=="object"&&$!==null)fe=$;else if(typeof $<"u")throw new TypeError("'options' must be an object.")}else fe=A}}else if(typeof A<"u")throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(const le of E)if(typeof k[le]>"u")throw new Error(`input '${le}' is missing in 'feeds'.`);if(ge)for(const le of C)ae[le]=null;return[ae,fe]}convertHandlerReturnTypeToMapOfTensors(E){const C={};for(const k in E)if(Object.hasOwnProperty.call(E,k)){const A=E[k];A instanceof R.Tensor?C[k]=A:C[k]=new R.Tensor(A.type,A.data,A.dims)}return C}async lazyResetGrad(){await this.handler.lazyResetGrad()}async runTrainStep(E,C,k){const[A,$]=this.typeNarrowingForRunStep(this.trainingInputNames,this.trainingOutputNames,E,C,k),ae=await this.handler.runTrainStep(E,A,$);return this.convertHandlerReturnTypeToMapOfTensors(ae)}async runOptimizerStep(E){if(this.hasOptimizerModel)await this.handler.runOptimizerStep(E||{});else throw new Error("This TrainingSession has no OptimizerModel loaded.")}async runEvalStep(E,C,k){if(this.hasEvalModel){const[A,$]=this.typeNarrowingForRunStep(this.evalInputNames,this.evalOutputNames,E,C,k),ae=await this.handler.runEvalStep(E,A,$);return this.convertHandlerReturnTypeToMapOfTensors(ae)}else throw new Error("This TrainingSession has no EvalModel loaded.")}async getParametersSize(E=!0){return this.handler.getParametersSize(E)}async loadParametersBuffer(E,C=!0){const k=await this.getParametersSize(C);if(E.length!==4*k)throw new Error("Size of the buffer passed into loadParametersBuffer must match the number of parameters in the model. Please use getParametersSize method to check.");return this.handler.loadParametersBuffer(E,C)}async getContiguousParameters(E=!0){return this.handler.getContiguousParameters(E)}async release(){return this.handler.dispose()}}},"./node_modules/onnxruntime-common/dist/esm/training-session.js":(ke,V,f)=>{f.r(V),f.d(V,{TrainingSession:()=>R});var P=f("./node_modules/onnxruntime-common/dist/esm/training-session-impl.js");const R=P.TrainingSession},"./node_modules/onnxruntime-common/dist/esm/version.js":(ke,V,f)=>{f.r(V),f.d(V,{version:()=>P});const P="1.20.1"},"./node_modules/onnxruntime-web/dist/ort.webgpu.bundle.min.mjs":(ke,V,f)=>{f.r(V),f.d(V,{InferenceSession:()=>wt,TRACE:()=>lt,TRACE_FUNC_BEGIN:()=>st,TRACE_FUNC_END:()=>Xe,Tensor:()=>be,TrainingSession:()=>gt,default:()=>K,env:()=>L,registerBackend:()=>fe});/*!
 * ONNX Runtime Web v1.20.1
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */var P=Object.defineProperty,R=Object.getOwnPropertyDescriptor,Q=Object.getOwnPropertyNames,se=Object.prototype.hasOwnProperty,oe=(e=>typeof require<"u"?require:typeof Proxy<"u"?new Proxy(e,{get:(r,s)=>(typeof require<"u"?require:r)[s]}):e)(function(e){if(typeof require<"u")return require.apply(this,arguments);throw Error('Dynamic require of "'+e+'" is not supported')}),E=(e,r)=>()=>(e&&(r=e(e=0)),r),C=(e,r)=>{for(var s in r)P(e,s,{get:r[s],enumerable:!0})},k=(e,r,s,i)=>{if(r&&typeof r=="object"||typeof r=="function")for(let a of Q(r))!se.call(e,a)&&a!==s&&P(e,a,{get:()=>r[a],enumerable:!(i=R(r,a))||i.enumerable});return e},A=e=>k(P({},"__esModule",{value:!0}),e),$,ae,fe,ge,le,q=E(()=>{$=new Map,ae=[],fe=(e,r,s)=>{if(r&&typeof r.init=="function"&&typeof r.createInferenceSessionHandler=="function"){let i=$.get(e);if(i===void 0)$.set(e,{backend:r,priority:s});else{if(i.priority>s)return;if(i.priority===s&&i.backend!==r)throw new Error(`cannot register backend "${e}" using priority ${s}`)}if(s>=0){let a=ae.indexOf(e);a!==-1&&ae.splice(a,1);for(let c=0;c<ae.length;c++)if($.get(ae[c]).priority<=s){ae.splice(c,0,e);return}ae.push(e)}return}throw new TypeError("not a valid backend")},ge=async e=>{let r=$.get(e);if(!r)return"backend not found.";if(r.initialized)return r.backend;if(r.aborted)return r.error;{let s=!!r.initPromise;try{return s||(r.initPromise=r.backend.init(e)),await r.initPromise,r.initialized=!0,r.backend}catch(i){return s||(r.error=`${i}`,r.aborted=!0),r.error}finally{delete r.initPromise}}},le=async e=>{let r=e.executionProviders||[],s=r.map(_=>typeof _=="string"?_:_.name),i=s.length===0?ae:s,a,c=[],l=new Set;for(let _ of i){let w=await ge(_);typeof w=="string"?c.push({name:_,err:w}):(a||(a=w),a===w&&l.add(_))}if(!a)throw new Error(`no available backend found. ERR: ${c.map(_=>`[${_.name}] ${_.err}`).join(", ")}`);for(let{name:_,err:w}of c)s.includes(_)&&console.warn(`removing requested execution provider "${_}" from session options because it is not available: ${w}`);let h=r.filter(_=>l.has(typeof _=="string"?_:_.name));return[a,new Proxy(e,{get:(_,w)=>w==="executionProviders"?h:Reflect.get(_,w)})]}}),ie=E(()=>{q()}),pe,X=E(()=>{pe="1.20.1"}),W,b,z=E(()=>{X(),W="warning",b={wasm:{},webgl:{},webgpu:{},versions:{common:pe},set logLevel(e){if(e!==void 0){if(typeof e!="string"||["verbose","info","warning","error","fatal"].indexOf(e)===-1)throw new Error(`Unsupported logging level: ${e}`);W=e}},get logLevel(){return W}},Object.defineProperty(b,"logLevel",{enumerable:!0})}),L,de=E(()=>{z(),L=b}),ce,Pe,Ee=E(()=>{ce=(e,r)=>{let s=typeof document<"u"?document.createElement("canvas"):new OffscreenCanvas(1,1);s.width=e.dims[3],s.height=e.dims[2];let i=s.getContext("2d");if(i!=null){let a,c;(r==null?void 0:r.tensorLayout)!==void 0&&r.tensorLayout==="NHWC"?(a=e.dims[2],c=e.dims[3]):(a=e.dims[3],c=e.dims[2]);let l=(r==null?void 0:r.format)!==void 0?r.format:"RGB",h=r==null?void 0:r.norm,_,w;h===void 0||h.mean===void 0?_=[255,255,255,255]:typeof h.mean=="number"?_=[h.mean,h.mean,h.mean,h.mean]:(_=[h.mean[0],h.mean[1],h.mean[2],0],h.mean[3]!==void 0&&(_[3]=h.mean[3])),h===void 0||h.bias===void 0?w=[0,0,0,0]:typeof h.bias=="number"?w=[h.bias,h.bias,h.bias,h.bias]:(w=[h.bias[0],h.bias[1],h.bias[2],0],h.bias[3]!==void 0&&(w[3]=h.bias[3]));let v=c*a,y=0,d=v,S=v*2,B=-1;l==="RGBA"?(y=0,d=v,S=v*2,B=v*3):l==="RGB"?(y=0,d=v,S=v*2):l==="RBG"&&(y=0,S=v,d=v*2);for(let j=0;j<c;j++)for(let Y=0;Y<a;Y++){let te=(e.data[y++]-w[0])*_[0],J=(e.data[d++]-w[1])*_[1],ye=(e.data[S++]-w[2])*_[2],ve=B===-1?255:(e.data[B++]-w[3])*_[3];i.fillStyle="rgba("+te+","+J+","+ye+","+ve+")",i.fillRect(Y,j,1,1)}if("toDataURL"in s)return s.toDataURL();throw new Error("toDataURL is not supported")}else throw new Error("Can not access image data")},Pe=(e,r)=>{let s=typeof document<"u"?document.createElement("canvas").getContext("2d"):new OffscreenCanvas(1,1).getContext("2d"),i;if(s!=null){let a,c,l;(r==null?void 0:r.tensorLayout)!==void 0&&r.tensorLayout==="NHWC"?(a=e.dims[2],c=e.dims[1],l=e.dims[3]):(a=e.dims[3],c=e.dims[2],l=e.dims[1]);let h=r!==void 0&&r.format!==void 0?r.format:"RGB",_=r==null?void 0:r.norm,w,v;_===void 0||_.mean===void 0?w=[255,255,255,255]:typeof _.mean=="number"?w=[_.mean,_.mean,_.mean,_.mean]:(w=[_.mean[0],_.mean[1],_.mean[2],255],_.mean[3]!==void 0&&(w[3]=_.mean[3])),_===void 0||_.bias===void 0?v=[0,0,0,0]:typeof _.bias=="number"?v=[_.bias,_.bias,_.bias,_.bias]:(v=[_.bias[0],_.bias[1],_.bias[2],0],_.bias[3]!==void 0&&(v[3]=_.bias[3]));let y=c*a;if(r!==void 0&&(r.format!==void 0&&l===4&&r.format!=="RGBA"||l===3&&r.format!=="RGB"&&r.format!=="BGR"))throw new Error("Tensor format doesn't match input tensor dims");let d=4,S=0,B=1,j=2,Y=3,te=0,J=y,ye=y*2,ve=-1;h==="RGBA"?(te=0,J=y,ye=y*2,ve=y*3):h==="RGB"?(te=0,J=y,ye=y*2):h==="RBG"&&(te=0,ye=y,J=y*2),i=s.createImageData(a,c);for(let Ce=0;Ce<c*a;S+=d,B+=d,j+=d,Y+=d,Ce++)i.data[S]=(e.data[te++]-v[0])*w[0],i.data[B]=(e.data[J++]-v[1])*w[1],i.data[j]=(e.data[ye++]-v[2])*w[2],i.data[Y]=ve===-1?255:(e.data[ve++]-v[3])*w[3]}else throw new Error("Can not access image data");return i}}),Se,Be,Le,He,Me,N,me=E(()=>{We(),Se=(e,r)=>{if(e===void 0)throw new Error("Image buffer must be defined");if(r.height===void 0||r.width===void 0)throw new Error("Image height and width must be defined");if(r.tensorLayout==="NHWC")throw new Error("NHWC Tensor layout is not supported yet");let{height:s,width:i}=r,a=r.norm??{mean:255,bias:0},c,l;typeof a.mean=="number"?c=[a.mean,a.mean,a.mean,a.mean]:c=[a.mean[0],a.mean[1],a.mean[2],a.mean[3]??255],typeof a.bias=="number"?l=[a.bias,a.bias,a.bias,a.bias]:l=[a.bias[0],a.bias[1],a.bias[2],a.bias[3]??0];let h=r.format!==void 0?r.format:"RGBA",_=r.tensorFormat!==void 0&&r.tensorFormat!==void 0?r.tensorFormat:"RGB",w=s*i,v=_==="RGBA"?new Float32Array(w*4):new Float32Array(w*3),y=4,d=0,S=1,B=2,j=3,Y=0,te=w,J=w*2,ye=-1;h==="RGB"&&(y=3,d=0,S=1,B=2,j=-1),_==="RGBA"?ye=w*3:_==="RBG"?(Y=0,J=w,te=w*2):_==="BGR"&&(J=0,te=w,Y=w*2);for(let ve=0;ve<w;ve++,d+=y,B+=y,S+=y,j+=y)v[Y++]=(e[d]+l[0])/c[0],v[te++]=(e[S]+l[1])/c[1],v[J++]=(e[B]+l[2])/c[2],ye!==-1&&j!==-1&&(v[ye++]=(e[j]+l[3])/c[3]);return _==="RGBA"?new Je("float32",v,[1,4,s,i]):new Je("float32",v,[1,3,s,i])},Be=async(e,r)=>{let s=typeof HTMLImageElement<"u"&&e instanceof HTMLImageElement,i=typeof ImageData<"u"&&e instanceof ImageData,a=typeof ImageBitmap<"u"&&e instanceof ImageBitmap,c=typeof e=="string",l,h=r??{},_=()=>{if(typeof document<"u")return document.createElement("canvas");if(typeof OffscreenCanvas<"u")return new OffscreenCanvas(1,1);throw new Error("Canvas is not supported")},w=v=>typeof HTMLCanvasElement<"u"&&v instanceof HTMLCanvasElement||v instanceof OffscreenCanvas?v.getContext("2d"):null;if(s){let v=_();v.width=e.width,v.height=e.height;let y=w(v);if(y!=null){let d=e.height,S=e.width;if(r!==void 0&&r.resizedHeight!==void 0&&r.resizedWidth!==void 0&&(d=r.resizedHeight,S=r.resizedWidth),r!==void 0){if(h=r,r.tensorFormat!==void 0)throw new Error("Image input config format must be RGBA for HTMLImageElement");h.tensorFormat="RGBA",h.height=d,h.width=S}else h.tensorFormat="RGBA",h.height=d,h.width=S;y.drawImage(e,0,0),l=y.getImageData(0,0,S,d).data}else throw new Error("Can not access image data")}else if(i){let v,y;if(r!==void 0&&r.resizedWidth!==void 0&&r.resizedHeight!==void 0?(v=r.resizedHeight,y=r.resizedWidth):(v=e.height,y=e.width),r!==void 0&&(h=r),h.format="RGBA",h.height=v,h.width=y,r!==void 0){let d=_();d.width=y,d.height=v;let S=w(d);if(S!=null)S.putImageData(e,0,0),l=S.getImageData(0,0,y,v).data;else throw new Error("Can not access image data")}else l=e.data}else if(a){if(r===void 0)throw new Error("Please provide image config with format for Imagebitmap");let v=_();v.width=e.width,v.height=e.height;let y=w(v);if(y!=null){let d=e.height,S=e.width;return y.drawImage(e,0,0,S,d),l=y.getImageData(0,0,S,d).data,h.height=d,h.width=S,Se(l,h)}else throw new Error("Can not access image data")}else{if(c)return new Promise((v,y)=>{let d=_(),S=w(d);if(!e||!S)return y();let B=new Image;B.crossOrigin="Anonymous",B.src=e,B.onload=()=>{d.width=B.width,d.height=B.height,S.drawImage(B,0,0,d.width,d.height);let j=S.getImageData(0,0,d.width,d.height);h.height=d.height,h.width=d.width,v(Se(j.data,h))}});throw new Error("Input data provided is not supported - aborted tensor creation")}if(l!==void 0)return Se(l,h);throw new Error("Input data provided is not supported - aborted tensor creation")},Le=(e,r)=>{let{width:s,height:i,download:a,dispose:c}=r,l=[1,i,s,4];return new Je({location:"texture",type:"float32",texture:e,dims:l,download:a,dispose:c})},He=(e,r)=>{let{dataType:s,dims:i,download:a,dispose:c}=r;return new Je({location:"gpu-buffer",type:s??"float32",gpuBuffer:e,dims:i,download:a,dispose:c})},Me=(e,r)=>{let{dataType:s,dims:i,download:a,dispose:c}=r;return new Je({location:"ml-tensor",type:s??"float32",mlTensor:e,dims:i,download:a,dispose:c})},N=(e,r,s)=>new Je({location:"cpu-pinned",type:e,data:r,dims:s??[r.length]})}),ue,ee,Te,je,qe=E(()=>{ue=new Map([["float32",Float32Array],["uint8",Uint8Array],["int8",Int8Array],["uint16",Uint16Array],["int16",Int16Array],["int32",Int32Array],["bool",Uint8Array],["float64",Float64Array],["uint32",Uint32Array],["int4",Uint8Array],["uint4",Uint8Array]]),ee=new Map([[Float32Array,"float32"],[Uint8Array,"uint8"],[Int8Array,"int8"],[Uint16Array,"uint16"],[Int16Array,"int16"],[Int32Array,"int32"],[Float64Array,"float64"],[Uint32Array,"uint32"]]),Te=!1,je=()=>{if(!Te){Te=!0;let e=typeof BigInt64Array<"u"&&BigInt64Array.from,r=typeof BigUint64Array<"u"&&BigUint64Array.from,s=typeof Float16Array<"u"&&Float16Array.from;e&&(ue.set("int64",BigInt64Array),ee.set(BigInt64Array,"int64")),r&&(ue.set("uint64",BigUint64Array),ee.set(BigUint64Array,"uint64")),s?(ue.set("float16",Float16Array),ee.set(Float16Array,"float16")):ue.set("float16",Uint16Array)}}}),tt,he,Ve=E(()=>{We(),tt=e=>{let r=1;for(let s=0;s<e.length;s++){let i=e[s];if(typeof i!="number"||!Number.isSafeInteger(i))throw new TypeError(`dims[${s}] must be an integer, got: ${i}`);if(i<0)throw new RangeError(`dims[${s}] must be a non-negative integer, got: ${i}`);r*=i}return r},he=(e,r)=>{switch(e.location){case"cpu":return new Je(e.type,e.data,r);case"cpu-pinned":return new Je({location:"cpu-pinned",data:e.data,type:e.type,dims:r});case"texture":return new Je({location:"texture",texture:e.texture,type:e.type,dims:r});case"gpu-buffer":return new Je({location:"gpu-buffer",gpuBuffer:e.gpuBuffer,type:e.type,dims:r});case"ml-tensor":return new Je({location:"ml-tensor",mlTensor:e.mlTensor,type:e.type,dims:r});default:throw new Error(`tensorReshape: tensor location ${e.location} is not supported`)}}}),Je,We=E(()=>{Ee(),me(),qe(),Ve(),Je=class{constructor(e,r,s){je();let i,a;if(typeof e=="object"&&"location"in e)switch(this.dataLocation=e.location,i=e.type,a=e.dims,e.location){case"cpu-pinned":{let l=ue.get(i);if(!l)throw new TypeError(`unsupported type "${i}" to create tensor from pinned buffer`);if(!(e.data instanceof l))throw new TypeError(`buffer should be of type ${l.name}`);this.cpuData=e.data;break}case"texture":{if(i!=="float32")throw new TypeError(`unsupported type "${i}" to create tensor from texture`);this.gpuTextureData=e.texture,this.downloader=e.download,this.disposer=e.dispose;break}case"gpu-buffer":{if(i!=="float32"&&i!=="float16"&&i!=="int32"&&i!=="int64"&&i!=="uint32"&&i!=="uint8"&&i!=="bool"&&i!=="uint4"&&i!=="int4")throw new TypeError(`unsupported type "${i}" to create tensor from gpu buffer`);this.gpuBufferData=e.gpuBuffer,this.downloader=e.download,this.disposer=e.dispose;break}case"ml-tensor":{if(i!=="float32"&&i!=="float16"&&i!=="int32"&&i!=="int64"&&i!=="uint32"&&i!=="uint64"&&i!=="int8"&&i!=="uint8"&&i!=="bool")throw new TypeError(`unsupported type "${i}" to create tensor from MLTensor`);this.mlTensorData=e.mlTensor,this.downloader=e.download,this.disposer=e.dispose;break}default:throw new Error(`Tensor constructor: unsupported location '${this.dataLocation}'`)}else{let l,h;if(typeof e=="string")if(i=e,h=s,e==="string"){if(!Array.isArray(r))throw new TypeError("A string tensor's data must be a string array.");l=r}else{let _=ue.get(e);if(_===void 0)throw new TypeError(`Unsupported tensor type: ${e}.`);if(Array.isArray(r)){if(e==="float16"&&_===Uint16Array||e==="uint4"||e==="int4")throw new TypeError(`Creating a ${e} tensor from number array is not supported. Please use ${_.name} as data.`);e==="uint64"||e==="int64"?l=_.from(r,BigInt):l=_.from(r)}else if(r instanceof _)l=r;else if(r instanceof Uint8ClampedArray)if(e==="uint8")l=Uint8Array.from(r);else throw new TypeError("A Uint8ClampedArray tensor's data must be type of uint8");else throw new TypeError(`A ${i} tensor's data must be type of ${_}`)}else if(h=r,Array.isArray(e)){if(e.length===0)throw new TypeError("Tensor type cannot be inferred from an empty array.");let _=typeof e[0];if(_==="string")i="string",l=e;else if(_==="boolean")i="bool",l=Uint8Array.from(e);else throw new TypeError(`Invalid element type of data array: ${_}.`)}else if(e instanceof Uint8ClampedArray)i="uint8",l=Uint8Array.from(e);else{let _=ee.get(e.constructor);if(_===void 0)throw new TypeError(`Unsupported type for tensor data: ${e.constructor}.`);i=_,l=e}if(h===void 0)h=[l.length];else if(!Array.isArray(h))throw new TypeError("A tensor's dims must be a number array");a=h,this.cpuData=l,this.dataLocation="cpu"}let c=tt(a);if(this.cpuData&&c!==this.cpuData.length&&!((i==="uint4"||i==="int4")&&Math.ceil(c/2)===this.cpuData.length))throw new Error(`Tensor's size(${c}) does not match data length(${this.cpuData.length}).`);this.type=i,this.dims=a,this.size=c}static async fromImage(e,r){return Be(e,r)}static fromTexture(e,r){return Le(e,r)}static fromGpuBuffer(e,r){return He(e,r)}static fromMLTensor(e,r){return Me(e,r)}static fromPinnedBuffer(e,r,s){return N(e,r,s)}toDataURL(e){return ce(this,e)}toImageData(e){return Pe(this,e)}get data(){if(this.ensureValid(),!this.cpuData)throw new Error("The data is not on CPU. Use `getData()` to download GPU data to CPU, or use `texture` or `gpuBuffer` property to access the GPU data directly.");return this.cpuData}get location(){return this.dataLocation}get texture(){if(this.ensureValid(),!this.gpuTextureData)throw new Error("The data is not stored as a WebGL texture.");return this.gpuTextureData}get gpuBuffer(){if(this.ensureValid(),!this.gpuBufferData)throw new Error("The data is not stored as a WebGPU buffer.");return this.gpuBufferData}get mlTensor(){if(this.ensureValid(),!this.mlTensorData)throw new Error("The data is not stored as a WebNN MLTensor.");return this.mlTensorData}async getData(e){switch(this.ensureValid(),this.dataLocation){case"cpu":case"cpu-pinned":return this.data;case"texture":case"gpu-buffer":case"ml-tensor":{if(!this.downloader)throw new Error("The current tensor is not created with a specified data downloader.");if(this.isDownloading)throw new Error("The current tensor is being downloaded.");try{this.isDownloading=!0;let r=await this.downloader();return this.downloader=void 0,this.dataLocation="cpu",this.cpuData=r,e&&this.disposer&&(this.disposer(),this.disposer=void 0),r}finally{this.isDownloading=!1}}default:throw new Error(`cannot get data from location: ${this.dataLocation}`)}}dispose(){if(this.isDownloading)throw new Error("The current tensor is being downloaded.");this.disposer&&(this.disposer(),this.disposer=void 0),this.cpuData=void 0,this.gpuTextureData=void 0,this.gpuBufferData=void 0,this.mlTensorData=void 0,this.downloader=void 0,this.isDownloading=void 0,this.dataLocation="none"}ensureValid(){if(this.dataLocation==="none")throw new Error("The tensor is disposed.")}reshape(e){if(this.ensureValid(),this.downloader||this.disposer)throw new Error("Cannot reshape a tensor that owns GPU resource.");return he(this,e)}}}),be,Re=E(()=>{We(),be=Je}),lt,ot,st,Xe,pt=E(()=>{z(),lt=(e,r)=>{(typeof b.trace>"u"?!b.wasm.trace:!b.trace)||console.timeStamp(`${e}::ORT::${r}`)},ot=(e,r)=>{var a;let s=((a=new Error().stack)==null?void 0:a.split(/\r\n|\r|\n/g))||[],i=!1;for(let c=0;c<s.length;c++){if(i&&!s[c].includes("TRACE_FUNC")){let l=`FUNC_${e}::${s[c].trim().split(" ")[1]}`;r&&(l+=`::${r}`),lt("CPU",l);return}s[c].includes("TRACE_FUNC")&&(i=!0)}},st=e=>{(typeof b.trace>"u"?!b.wasm.trace:!b.trace)||ot("BEGIN",e)},Xe=e=>{(typeof b.trace>"u"?!b.wasm.trace:!b.trace)||ot("END",e)}}),_t,Et=E(()=>{q(),Re(),pt(),_t=class vm{constructor(r){this.handler=r}async run(r,s,i){st();let a={},c={};if(typeof r!="object"||r===null||r instanceof be||Array.isArray(r))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let l=!0;if(typeof s=="object"){if(s===null)throw new TypeError("Unexpected argument[1]: cannot be null.");if(s instanceof be)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(s)){if(s.length===0)throw new TypeError("'fetches' cannot be an empty array.");l=!1;for(let w of s){if(typeof w!="string")throw new TypeError("'fetches' must be a string array or an object.");if(this.outputNames.indexOf(w)===-1)throw new RangeError(`'fetches' contains invalid output name: ${w}.`);a[w]=null}if(typeof i=="object"&&i!==null)c=i;else if(typeof i<"u")throw new TypeError("'options' must be an object.")}else{let w=!1,v=Object.getOwnPropertyNames(s);for(let y of this.outputNames)if(v.indexOf(y)!==-1){let d=s[y];(d===null||d instanceof be)&&(w=!0,l=!1,a[y]=d)}if(w){if(typeof i=="object"&&i!==null)c=i;else if(typeof i<"u")throw new TypeError("'options' must be an object.")}else c=s}}else if(typeof s<"u")throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(let w of this.inputNames)if(typeof r[w]>"u")throw new Error(`input '${w}' is missing in 'feeds'.`);if(l)for(let w of this.outputNames)a[w]=null;let h=await this.handler.run(r,a,c),_={};for(let w in h)if(Object.hasOwnProperty.call(h,w)){let v=h[w];v instanceof be?_[w]=v:_[w]=new be(v.type,v.data,v.dims)}return Xe(),_}async release(){return this.handler.dispose()}static async create(r,s,i,a){st();let c,l={};if(typeof r=="string"){if(c=r,typeof s=="object"&&s!==null)l=s;else if(typeof s<"u")throw new TypeError("'options' must be an object.")}else if(r instanceof Uint8Array){if(c=r,typeof s=="object"&&s!==null)l=s;else if(typeof s<"u")throw new TypeError("'options' must be an object.")}else if(r instanceof ArrayBuffer||typeof SharedArrayBuffer<"u"&&r instanceof SharedArrayBuffer){let v=r,y=0,d=r.byteLength;if(typeof s=="object"&&s!==null)l=s;else if(typeof s=="number"){if(y=s,!Number.isSafeInteger(y))throw new RangeError("'byteOffset' must be an integer.");if(y<0||y>=v.byteLength)throw new RangeError(`'byteOffset' is out of range [0, ${v.byteLength}).`);if(d=r.byteLength-y,typeof i=="number"){if(d=i,!Number.isSafeInteger(d))throw new RangeError("'byteLength' must be an integer.");if(d<=0||y+d>v.byteLength)throw new RangeError(`'byteLength' is out of range (0, ${v.byteLength-y}].`);if(typeof a=="object"&&a!==null)l=a;else if(typeof a<"u")throw new TypeError("'options' must be an object.")}else if(typeof i<"u")throw new TypeError("'byteLength' must be a number.")}else if(typeof s<"u")throw new TypeError("'options' must be an object.");c=new Uint8Array(v,y,d)}else throw new TypeError("Unexpected argument[0]: must be 'path' or 'buffer'.");let[h,_]=await le(l),w=await h.createInferenceSessionHandler(c,_);return Xe(),new vm(w)}startProfiling(){this.handler.startProfiling()}endProfiling(){this.handler.endProfiling()}get inputNames(){return this.handler.inputNames}get outputNames(){return this.handler.outputNames}}}),wt,vt=E(()=>{Et(),wt=_t}),U=E(()=>{}),_e=E(()=>{}),Z=E(()=>{}),xe=E(()=>{}),Ne,at,ct=E(()=>{q(),Re(),Ne="Training backend could not be resolved. Make sure you're using the correct configuration & WebAssembly files.",at=class Mm{constructor(r,s,i){this.handler=r,this.hasOptimizerModel=s,this.hasEvalModel=i}get trainingInputNames(){return this.handler.inputNames}get trainingOutputNames(){return this.handler.outputNames}get evalInputNames(){if(this.hasEvalModel)return this.handler.evalInputNames;throw new Error("This training session has no evalModel loaded.")}get evalOutputNames(){if(this.hasEvalModel)return this.handler.evalOutputNames;throw new Error("This training session has no evalModel loaded.")}static async create(r,s){let i=r.evalModel||"",a=r.optimizerModel||"",c=s||{},[l,h]=await le(c);if(l.createTrainingSessionHandler){let _=await l.createTrainingSessionHandler(r.checkpointState,r.trainModel,i,a,h);return new Mm(_,!!r.optimizerModel,!!r.evalModel)}else throw new Error(Ne)}typeNarrowingForRunStep(r,s,i,a,c){let l={},h={};if(typeof i!="object"||i===null||i instanceof be||Array.isArray(i))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let _=!0;if(typeof a=="object"){if(a===null)throw new TypeError("Unexpected argument[1]: cannot be null.");if(a instanceof be)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(a)){if(a.length===0)throw new TypeError("'fetches' cannot be an empty array.");_=!1;for(let w of a){if(typeof w!="string")throw new TypeError("'fetches' must be a string array or an object.");if(s.indexOf(w)===-1)throw new RangeError(`'fetches' contains invalid output name: ${w}.`);l[w]=null}if(typeof c=="object"&&c!==null)h=c;else if(typeof c<"u")throw new TypeError("'options' must be an object.")}else{let w=!1,v=Object.getOwnPropertyNames(a);for(let y of s)if(v.indexOf(y)!==-1){let d=a[y];(d===null||d instanceof be)&&(w=!0,_=!1,l[y]=d)}if(w){if(typeof c=="object"&&c!==null)h=c;else if(typeof c<"u")throw new TypeError("'options' must be an object.")}else h=a}}else if(typeof a<"u")throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(let w of r)if(typeof i[w]>"u")throw new Error(`input '${w}' is missing in 'feeds'.`);if(_)for(let w of s)l[w]=null;return[l,h]}convertHandlerReturnTypeToMapOfTensors(r){let s={};for(let i in r)if(Object.hasOwnProperty.call(r,i)){let a=r[i];a instanceof be?s[i]=a:s[i]=new be(a.type,a.data,a.dims)}return s}async lazyResetGrad(){await this.handler.lazyResetGrad()}async runTrainStep(r,s,i){let[a,c]=this.typeNarrowingForRunStep(this.trainingInputNames,this.trainingOutputNames,r,s,i),l=await this.handler.runTrainStep(r,a,c);return this.convertHandlerReturnTypeToMapOfTensors(l)}async runOptimizerStep(r){if(this.hasOptimizerModel)await this.handler.runOptimizerStep(r||{});else throw new Error("This TrainingSession has no OptimizerModel loaded.")}async runEvalStep(r,s,i){if(this.hasEvalModel){let[a,c]=this.typeNarrowingForRunStep(this.evalInputNames,this.evalOutputNames,r,s,i),l=await this.handler.runEvalStep(r,a,c);return this.convertHandlerReturnTypeToMapOfTensors(l)}else throw new Error("This TrainingSession has no EvalModel loaded.")}async getParametersSize(r=!0){return this.handler.getParametersSize(r)}async loadParametersBuffer(r,s=!0){let i=await this.getParametersSize(s);if(r.length!==4*i)throw new Error("Size of the buffer passed into loadParametersBuffer must match the number of parameters in the model. Please use getParametersSize method to check.");return this.handler.loadParametersBuffer(r,s)}async getContiguousParameters(r=!0){return this.handler.getContiguousParameters(r)}async release(){return this.handler.dispose()}}}),gt,zt=E(()=>{ct(),gt=at}),$t={};C($t,{InferenceSession:()=>wt,TRACE:()=>lt,TRACE_FUNC_BEGIN:()=>st,TRACE_FUNC_END:()=>Xe,Tensor:()=>be,TrainingSession:()=>gt,env:()=>L,registerBackend:()=>fe});var St=E(()=>{ie(),de(),vt(),Re(),U(),_e(),pt(),Z(),xe(),zt()}),Ft=E(()=>{}),gr={};C(gr,{default:()=>an});var Cr,rn,an,Pn=E(()=>{var e;vp(),rs(),Cs(),Cr="ort-wasm-proxy-worker",rn=((e=globalThis.self)==null?void 0:e.name)===Cr,rn&&(self.onmessage=r=>{let{type:s,in:i}=r.data;try{switch(s){case"init-wasm":ao(i.wasm).then(()=>{$p(i).then(()=>{postMessage({type:s})},a=>{postMessage({type:s,err:a})})},a=>{postMessage({type:s,err:a})});break;case"init-ep":{let{epName:a,env:c}=i;wp(c,a).then(()=>{postMessage({type:s})},l=>{postMessage({type:s,err:l})});break}case"copy-from":{let{buffer:a}=i,c=bs(a);postMessage({type:s,out:c});break}case"create":{let{model:a,options:c}=i;np(a,c).then(l=>{postMessage({type:s,out:l})},l=>{postMessage({type:s,err:l})});break}case"release":Ip(i),postMessage({type:s});break;case"run":{let{sessionId:a,inputIndices:c,inputs:l,outputIndices:h,options:_}=i;Xc(a,c,l,h,new Array(h.length).fill(null),_).then(w=>{w.some(v=>v[3]!=="cpu")?postMessage({type:s,err:"Proxy does not support non-cpu tensor location."}):postMessage({type:s,out:w},Yc([...l,...w]))},w=>{postMessage({type:s,err:w})});break}case"end-profiling":ca(i),postMessage({type:s});break;default:}}catch(a){postMessage({type:s,err:a})}}),an=rn?null:r=>new Worker(r??fs,{type:"module",name:Cr})}),Ns={};C(Ns,{default:()=>Bn});var Us,Ps,Bn,Gt=E(()=>{var e;Ps=(Us=import.meta.url,async function(r={}){function s(){return yr.buffer!=tr.buffer&&es(),tr}function i(){return yr.buffer!=tr.buffer&&es(),Ir}function a(){return yr.buffer!=tr.buffer&&es(),et}function c(){return yr.buffer!=tr.buffer&&es(),xt}function l(){return yr.buffer!=tr.buffer&&es(),rr}function h(){return yr.buffer!=tr.buffer&&es(),jr}function _(){return yr.buffer!=tr.buffer&&es(),Fn}function w(){return yr.buffer!=tr.buffer&&es(),Vp}var v,y,d=Object.assign({},r),S=new Promise((p,x)=>{v=p,y=x}),B=typeof window=="object",j=typeof importScripts=="function",Y=j&&self.name=="em-pthread";d.mountExternalData=(p,x)=>{p.startsWith("./")&&(p=p.substring(2)),(d.Fb||(d.Fb=new Map)).set(p,x)},d.unmountExternalData=()=>{delete d.Fb};var te=globalThis.SharedArrayBuffer??new WebAssembly.Memory({initial:0,maximum:0,shared:!0}).buffer.constructor;let J=()=>{let p=(D,H,re)=>(...Ae)=>{let nt=sl,ht=H==null?void 0:H();Ae=D(...Ae);let Ct=H==null?void 0:H();return ht!==Ct&&(D=Ct,re(ht),H=re=null),sl!=nt?new Promise((Lt,er)=>{Tf={resolve:Lt,reject:er}}):Ae},x=D=>async(...H)=>{var re;try{if(d.Eb)throw Error("Session already started");let Ae=d.Eb={fc:H[0],errors:[]},nt=await D(...H);if(d.Eb!==Ae)throw Error("Session mismatch");(re=d.Gb)==null||re.flush();let ht=Ae.errors;if(0<ht.length){let Ct=await Promise.all(ht);if(Ct=Ct.filter(Lt=>Lt),0<Ct.length)throw Error(Ct.join(`
`))}return nt}finally{d.Eb=null}};d._OrtCreateSession=p(d._OrtCreateSession,()=>d._OrtCreateSession,D=>d._OrtCreateSession=D),d._OrtRun=x(p(d._OrtRun,()=>d._OrtRun,D=>d._OrtRun=D)),d._OrtRunWithBinding=x(p(d._OrtRunWithBinding,()=>d._OrtRunWithBinding,D=>d._OrtRunWithBinding=D)),d._OrtBindInput=p(d._OrtBindInput,()=>d._OrtBindInput,D=>d._OrtBindInput=D),J=void 0};d.jsepInit=(p,x)=>{if(J==null||J(),p==="webgpu"){[d.Gb,d.Ub,d.Yb,d.Nb,d.Xb,d.jb,d.Zb,d.bc,d.Vb,d.Wb,d.$b]=x;let D=d.Gb;d.jsepRegisterBuffer=(H,re,Ae,nt)=>D.registerBuffer(H,re,Ae,nt),d.jsepGetBuffer=H=>D.getBuffer(H),d.jsepCreateDownloader=(H,re,Ae)=>D.createDownloader(H,re,Ae),d.jsepOnReleaseSession=H=>{D.onReleaseSession(H)},d.jsepOnRunStart=H=>D.onRunStart(H),d.cc=(H,re)=>{D.upload(H,re)}}else if(p==="webnn"){[d.Gb,d.ac,d.Ob,d.jsepEnsureTensor,d.dc,d.jsepDownloadTensor]=x,d.jsepReleaseTensorId=d.Ob;let D=d.Gb;d.jsepOnRunStart=H=>D.onRunStart(H),d.jsepRegisterMLContext=(H,re)=>{D.registerMLContext(H,re)},d.jsepOnReleaseSession=H=>{D.onReleaseSession(H)},d.jsepCreateMLTensorDownloader=(H,re)=>D.createMLTensorDownloader(H,re),d.jsepRegisterMLTensor=(H,re,Ae)=>D.registerMLTensor(H,re,Ae)}};var ye,ve,Ce=Object.assign({},d),Ze="./this.program",Ke=(p,x)=>{throw x},ft="";(B||j)&&(j?ft=self.location.href:typeof document<"u"&&document.currentScript&&(ft=document.currentScript.src),Us&&(ft=Us),ft=ft.startsWith("blob:")?"":ft.substr(0,ft.replace(/[?#].*/,"").lastIndexOf("/")+1),j&&(ve=p=>{var x=new XMLHttpRequest;return x.open("GET",p,!1),x.responseType="arraybuffer",x.send(null),new Uint8Array(x.response)}),ye=(p,x,D)=>{var H=new XMLHttpRequest;H.open("GET",p,!0),H.responseType="arraybuffer",H.onload=()=>{H.status==200||H.status==0&&H.response?x(H.response):D()},H.onerror=D,H.send(null)});var It,Bt=console.log.bind(console),cr=console.error.bind(console),fr=Bt,Xt=cr;if(Object.assign(d,Ce),Ce=null,Y){let p=function(x){try{var D=x.data,H=D.cmd;if(H==="load"){let re=[];self.onmessage=Ae=>re.push(Ae),self.startWorker=()=>{postMessage({cmd:"loaded"});for(let Ae of re)p(Ae);self.onmessage=p};for(let Ae of D.handlers)d[Ae]&&!d[Ae].proxy||(d[Ae]=(...nt)=>{postMessage({Mb:"callHandler",oc:Ae,args:nt})},Ae=="print"&&(fr=d[Ae]),Ae=="printErr"&&(Xt=d[Ae]));yr=D.wasmMemory,es(),Rr(D.wasmModule)}else if(H==="run"){Cf(D.pthread_ptr,0,0,1,0,0),vf(D.pthread_ptr),Em(),Xf(),on||(Hh(),on=!0);try{Pm(D.start_routine,D.arg)}catch(re){if(re!="unwind")throw re}}else H==="cancel"?Cp()&&tf(-1):D.target!=="setimmediate"&&(H==="checkMailbox"?on&&Kp():H&&(Xt(`worker: received unknown command ${H}`),Xt(D)))}catch(re){throw qh(),re}};var Rr,on=!1;Xt=function(...x){x=x.join(" "),console.error(x)},self.alert=function(...x){postMessage({Mb:"alert",text:x.join(" "),qc:Cp()})},d.instantiateWasm=(x,D)=>new Promise(H=>{Rr=re=>{re=new WebAssembly.Instance(re,Gf()),D(re),H()}}),self.onunhandledrejection=x=>{throw x.reason||x},self.onmessage=p}d.wasmBinary&&(It=d.wasmBinary);var yr,Vr,Wt,tr,Ir,et,xt,rr,jr,Fn,zn,td,Vp,no=!1;function es(){var p=yr.buffer;d.HEAP8=tr=new Int8Array(p),d.HEAP16=et=new Int16Array(p),d.HEAPU8=Ir=new Uint8Array(p),d.HEAPU16=xt=new Uint16Array(p),d.HEAP32=rr=new Int32Array(p),d.HEAPU32=jr=new Uint32Array(p),d.HEAPF32=Fn=new Float32Array(p),d.HEAPF64=Vp=new Float64Array(p),d.HEAP64=zn=new BigInt64Array(p),d.HEAPU64=td=new BigUint64Array(p)}if(!Y){if(!((yr=new WebAssembly.Memory({initial:256,maximum:65536,shared:!0})).buffer instanceof te))throw Xt("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),Error("bad memory");es()}var up=[],Hn=[],Es=[],xi=0,rd=null;function Wp(){if(--xi==0&&rd){var p=rd;rd=null,p()}}function bp(p){throw Xt(p="Aborted("+p+")"),no=!0,Wt=1,p=new WebAssembly.RuntimeError(p+". Build with -sASSERTIONS for more info."),y(p),p}var lf,Nf=p=>p.startsWith("data:application/octet-stream;base64,"),Uf=p=>p.startsWith("file://");function Vf(p){if(p==lf&&It)return new Uint8Array(It);if(ve)return ve(p);throw"both async and sync fetching of the wasm failed"}function Wf(p,x,D){return function(H){if(!It&&(B||j)){if(typeof fetch=="function"&&!Uf(H))return fetch(H,{credentials:"same-origin"}).then(re=>{if(!re.ok)throw`failed to load wasm binary file at '${H}'`;return re.arrayBuffer()}).catch(()=>Vf(H));if(ye)return new Promise((re,Ae)=>{ye(H,nt=>re(new Uint8Array(nt)),Ae)})}return Promise.resolve().then(()=>Vf(H))}(p).then(H=>WebAssembly.instantiate(H,x)).then(D,H=>{Xt(`failed to asynchronously prepare wasm: ${H}`),bp(H)})}function Gf(){return{a:{O:bm,Aa:Tm,b:Sm,aa:eh,B:nh,qa:sh,Y:ih,_:ah,ra:lh,oa:uh,ha:ch,na:dh,L:ph,Z:fh,W:hh,pa:mh,X:_h,wa:km,F:$m,Q:Im,P:Fm,E:Lm,u:Dm,q:zm,G:Bm,A:Gm,R:Km,ua:Hm,ka:qm,U:Qm,ba:Xm,H:Ym,ja:vf,ta:Jm,t:Zm,x:r_,o:n_,l:o_,c:yf,n:i_,j:u_,w:c_,p:d_,g:p_,s:f_,m:h_,e:m_,k:__,i:g_,h:y_,d:w_,ea:v_,fa:M_,ga:x_,ca:$h,da:Ih,T:T_,f:b_,D:E_,I:P_,M:C_,y:S_,sa:k_,V:$_,v:Fh,z:I_,N:A_,S:F_,za:O_,ya:L_,la:Dh,ma:zh,$:ff,C:Bh,K:Rh,ia:jh,J:Nh,a:yr,xa:pf,va:Wh,r:B_}}}var uf={868340:(p,x,D,H,re)=>{if(d===void 0||!d.Fb)return 1;if((p=ps(p>>>0)).startsWith("./")&&(p=p.substring(2)),!(p=d.Fb.get(p)))return 2;if(H>>>=0,(x>>>=0)+(D>>>=0)>p.byteLength)return 3;try{let Ae=p.subarray(x,x+D);switch(re){case 0:i().set(Ae,H>>>0);break;case 1:d.cc(H,Ae);break;default:return 4}return 0}catch{return 4}},869023:(p,x,D)=>{d.dc(p,i().subarray(x>>>0,x+D>>>0))},869086:()=>d.ac(),869127:p=>{d.Ob(p)},869163:()=>{d.Vb()},869194:()=>{d.Wb()},869223:()=>{d.$b()},869248:p=>d.Ub(p),869281:p=>d.Yb(p),869313:(p,x,D)=>{d.Nb(p,x,D,!0)},869352:(p,x,D)=>{d.Nb(p,x,D)},869385:()=>typeof wasmOffsetConverter<"u",869442:p=>{d.jb("Abs",p,void 0)},869493:p=>{d.jb("Neg",p,void 0)},869544:p=>{d.jb("Floor",p,void 0)},869597:p=>{d.jb("Ceil",p,void 0)},869649:p=>{d.jb("Reciprocal",p,void 0)},869707:p=>{d.jb("Sqrt",p,void 0)},869759:p=>{d.jb("Exp",p,void 0)},869810:p=>{d.jb("Erf",p,void 0)},869861:p=>{d.jb("Sigmoid",p,void 0)},869916:(p,x,D)=>{d.jb("HardSigmoid",p,{alpha:x,beta:D})},869995:p=>{d.jb("Log",p,void 0)},870046:p=>{d.jb("Sin",p,void 0)},870097:p=>{d.jb("Cos",p,void 0)},870148:p=>{d.jb("Tan",p,void 0)},870199:p=>{d.jb("Asin",p,void 0)},870251:p=>{d.jb("Acos",p,void 0)},870303:p=>{d.jb("Atan",p,void 0)},870355:p=>{d.jb("Sinh",p,void 0)},870407:p=>{d.jb("Cosh",p,void 0)},870459:p=>{d.jb("Asinh",p,void 0)},870512:p=>{d.jb("Acosh",p,void 0)},870565:p=>{d.jb("Atanh",p,void 0)},870618:p=>{d.jb("Tanh",p,void 0)},870670:p=>{d.jb("Not",p,void 0)},870721:(p,x,D)=>{d.jb("Clip",p,{min:x,max:D})},870790:p=>{d.jb("Clip",p,void 0)},870842:(p,x)=>{d.jb("Elu",p,{alpha:x})},870900:p=>{d.jb("Gelu",p,void 0)},870952:p=>{d.jb("Relu",p,void 0)},871004:(p,x)=>{d.jb("LeakyRelu",p,{alpha:x})},871068:(p,x)=>{d.jb("ThresholdedRelu",p,{alpha:x})},871138:(p,x)=>{d.jb("Cast",p,{to:x})},871196:p=>{d.jb("Add",p,void 0)},871247:p=>{d.jb("Sub",p,void 0)},871298:p=>{d.jb("Mul",p,void 0)},871349:p=>{d.jb("Div",p,void 0)},871400:p=>{d.jb("Pow",p,void 0)},871451:p=>{d.jb("Equal",p,void 0)},871504:p=>{d.jb("Greater",p,void 0)},871559:p=>{d.jb("GreaterOrEqual",p,void 0)},871621:p=>{d.jb("Less",p,void 0)},871673:p=>{d.jb("LessOrEqual",p,void 0)},871732:(p,x,D,H,re)=>{d.jb("ReduceMean",p,{keepDims:!!x,noopWithEmptyAxes:!!D,axes:H?Array.from(l().subarray(H>>>0,re>>>0)):[]})},871891:(p,x,D,H,re)=>{d.jb("ReduceMax",p,{keepDims:!!x,noopWithEmptyAxes:!!D,axes:H?Array.from(l().subarray(H>>>0,re>>>0)):[]})},872049:(p,x,D,H,re)=>{d.jb("ReduceMin",p,{keepDims:!!x,noopWithEmptyAxes:!!D,axes:H?Array.from(l().subarray(H>>>0,re>>>0)):[]})},872207:(p,x,D,H,re)=>{d.jb("ReduceProd",p,{keepDims:!!x,noopWithEmptyAxes:!!D,axes:H?Array.from(l().subarray(H>>>0,re>>>0)):[]})},872366:(p,x,D,H,re)=>{d.jb("ReduceSum",p,{keepDims:!!x,noopWithEmptyAxes:!!D,axes:H?Array.from(l().subarray(H>>>0,re>>>0)):[]})},872524:(p,x,D,H,re)=>{d.jb("ReduceL1",p,{keepDims:!!x,noopWithEmptyAxes:!!D,axes:H?Array.from(l().subarray(H>>>0,re>>>0)):[]})},872681:(p,x,D,H,re)=>{d.jb("ReduceL2",p,{keepDims:!!x,noopWithEmptyAxes:!!D,axes:H?Array.from(l().subarray(H>>>0,re>>>0)):[]})},872838:(p,x,D,H,re)=>{d.jb("ReduceLogSum",p,{keepDims:!!x,noopWithEmptyAxes:!!D,axes:H?Array.from(l().subarray(H>>>0,re>>>0)):[]})},872999:(p,x,D,H,re)=>{d.jb("ReduceSumSquare",p,{keepDims:!!x,noopWithEmptyAxes:!!D,axes:H?Array.from(l().subarray(H>>>0,re>>>0)):[]})},873163:(p,x,D,H,re)=>{d.jb("ReduceLogSumExp",p,{keepDims:!!x,noopWithEmptyAxes:!!D,axes:H?Array.from(l().subarray(H>>>0,re>>>0)):[]})},873327:p=>{d.jb("Where",p,void 0)},873380:(p,x,D)=>{d.jb("Transpose",p,{perm:x?Array.from(l().subarray(x>>>0,D>>>0)):[]})},873488:(p,x,D,H)=>{d.jb("DepthToSpace",p,{blocksize:x,mode:ps(D),format:H?"NHWC":"NCHW"})},873621:(p,x,D,H)=>{d.jb("DepthToSpace",p,{blocksize:x,mode:ps(D),format:H?"NHWC":"NCHW"})},873754:(p,x,D,H,re,Ae,nt,ht,Ct,Lt,er,Ar,Wr,Ye,Er)=>{d.jb("ConvTranspose",p,{format:Ct?"NHWC":"NCHW",autoPad:x,dilations:[D],group:H,kernelShape:[re],pads:[Ae,nt],strides:[ht],wIsConst:()=>!!s()[Lt>>>0],outputPadding:er?Array.from(l().subarray(er>>>0,Ar>>>0)):[],outputShape:Wr?Array.from(l().subarray(Wr>>>0,Ye>>>0)):[],activation:ps(Er)})},874155:(p,x,D,H,re,Ae,nt,ht,Ct,Lt,er,Ar,Wr,Ye)=>{d.jb("ConvTranspose",p,{format:ht?"NHWC":"NCHW",autoPad:x,dilations:Array.from(l().subarray(D>>>0,2+(D>>>0)>>>0)),group:H,kernelShape:Array.from(l().subarray(re>>>0,2+(re>>>0)>>>0)),pads:Array.from(l().subarray(Ae>>>0,4+(Ae>>>0)>>>0)),strides:Array.from(l().subarray(nt>>>0,2+(nt>>>0)>>>0)),wIsConst:()=>!!s()[Ct>>>0],outputPadding:Lt?Array.from(l().subarray(Lt>>>0,er>>>0)):[],outputShape:Ar?Array.from(l().subarray(Ar>>>0,Wr>>>0)):[],activation:ps(Ye)})},874720:(p,x,D,H,re,Ae,nt,ht,Ct,Lt,er,Ar,Wr,Ye,Er)=>{d.jb("ConvTranspose",p,{format:Ct?"NHWC":"NCHW",autoPad:x,dilations:[D],group:H,kernelShape:[re],pads:[Ae,nt],strides:[ht],wIsConst:()=>!!s()[Lt>>>0],outputPadding:er?Array.from(l().subarray(er>>>0,Ar>>>0)):[],outputShape:Wr?Array.from(l().subarray(Wr>>>0,Ye>>>0)):[],activation:ps(Er)})},875121:(p,x,D,H,re,Ae,nt,ht,Ct,Lt,er,Ar,Wr,Ye)=>{d.jb("ConvTranspose",p,{format:ht?"NHWC":"NCHW",autoPad:x,dilations:Array.from(l().subarray(D>>>0,2+(D>>>0)>>>0)),group:H,kernelShape:Array.from(l().subarray(re>>>0,2+(re>>>0)>>>0)),pads:Array.from(l().subarray(Ae>>>0,4+(Ae>>>0)>>>0)),strides:Array.from(l().subarray(nt>>>0,2+(nt>>>0)>>>0)),wIsConst:()=>!!s()[Ct>>>0],outputPadding:Lt?Array.from(l().subarray(Lt>>>0,er>>>0)):[],outputShape:Ar?Array.from(l().subarray(Ar>>>0,Wr>>>0)):[],activation:ps(Ye)})},875686:(p,x)=>{d.jb("GlobalAveragePool",p,{format:x?"NHWC":"NCHW"})},875777:(p,x,D,H,re,Ae,nt,ht,Ct,Lt,er,Ar,Wr,Ye)=>{d.jb("AveragePool",p,{format:Ye?"NHWC":"NCHW",auto_pad:x,ceil_mode:D,count_include_pad:H,storage_order:re,dilations:Ae?Array.from(l().subarray(Ae>>>0,nt>>>0)):[],kernel_shape:ht?Array.from(l().subarray(ht>>>0,Ct>>>0)):[],pads:Lt?Array.from(l().subarray(Lt>>>0,er>>>0)):[],strides:Ar?Array.from(l().subarray(Ar>>>0,Wr>>>0)):[]})},876192:(p,x)=>{d.jb("GlobalAveragePool",p,{format:x?"NHWC":"NCHW"})},876283:(p,x,D,H,re,Ae,nt,ht,Ct,Lt,er,Ar,Wr,Ye)=>{d.jb("AveragePool",p,{format:Ye?"NHWC":"NCHW",auto_pad:x,ceil_mode:D,count_include_pad:H,storage_order:re,dilations:Ae?Array.from(l().subarray(Ae>>>0,nt>>>0)):[],kernel_shape:ht?Array.from(l().subarray(ht>>>0,Ct>>>0)):[],pads:Lt?Array.from(l().subarray(Lt>>>0,er>>>0)):[],strides:Ar?Array.from(l().subarray(Ar>>>0,Wr>>>0)):[]})},876698:(p,x)=>{d.jb("GlobalMaxPool",p,{format:x?"NHWC":"NCHW"})},876785:(p,x,D,H,re,Ae,nt,ht,Ct,Lt,er,Ar,Wr,Ye)=>{d.jb("MaxPool",p,{format:Ye?"NHWC":"NCHW",auto_pad:x,ceil_mode:D,count_include_pad:H,storage_order:re,dilations:Ae?Array.from(l().subarray(Ae>>>0,nt>>>0)):[],kernel_shape:ht?Array.from(l().subarray(ht>>>0,Ct>>>0)):[],pads:Lt?Array.from(l().subarray(Lt>>>0,er>>>0)):[],strides:Ar?Array.from(l().subarray(Ar>>>0,Wr>>>0)):[]})},877196:(p,x)=>{d.jb("GlobalMaxPool",p,{format:x?"NHWC":"NCHW"})},877283:(p,x,D,H,re,Ae,nt,ht,Ct,Lt,er,Ar,Wr,Ye)=>{d.jb("MaxPool",p,{format:Ye?"NHWC":"NCHW",auto_pad:x,ceil_mode:D,count_include_pad:H,storage_order:re,dilations:Ae?Array.from(l().subarray(Ae>>>0,nt>>>0)):[],kernel_shape:ht?Array.from(l().subarray(ht>>>0,Ct>>>0)):[],pads:Lt?Array.from(l().subarray(Lt>>>0,er>>>0)):[],strides:Ar?Array.from(l().subarray(Ar>>>0,Wr>>>0)):[]})},877694:(p,x,D,H,re)=>{d.jb("Gemm",p,{alpha:x,beta:D,transA:H,transB:re})},877798:p=>{d.jb("MatMul",p,void 0)},877852:(p,x,D,H)=>{d.jb("ArgMax",p,{keepDims:!!x,selectLastIndex:!!D,axis:H})},877960:(p,x,D,H)=>{d.jb("ArgMin",p,{keepDims:!!x,selectLastIndex:!!D,axis:H})},878068:(p,x)=>{d.jb("Softmax",p,{axis:x})},878131:(p,x)=>{d.jb("Concat",p,{axis:x})},878191:(p,x,D,H,re)=>{d.jb("Split",p,{axis:x,numOutputs:D,splitSizes:H?Array.from(l().subarray(H>>>0,re>>>0)):[]})},878331:p=>{d.jb("Expand",p,void 0)},878385:(p,x)=>{d.jb("Gather",p,{axis:Number(x)})},878456:(p,x)=>{d.jb("GatherElements",p,{axis:Number(x)})},878535:(p,x,D,H,re,Ae,nt,ht,Ct,Lt,er)=>{d.jb("Resize",p,{antialias:x,axes:D?Array.from(l().subarray(D>>>0,H>>>0)):[],coordinateTransformMode:ps(re),cubicCoeffA:Ae,excludeOutside:nt,extrapolationValue:ht,keepAspectRatioPolicy:ps(Ct),mode:ps(Lt),nearestMode:ps(er)})},878881:(p,x,D,H,re,Ae,nt)=>{d.jb("Slice",p,{starts:x?Array.from(l().subarray(x>>>0,D>>>0)):[],ends:H?Array.from(l().subarray(H>>>0,re>>>0)):[],axes:Ae?Array.from(l().subarray(Ae>>>0,nt>>>0)):[]})},879097:p=>{d.jb("Tile",p,void 0)},879149:(p,x,D)=>{d.jb("InstanceNormalization",p,{epsilon:x,format:D?"NHWC":"NCHW"})},879263:(p,x,D)=>{d.jb("InstanceNormalization",p,{epsilon:x,format:D?"NHWC":"NCHW"})},879377:p=>{d.jb("Range",p,void 0)},879430:(p,x)=>{d.jb("Einsum",p,{equation:ps(x)})},879511:(p,x,D,H,re)=>{d.jb("Pad",p,{mode:x,value:D,pads:H?Array.from(l().subarray(H>>>0,re>>>0)):[]})},879638:(p,x,D,H,re,Ae)=>{d.jb("BatchNormalization",p,{epsilon:x,momentum:D,spatial:!!re,trainingMode:!!H,format:Ae?"NHWC":"NCHW"})},879807:(p,x,D,H,re,Ae)=>{d.jb("BatchNormalization",p,{epsilon:x,momentum:D,spatial:!!re,trainingMode:!!H,format:Ae?"NHWC":"NCHW"})},879976:(p,x,D)=>{d.jb("CumSum",p,{exclusive:Number(x),reverse:Number(D)})},880073:(p,x,D)=>{d.jb("DequantizeLinear",p,{axis:x,blockSize:D})},880163:(p,x,D,H,re,Ae,nt,ht,Ct)=>{d.jb("Attention",p,{numHeads:x,isUnidirectional:D,maskFilterValue:H,scale:re,doRotary:Ae,qkvHiddenSizes:nt?Array.from(l().subarray(Number(ht)>>>0,Number(ht)+nt>>>0)):[],pastPresentShareBuffer:!!Ct})},880435:p=>{d.jb("BiasAdd",p,void 0)},880490:p=>{d.jb("BiasSplitGelu",p,void 0)},880551:p=>{d.jb("FastGelu",p,void 0)},880607:(p,x,D,H,re,Ae,nt,ht,Ct,Lt,er,Ar,Wr,Ye,Er,En)=>{d.jb("Conv",p,{format:Ar?"NHWC":"NCHW",auto_pad:x,dilations:D?Array.from(l().subarray(D>>>0,H>>>0)):[],group:re,kernel_shape:Ae?Array.from(l().subarray(Ae>>>0,nt>>>0)):[],pads:ht?Array.from(l().subarray(ht>>>0,Ct>>>0)):[],strides:Lt?Array.from(l().subarray(Lt>>>0,er>>>0)):[],w_is_const:()=>!!s()[Wr>>>0],activation:ps(Ye),activation_params:Er?Array.from(_().subarray(Er>>>0,En>>>0)):[]})},881103:p=>{d.jb("Gelu",p,void 0)},881155:(p,x,D,H)=>{d.jb("GroupQueryAttention",p,{numHeads:x,kvNumHeads:D,scale:H})},881268:(p,x,D,H)=>{d.jb("LayerNormalization",p,{axis:x,epsilon:D,simplified:!!H})},881379:(p,x,D,H)=>{d.jb("LayerNormalization",p,{axis:x,epsilon:D,simplified:!!H})},881490:(p,x,D,H,re,Ae)=>{d.jb("MatMulNBits",p,{k:x,n:D,accuracyLevel:H,bits:re,blockSize:Ae})},881617:(p,x,D,H,re,Ae)=>{d.jb("MultiHeadAttention",p,{numHeads:x,isUnidirectional:D,maskFilterValue:H,scale:re,doRotary:Ae})},881776:(p,x)=>{d.jb("QuickGelu",p,{alpha:x})},881840:(p,x,D,H,re)=>{d.jb("RotaryEmbedding",p,{interleaved:!!x,numHeads:D,rotaryEmbeddingDim:H,scale:re})},881979:(p,x,D)=>{d.jb("SkipLayerNormalization",p,{epsilon:x,simplified:!!D})},882081:(p,x,D)=>{d.jb("SkipLayerNormalization",p,{epsilon:x,simplified:!!D})},882183:(p,x,D,H)=>{d.jb("GatherBlockQuantized",p,{gatherAxis:x,quantizeAxis:D,blockSize:H})},882304:p=>{d.Zb(p)},882338:(p,x)=>d.bc(p,x,d.Eb.fc,d.Eb.errors)};function Tm(p,x,D){return Eh(async()=>{await d.Xb(p,x,D)})}function bm(){return typeof wasmOffsetConverter<"u"}function cf(p){this.name="ExitStatus",this.message=`Program terminated with exit(${p})`,this.status=p}var df=p=>{p.terminate(),p.onmessage=()=>{}},Kf=p=>{nd.length==0&&(Jf(),Yf(nd[0]));var x=nd.pop();if(!x)return 6;dp.push(x),rl[p.Ab]=x,x.Ab=p.Ab;var D={cmd:"run",start_routine:p.hc,arg:p.Qb,pthread_ptr:p.Ab};return x.postMessage(D,p.mc),0},cp=0,vn=(p,x,...D)=>{for(var H=2*D.length,re=$f(),Ae=kf(8*H),nt=Ae>>>3,ht=0;ht<D.length;ht++){var Ct=D[ht];typeof Ct=="bigint"?(zn[nt+2*ht]=1n,zn[nt+2*ht+1]=Ct):(zn[nt+2*ht]=0n,w()[nt+2*ht+1>>>0]=Ct)}return p=Qh(p,0,H,Ae,x),rf(re),p};function pf(p){if(Y)return vn(0,1,p);if(Wt=p,!(0<cp)){for(var x of dp)df(x);for(x of nd)df(x);nd=[],dp=[],rl=[],no=!0}Ke(p,new cf(p))}function Hf(p){if(Y)return vn(1,0,p);ff(p)}var ff=p=>{if(Wt=p,Y)throw Hf(p),"unwind";pf(p)},nd=[],dp=[],qf=[],rl={},Qf=p=>{var x=p.Ab;delete rl[x],nd.push(p),dp.splice(dp.indexOf(p),1),p.Ab=0,Sf(x)};function Xf(){qf.forEach(p=>p())}var Yf=p=>new Promise(x=>{p.onmessage=re=>{var Ae=(re=re.data).cmd;if(re.targetThread&&re.targetThread!=Cp()){var nt=rl[re.targetThread];nt?nt.postMessage(re,re.transferList):Xt(`Internal error! Worker sent a message "${Ae}" to target pthread ${re.targetThread}, but that thread no longer exists!`)}else Ae==="checkMailbox"?Kp():Ae==="spawnThread"?Kf(re):Ae==="cleanupThread"?Qf(rl[re.thread]):Ae==="killThread"?(re=re.thread,Ae=rl[re],delete rl[re],df(Ae),Sf(re),dp.splice(dp.indexOf(Ae),1),Ae.Ab=0):Ae==="cancelThread"?rl[re.thread].postMessage({cmd:"cancel"}):Ae==="loaded"?(p.loaded=!0,x(p)):Ae==="alert"?alert(`Thread ${re.threadId}: ${re.text}`):re.target==="setimmediate"?p.postMessage(re):Ae==="callHandler"?d[re.handler](...re.args):Ae&&Xt(`worker sent an unknown command ${Ae}`)},p.onerror=re=>{throw Xt(`worker sent an error! ${re.filename}:${re.lineno}: ${re.message}`),re};var D,H=[];for(D of[])d.hasOwnProperty(D)&&H.push(D);p.postMessage({cmd:"load",handlers:H,wasmMemory:yr,wasmModule:Vr})});function Jf(){var p=new Worker(new URL(import.meta.url),{type:"module",workerData:"em-pthread",name:"em-pthread"});nd.push(p)}var Gp=p=>{for(;0<p.length;)p.shift()(d)},Em=()=>{var p=Cp(),x=h()[p+52>>>2>>>0];p=h()[p+56>>>2>>>0],Yh(x,x-p),rf(x)},Pm=(p,x)=>{cp=0,p=Jh(p,x),0<cp?Wt=p:tf(p)};class Cm{constructor(x){this.Jb=x-24}}function Sm(p,x,D){var H=new Cm(p>>>=0);throw x>>>=0,D>>>=0,h()[H.Jb+16>>>2>>>0]=0,h()[H.Jb+4>>>2>>>0]=x,h()[H.Jb+8>>>2>>>0]=D,p}function Zf(p,x,D,H){return Y?vn(2,1,p,x,D,H):eh(p,x,D,H)}function eh(p,x,D,H){if(p>>>=0,x>>>=0,D>>>=0,H>>>=0,te===void 0)return Xt("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var re=[];return Y&&re.length===0?Zf(p,x,D,H):(p={hc:D,Ab:p,Qb:H,mc:re},Y?(p.Mb="spawnThread",postMessage(p,re),0):Kf(p))}var th=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0,rh=(p,x,D)=>{var H=(x>>>=0)+D;for(D=x;p[D]&&!(D>=H);)++D;if(16<D-x&&p.buffer&&th)return th.decode(p.buffer instanceof te?p.slice(x,D):p.subarray(x,D));for(H="";x<D;){var re=p[x++];if(128&re){var Ae=63&p[x++];if((224&re)==192)H+=String.fromCharCode((31&re)<<6|Ae);else{var nt=63&p[x++];65536>(re=(240&re)==224?(15&re)<<12|Ae<<6|nt:(7&re)<<18|Ae<<12|nt<<6|63&p[x++])?H+=String.fromCharCode(re):(re-=65536,H+=String.fromCharCode(55296|re>>10,56320|1023&re))}}else H+=String.fromCharCode(re)}return H},ps=(p,x)=>(p>>>=0)?rh(i(),p,x):"";function nh(p,x,D){return Y?vn(3,1,p,x,D):0}function sh(p,x){if(Y)return vn(4,1,p,x)}var hf=p=>{for(var x=0,D=0;D<p.length;++D){var H=p.charCodeAt(D);127>=H?x++:2047>=H?x+=2:55296<=H&&57343>=H?(x+=4,++D):x+=3}return x},oh=(p,x,D,H)=>{if(!(0<H))return 0;var re=D>>>=0;H=D+H-1;for(var Ae=0;Ae<p.length;++Ae){var nt=p.charCodeAt(Ae);if(55296<=nt&&57343>=nt&&(nt=65536+((1023&nt)<<10)|1023&p.charCodeAt(++Ae)),127>=nt){if(D>=H)break;x[D++>>>0]=nt}else{if(2047>=nt){if(D+1>=H)break;x[D++>>>0]=192|nt>>6}else{if(65535>=nt){if(D+2>=H)break;x[D++>>>0]=224|nt>>12}else{if(D+3>=H)break;x[D++>>>0]=240|nt>>18,x[D++>>>0]=128|nt>>12&63}x[D++>>>0]=128|nt>>6&63}x[D++>>>0]=128|63&nt}}return x[D>>>0]=0,D-re},Ep=(p,x,D)=>oh(p,i(),x,D);function ih(p,x){if(Y)return vn(5,1,p,x)}function ah(p,x,D){if(Y)return vn(6,1,p,x,D)}function lh(p,x,D){return Y?vn(7,1,p,x,D):0}function uh(p,x){if(Y)return vn(8,1,p,x)}function ch(p,x,D){if(Y)return vn(9,1,p,x,D)}function dh(p,x,D,H){if(Y)return vn(10,1,p,x,D,H)}function ph(p,x,D,H){if(Y)return vn(11,1,p,x,D,H)}function fh(p,x,D,H){if(Y)return vn(12,1,p,x,D,H)}function hh(p){if(Y)return vn(13,1,p)}function mh(p,x){if(Y)return vn(14,1,p,x)}function _h(p,x,D){if(Y)return vn(15,1,p,x,D)}var gh,sd,km=()=>{bp("")},nl=p=>{for(var x="";i()[p>>>0];)x+=gh[i()[p++>>>0]];return x},mf={},_f={};function _u(p,x,D={}){if(!("argPackAdvance"in x))throw new TypeError("registerType registeredInstance requires argPackAdvance");return function(H,re,Ae={}){var nt=re.name;if(!H)throw new sd(`type "${nt}" must have a positive integer typeid pointer`);if(_f.hasOwnProperty(H)){if(Ae.Sb)return;throw new sd(`Cannot register type '${nt}' twice`)}_f[H]=re,mf.hasOwnProperty(H)&&(re=mf[H],delete mf[H],re.forEach(ht=>ht()))}(p,x,D)}var yh=(p,x,D)=>{switch(x){case 1:return D?H=>s()[H>>>0]:H=>i()[H>>>0];case 2:return D?H=>a()[H>>>1>>>0]:H=>c()[H>>>1>>>0];case 4:return D?H=>l()[H>>>2>>>0]:H=>h()[H>>>2>>>0];case 8:return D?H=>zn[H>>>3]:H=>td[H>>>3];default:throw new TypeError(`invalid integer width (${x}): ${p}`)}};function $m(p,x,D){D>>>=0,_u(p>>>=0,{name:x=nl(x>>>0),fromWireType:H=>H,toWireType:function(H,re){if(typeof re!="bigint"&&typeof re!="number")throw re=re===null?"null":(H=typeof re)=="object"||H==="array"||H==="function"?re.toString():""+re,new TypeError(`Cannot convert "${re}" to ${this.name}`);return typeof re=="number"&&(re=BigInt(re)),re},argPackAdvance:od,readValueFromPointer:yh(x,D,x.indexOf("u")==-1),Db:null})}var od=8;function Im(p,x,D,H){_u(p>>>=0,{name:x=nl(x>>>0),fromWireType:function(re){return!!re},toWireType:function(re,Ae){return Ae?D:H},argPackAdvance:od,readValueFromPointer:function(re){return this.fromWireType(i()[re>>>0])},Db:null})}var gf=[],gu=[];function yf(p){9<(p>>>=0)&&--gu[p+1]==0&&(gu[p]=void 0,gf.push(p))}var Ti=p=>{if(!p)throw new sd("Cannot use deleted val. handle = "+p);return gu[p]},bi=p=>{switch(p){case void 0:return 2;case null:return 4;case!0:return 6;case!1:return 8;default:let x=gf.pop()||gu.length;return gu[x]=p,gu[x+1]=1,x}};function wf(p){return this.fromWireType(h()[p>>>2>>>0])}var Am={name:"emscripten::val",fromWireType:p=>{var x=Ti(p);return yf(p),x},toWireType:(p,x)=>bi(x),argPackAdvance:od,readValueFromPointer:wf,Db:null};function Fm(p){return _u(p>>>0,Am)}var Om=(p,x)=>{switch(x){case 4:return function(D){return this.fromWireType(_()[D>>>2>>>0])};case 8:return function(D){return this.fromWireType(w()[D>>>3>>>0])};default:throw new TypeError(`invalid float width (${x}): ${p}`)}};function Lm(p,x,D){D>>>=0,_u(p>>>=0,{name:x=nl(x>>>0),fromWireType:H=>H,toWireType:(H,re)=>re,argPackAdvance:od,readValueFromPointer:Om(x,D),Db:null})}function Dm(p,x,D,H,re){if(p>>>=0,D>>>=0,x=nl(x>>>0),re===-1&&(re=4294967295),re=ht=>ht,H===0){var Ae=32-8*D;re=ht=>ht<<Ae>>>Ae}var nt=x.includes("unsigned")?function(ht,Ct){return Ct>>>0}:function(ht,Ct){return Ct};_u(p,{name:x,fromWireType:re,toWireType:nt,argPackAdvance:od,readValueFromPointer:yh(x,D,H!==0),Db:null})}function zm(p,x,D){function H(Ae){var nt=h()[Ae>>>2>>>0];return Ae=h()[Ae+4>>>2>>>0],new re(s().buffer,Ae,nt)}var re=[Int8Array,Uint8Array,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array,BigInt64Array,BigUint64Array][x];_u(p>>>=0,{name:D=nl(D>>>0),fromWireType:H,argPackAdvance:od,readValueFromPointer:H},{Sb:!0})}function Bm(p,x){p>>>=0;var D=(x=nl(x>>>0))==="std::string";_u(p,{name:x,fromWireType:function(H){var re=h()[H>>>2>>>0],Ae=H+4;if(D)for(var nt=Ae,ht=0;ht<=re;++ht){var Ct=Ae+ht;if(ht==re||i()[Ct>>>0]==0){if(nt=ps(nt,Ct-nt),Lt===void 0)var Lt=nt;else Lt+="\0",Lt+=nt;nt=Ct+1}}else{for(Lt=Array(re),ht=0;ht<re;++ht)Lt[ht]=String.fromCharCode(i()[Ae+ht>>>0]);Lt=Lt.join("")}return ol(H),Lt},toWireType:function(H,re){re instanceof ArrayBuffer&&(re=new Uint8Array(re));var Ae=typeof re=="string";if(!(Ae||re instanceof Uint8Array||re instanceof Uint8ClampedArray||re instanceof Int8Array))throw new sd("Cannot pass non-string to std::string");var nt=D&&Ae?hf(re):re.length,ht=ef(4+nt+1),Ct=ht+4;if(h()[ht>>>2>>>0]=nt,D&&Ae)Ep(re,Ct,nt+1);else if(Ae)for(Ae=0;Ae<nt;++Ae){var Lt=re.charCodeAt(Ae);if(255<Lt)throw ol(Ct),new sd("String has UTF-16 code units that do not fit in 8 bits");i()[Ct+Ae>>>0]=Lt}else for(Ae=0;Ae<nt;++Ae)i()[Ct+Ae>>>0]=re[Ae];return H!==null&&H.push(ol,ht),ht},argPackAdvance:od,readValueFromPointer:wf,Db(H){ol(H)}})}var wh=typeof TextDecoder<"u"?new TextDecoder("utf-16le"):void 0,Rm=(p,x)=>{for(var D=p>>1,H=D+x/2;!(D>=H)&&c()[D>>>0];)++D;if(32<(D<<=1)-p&&wh)return wh.decode(i().slice(p,D));for(D="",H=0;!(H>=x/2);++H){var re=a()[p+2*H>>>1>>>0];if(re==0)break;D+=String.fromCharCode(re)}return D},jm=(p,x,D)=>{if(D??(D=2147483647),2>D)return 0;var H=x;D=(D-=2)<2*p.length?D/2:p.length;for(var re=0;re<D;++re){var Ae=p.charCodeAt(re);a()[x>>>1>>>0]=Ae,x+=2}return a()[x>>>1>>>0]=0,x-H},Nm=p=>2*p.length,Um=(p,x)=>{for(var D=0,H="";!(D>=x/4);){var re=l()[p+4*D>>>2>>>0];if(re==0)break;++D,65536<=re?(re-=65536,H+=String.fromCharCode(55296|re>>10,56320|1023&re)):H+=String.fromCharCode(re)}return H},Vm=(p,x,D)=>{if(x>>>=0,D??(D=2147483647),4>D)return 0;var H=x;D=H+D-4;for(var re=0;re<p.length;++re){var Ae=p.charCodeAt(re);if(55296<=Ae&&57343>=Ae&&(Ae=65536+((1023&Ae)<<10)|1023&p.charCodeAt(++re)),l()[x>>>2>>>0]=Ae,(x+=4)+4>D)break}return l()[x>>>2>>>0]=0,x-H},Wm=p=>{for(var x=0,D=0;D<p.length;++D){var H=p.charCodeAt(D);55296<=H&&57343>=H&&++D,x+=4}return x};function Gm(p,x,D){if(p>>>=0,x>>>=0,D=nl(D>>>=0),x===2)var H=Rm,re=jm,Ae=Nm,nt=ht=>c()[ht>>>1>>>0];else x===4&&(H=Um,re=Vm,Ae=Wm,nt=ht=>h()[ht>>>2>>>0]);_u(p,{name:D,fromWireType:ht=>{for(var Ct,Lt=h()[ht>>>2>>>0],er=ht+4,Ar=0;Ar<=Lt;++Ar){var Wr=ht+4+Ar*x;Ar!=Lt&&nt(Wr)!=0||(er=H(er,Wr-er),Ct===void 0?Ct=er:(Ct+="\0",Ct+=er),er=Wr+x)}return ol(ht),Ct},toWireType:(ht,Ct)=>{if(typeof Ct!="string")throw new sd(`Cannot pass non-string to C++ string type ${D}`);var Lt=Ae(Ct),er=ef(4+Lt+x);return h()[er>>>2>>>0]=Lt/x,re(Ct,er+4,Lt+x),ht!==null&&ht.push(ol,er),er},argPackAdvance:od,readValueFromPointer:wf,Db(ht){ol(ht)}})}function Km(p,x){_u(p>>>=0,{Tb:!0,name:x=nl(x>>>0),argPackAdvance:0,fromWireType:()=>{},toWireType:()=>{}})}var Hm=()=>1;function qm(p){Cf(p>>>0,!j,1,!B,131072,!1),Xf()}var vh=p=>{if(!no)try{if(p(),!(0<cp))try{Y?tf(Wt):ff(Wt)}catch(x){x instanceof cf||x=="unwind"||Ke(1,x)}}catch(x){x instanceof cf||x=="unwind"||Ke(1,x)}};function vf(p){p>>>=0,typeof Atomics.nc=="function"&&(Atomics.nc(l(),p>>>2,p).value.then(Kp),p+=128,Atomics.store(l(),p>>>2,1))}var Kp=()=>{var p=Cp();p&&(vf(p),vh(Xh))};function Qm(p,x){(p>>>=0)==x>>>0?setTimeout(Kp):Y?postMessage({targetThread:p,cmd:"checkMailbox"}):(p=rl[p])&&p.postMessage({cmd:"checkMailbox"})}var Mf=[];function Xm(p,x,D,H,re){for(x>>>=0,H/=2,Mf.length=H,D=re>>>0>>>3,re=0;re<H;re++)Mf[re]=zn[D+2*re]?zn[D+2*re+1]:w()[D+2*re+1>>>0];return(x?uf[x]:R_[p])(...Mf)}function Ym(p){p>>>=0,Y?postMessage({cmd:"cleanupThread",thread:p}):Qf(rl[p])}function Jm(p){}var xf=(p,x)=>{var D=_f[p];if(D===void 0)throw p=Kh(p),D=nl(p),ol(p),new sd(`${x} has unknown type ${D}`);return D},Mh=(p,x,D)=>{var H=[];return p=p.toWireType(H,D),H.length&&(h()[x>>>2>>>0]=bi(H)),p};function Zm(p,x,D){return x>>>=0,D>>>=0,p=Ti(p>>>0),x=xf(x,"emval::as"),Mh(x,D,p)}var Hp=p=>{try{p()}catch(x){bp(x)}},id=0,sl=null,xh=0,qp=[],Th={},bh={},e_=0,Tf=null,t_=[];function Eh(p){return function(x){if(!no){if(id===0){var D=!1,H=!1;x((re=0)=>{if(!no&&(xh=re,D=!0,H)){id=2,Hp(()=>tm(sl)),typeof Browser<"u"&&Browser.Kb.Rb&&Browser.Kb.resume(),re=!1;try{var Ae=function(){var Ct=l()[sl+8>>>2>>>0];return Ct=Yt[bh[Ct]],--cp,Ct()}()}catch(Ct){Ae=Ct,re=!0}var nt=!1;if(!sl){var ht=Tf;ht&&(Tf=null,(re?ht.reject:ht.resolve)(Ae),nt=!0)}if(re&&!nt)throw Ae}}),H=!0,D||(id=1,sl=function(){var re=ef(65548),Ae=re+12;h()[re>>>2>>>0]=Ae,h()[re+4>>>2>>>0]=Ae+65536,Ae=qp[0];var nt=Th[Ae];return nt===void 0&&(nt=e_++,Th[Ae]=nt,bh[nt]=Ae),Ae=nt,l()[re+8>>>2>>>0]=Ae,re}(),typeof Browser<"u"&&Browser.Kb.Rb&&Browser.Kb.pause(),Hp(()=>Zh(sl)))}else id===2?(id=0,Hp(rm),ol(sl),sl=null,t_.forEach(vh)):bp(`invalid state: ${id}`);return xh}}(x=>{p().then(x)})}function r_(p){return p>>>=0,Eh(()=>(p=Ti(p)).then(bi))}var Qp=[];function n_(p,x,D,H){return D>>>=0,H>>>=0,(p=Qp[p>>>0])(null,x=Ti(x>>>0),D,H)}var s_={},Xp=p=>{var x=s_[p];return x===void 0?nl(p):x};function o_(p,x,D,H,re){return D>>>=0,H>>>=0,re>>>=0,(p=Qp[p>>>0])(x=Ti(x>>>0),x[D=Xp(D)],H,re)}var Ph=()=>typeof globalThis=="object"?globalThis:Function("return this")();function i_(p){return(p>>>=0)==0?bi(Ph()):(p=Xp(p),bi(Ph()[p]))}var a_=p=>{var x=Qp.length;return Qp.push(p),x},l_=(p,x)=>{for(var D=Array(p),H=0;H<p;++H)D[H]=xf(h()[x+4*H>>>2>>>0],"parameter "+H);return D},Ch=(p,x)=>Object.defineProperty(x,"name",{value:p});function u_(p,x,D){var H=(x=l_(p,x>>>0)).shift();p--;var re=`return function (obj, func, destructorsRef, args) {
`,Ae=0,nt=[];D===0&&nt.push("obj");for(var ht=["retType"],Ct=[H],Lt=0;Lt<p;++Lt)nt.push("arg"+Lt),ht.push("argType"+Lt),Ct.push(x[Lt]),re+=`  var arg${Lt} = argType${Lt}.readValueFromPointer(args${Ae?"+"+Ae:""});
`,Ae+=x[Lt].argPackAdvance;return re+=`  var rv = ${D===1?"new func":"func.call"}(${nt.join(", ")});
`,H.Tb||(ht.push("emval_returnValue"),Ct.push(Mh),re+=`  return emval_returnValue(retType, destructorsRef, rv);
`),ht.push(re+`};
`),p=function(er){var Ar=Function;if(!(Ar instanceof Function))throw new TypeError(`new_ called with constructor type ${typeof Ar} which is not a function`);var Wr=Ch(Ar.name||"unknownFunctionName",function(){});return Wr.prototype=Ar.prototype,Wr=new Wr,(er=Ar.apply(Wr,er))instanceof Object?er:Wr}(ht)(...Ct),D=`methodCaller<(${x.map(er=>er.name).join(", ")}) => ${H.name}>`,a_(Ch(D,p))}function c_(p){return p=Xp(p>>>0),bi(d[p])}function d_(p,x){return x>>>=0,p=Ti(p>>>0),x=Ti(x),bi(p[x])}function p_(p){9<(p>>>=0)&&(gu[p+1]+=1)}function f_(){return bi([])}function h_(p){p=Ti(p>>>0);for(var x=Array(p.length),D=0;D<p.length;D++)x[D]=p[D];return bi(x)}function m_(p){return bi(Xp(p>>>0))}function __(){return bi({})}function g_(p){for(var x=Ti(p>>>=0);x.length;){var D=x.pop();x.pop()(D)}yf(p)}function y_(p,x,D){x>>>=0,D>>>=0,p=Ti(p>>>0),x=Ti(x),D=Ti(D),p[x]=D}function w_(p,x){return x>>>=0,p=(p=xf(p>>>0,"_emval_take_value")).readValueFromPointer(x),bi(p)}function v_(p,x){p=-9007199254740992>p||9007199254740992<p?NaN:Number(p),x>>>=0,p=new Date(1e3*p),l()[x>>>2>>>0]=p.getUTCSeconds(),l()[x+4>>>2>>>0]=p.getUTCMinutes(),l()[x+8>>>2>>>0]=p.getUTCHours(),l()[x+12>>>2>>>0]=p.getUTCDate(),l()[x+16>>>2>>>0]=p.getUTCMonth(),l()[x+20>>>2>>>0]=p.getUTCFullYear()-1900,l()[x+24>>>2>>>0]=p.getUTCDay(),p=(p.getTime()-Date.UTC(p.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,l()[x+28>>>2>>>0]=p}var Pp=p=>p%4==0&&(p%100!=0||p%400==0),Sh=[0,31,60,91,121,152,182,213,244,274,305,335],kh=[0,31,59,90,120,151,181,212,243,273,304,334];function M_(p,x){p=-9007199254740992>p||9007199254740992<p?NaN:Number(p),x>>>=0,p=new Date(1e3*p),l()[x>>>2>>>0]=p.getSeconds(),l()[x+4>>>2>>>0]=p.getMinutes(),l()[x+8>>>2>>>0]=p.getHours(),l()[x+12>>>2>>>0]=p.getDate(),l()[x+16>>>2>>>0]=p.getMonth(),l()[x+20>>>2>>>0]=p.getFullYear()-1900,l()[x+24>>>2>>>0]=p.getDay();var D=(Pp(p.getFullYear())?Sh:kh)[p.getMonth()]+p.getDate()-1|0;l()[x+28>>>2>>>0]=D,l()[x+36>>>2>>>0]=-60*p.getTimezoneOffset(),D=new Date(p.getFullYear(),6,1).getTimezoneOffset();var H=new Date(p.getFullYear(),0,1).getTimezoneOffset();p=0|(D!=H&&p.getTimezoneOffset()==Math.min(H,D)),l()[x+32>>>2>>>0]=p}function x_(p){p>>>=0;var x=new Date(l()[p+20>>>2>>>0]+1900,l()[p+16>>>2>>>0],l()[p+12>>>2>>>0],l()[p+8>>>2>>>0],l()[p+4>>>2>>>0],l()[p>>>2>>>0],0),D=l()[p+32>>>2>>>0],H=x.getTimezoneOffset(),re=new Date(x.getFullYear(),6,1).getTimezoneOffset(),Ae=new Date(x.getFullYear(),0,1).getTimezoneOffset(),nt=Math.min(Ae,re);return 0>D?l()[p+32>>>2>>>0]=+(re!=Ae&&nt==H):0<D!=(nt==H)&&(re=Math.max(Ae,re),x.setTime(x.getTime()+6e4*((0<D?nt:re)-H))),l()[p+24>>>2>>>0]=x.getDay(),D=(Pp(x.getFullYear())?Sh:kh)[x.getMonth()]+x.getDate()-1|0,l()[p+28>>>2>>>0]=D,l()[p>>>2>>>0]=x.getSeconds(),l()[p+4>>>2>>>0]=x.getMinutes(),l()[p+8>>>2>>>0]=x.getHours(),l()[p+12>>>2>>>0]=x.getDate(),l()[p+16>>>2>>>0]=x.getMonth(),l()[p+20>>>2>>>0]=x.getYear(),p=x.getTime(),BigInt(isNaN(p)?-1:p/1e3)}function $h(p,x,D,H,re,Ae,nt){return Y?vn(16,1,p,x,D,H,re,Ae,nt):-52}function Ih(p,x,D,H,re,Ae){if(Y)return vn(17,1,p,x,D,H,re,Ae)}function T_(p,x,D,H){p>>>=0,x>>>=0,D>>>=0,H>>>=0;var re=new Date().getFullYear(),Ae=new Date(re,0,1),nt=new Date(re,6,1);re=Ae.getTimezoneOffset();var ht=nt.getTimezoneOffset(),Ct=Math.max(re,ht);h()[p>>>2>>>0]=60*Ct,l()[x>>>2>>>0]=+(re!=ht),Ae=(p=Lt=>Lt.toLocaleTimeString(void 0,{hour12:!1,timeZoneName:"short"}).split(" ")[1])(Ae),nt=p(nt),ht<re?(Ep(Ae,D,17),Ep(nt,H,17)):(Ep(Ae,H,17),Ep(nt,D,17))}var bf=[],Ah=(p,x)=>{bf.length=0;for(var D;D=i()[p++>>>0];){var H=D!=105;x+=(H&=D!=112)&&x%8?4:0,bf.push(D==112?h()[x>>>2>>>0]:D==106?zn[x>>>3]:D==105?l()[x>>>2>>>0]:w()[x>>>3>>>0]),x+=H?8:4}return bf};function b_(p,x,D){return p>>>=0,x=Ah(x>>>0,D>>>0),uf[p](...x)}function E_(p,x,D){return p>>>=0,x=Ah(x>>>0,D>>>0),uf[p](...x)}var P_=()=>{},C_=()=>Date.now();function S_(p,x){return Xt(ps(p>>>0,x>>>0))}var Fh,k_=()=>{throw cp+=1,"unwind"};function $_(){return 4294901760}Fh=()=>performance.timeOrigin+performance.now();var I_=()=>navigator.hardwareConcurrency;function A_(){return bp("Cannot use emscripten_pc_get_function without -sUSE_OFFSET_CONVERTER"),0}function F_(p){p>>>=0;var x=i().length;if(p<=x||4294901760<p)return!1;for(var D=1;4>=D;D*=2){var H=x*(1+.2/D);H=Math.min(H,p+100663296);var re=Math;H=Math.max(p,H);e:{re=(re.min.call(re,4294901760,H+(65536-H%65536)%65536)-yr.buffer.byteLength+65535)/65536;try{yr.grow(re),es();var Ae=1;break e}catch{}Ae=void 0}if(Ae)return!0}return!1}var Yp=()=>(bp("Cannot use convertFrameToPC (needed by __builtin_return_address) without -sUSE_OFFSET_CONVERTER"),0),Lp={},Oh=p=>{p.forEach(x=>{Yp()})};function O_(){var p=Error().stack.toString().split(`
`);return p[0]=="Error"&&p.shift(),Oh(p),Lp.Pb=Yp(),Lp.ec=p,Lp.Pb}function L_(p,x,D){if(p>>>=0,x>>>=0,Lp.Pb==p)var H=Lp.ec;else(H=Error().stack.toString().split(`
`))[0]=="Error"&&H.shift(),Oh(H);for(var re=3;H[re]&&Yp()!=p;)++re;for(p=0;p<D&&H[p+re];++p)l()[x+4*p>>>2>>>0]=Yp();return p}var Ef,Pf={},Lh=()=>{if(!Ef){var p,x={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:Ze};for(p in Pf)Pf[p]===void 0?delete x[p]:x[p]=Pf[p];var D=[];for(p in x)D.push(`${p}=${x[p]}`);Ef=D}return Ef};function Dh(p,x){if(Y)return vn(18,1,p,x);p>>>=0,x>>>=0;var D=0;return Lh().forEach((H,re)=>{var Ae=x+D;for(re=h()[p+4*re>>>2>>>0]=Ae,Ae=0;Ae<H.length;++Ae)s()[re++>>>0]=H.charCodeAt(Ae);s()[re>>>0]=0,D+=H.length+1}),0}function zh(p,x){if(Y)return vn(19,1,p,x);p>>>=0,x>>>=0;var D=Lh();h()[p>>>2>>>0]=D.length;var H=0;return D.forEach(re=>H+=re.length+1),h()[x>>>2>>>0]=H,0}function Bh(p){return Y?vn(20,1,p):52}function Rh(p,x,D,H){return Y?vn(21,1,p,x,D,H):52}function jh(p,x,D,H){return Y?vn(22,1,p,x,D,H):70}var D_=[null,[],[]];function Nh(p,x,D,H){if(Y)return vn(23,1,p,x,D,H);x>>>=0,D>>>=0,H>>>=0;for(var re=0,Ae=0;Ae<D;Ae++){var nt=h()[x>>>2>>>0],ht=h()[x+4>>>2>>>0];x+=8;for(var Ct=0;Ct<ht;Ct++){var Lt=i()[nt+Ct>>>0],er=D_[p];Lt===0||Lt===10?((p===1?fr:Xt)(rh(er,0)),er.length=0):er.push(Lt)}re+=ht}return h()[H>>>2>>>0]=re,0}var Uh=[31,29,31,30,31,30,31,31,30,31,30,31],Vh=[31,28,31,30,31,30,31,31,30,31,30,31],z_=(p,x)=>{s().set(p,x>>>0)};function Wh(p,x,D,H){function re(Ye,Er,En){for(Ye=typeof Ye=="number"?Ye.toString():Ye||"";Ye.length<Er;)Ye=En[0]+Ye;return Ye}function Ae(Ye,Er){return re(Ye,Er,"0")}function nt(Ye,Er){function En(sm){return 0>sm?-1:0<sm?1:0}var pp;return(pp=En(Ye.getFullYear()-Er.getFullYear()))===0&&(pp=En(Ye.getMonth()-Er.getMonth()))===0&&(pp=En(Ye.getDate()-Er.getDate())),pp}function ht(Ye){switch(Ye.getDay()){case 0:return new Date(Ye.getFullYear()-1,11,29);case 1:return Ye;case 2:return new Date(Ye.getFullYear(),0,3);case 3:return new Date(Ye.getFullYear(),0,2);case 4:return new Date(Ye.getFullYear(),0,1);case 5:return new Date(Ye.getFullYear()-1,11,31);case 6:return new Date(Ye.getFullYear()-1,11,30)}}function Ct(Ye){var Er=Ye.Bb;for(Ye=new Date(new Date(Ye.Cb+1900,0,1).getTime());0<Er;){var En=Ye.getMonth(),pp=(Pp(Ye.getFullYear())?Uh:Vh)[En];if(!(Er>pp-Ye.getDate())){Ye.setDate(Ye.getDate()+Er);break}Er-=pp-Ye.getDate()+1,Ye.setDate(1),11>En?Ye.setMonth(En+1):(Ye.setMonth(0),Ye.setFullYear(Ye.getFullYear()+1))}return En=new Date(Ye.getFullYear()+1,0,4),Er=ht(new Date(Ye.getFullYear(),0,4)),En=ht(En),0>=nt(Er,Ye)?0>=nt(En,Ye)?Ye.getFullYear()+1:Ye.getFullYear():Ye.getFullYear()-1}p>>>=0,x>>>=0,D>>>=0,H>>>=0;var Lt=h()[H+40>>>2>>>0];for(var er in H={kc:l()[H>>>2>>>0],jc:l()[H+4>>>2>>>0],Hb:l()[H+8>>>2>>>0],Lb:l()[H+12>>>2>>>0],Ib:l()[H+16>>>2>>>0],Cb:l()[H+20>>>2>>>0],ub:l()[H+24>>>2>>>0],Bb:l()[H+28>>>2>>>0],rc:l()[H+32>>>2>>>0],ic:l()[H+36>>>2>>>0],lc:Lt?ps(Lt):""},D=ps(D),Lt={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"})D=D.replace(new RegExp(er,"g"),Lt[er]);var Ar="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),Wr="January February March April May June July August September October November December".split(" ");for(er in Lt={"%a":Ye=>Ar[Ye.ub].substring(0,3),"%A":Ye=>Ar[Ye.ub],"%b":Ye=>Wr[Ye.Ib].substring(0,3),"%B":Ye=>Wr[Ye.Ib],"%C":Ye=>Ae((Ye.Cb+1900)/100|0,2),"%d":Ye=>Ae(Ye.Lb,2),"%e":Ye=>re(Ye.Lb,2," "),"%g":Ye=>Ct(Ye).toString().substring(2),"%G":Ct,"%H":Ye=>Ae(Ye.Hb,2),"%I":Ye=>((Ye=Ye.Hb)==0?Ye=12:12<Ye&&(Ye-=12),Ae(Ye,2)),"%j":Ye=>{for(var Er=0,En=0;En<=Ye.Ib-1;Er+=(Pp(Ye.Cb+1900)?Uh:Vh)[En++]);return Ae(Ye.Lb+Er,3)},"%m":Ye=>Ae(Ye.Ib+1,2),"%M":Ye=>Ae(Ye.jc,2),"%n":()=>`
`,"%p":Ye=>0<=Ye.Hb&&12>Ye.Hb?"AM":"PM","%S":Ye=>Ae(Ye.kc,2),"%t":()=>"	","%u":Ye=>Ye.ub||7,"%U":Ye=>Ae(Math.floor((Ye.Bb+7-Ye.ub)/7),2),"%V":Ye=>{var Er=Math.floor((Ye.Bb+7-(Ye.ub+6)%7)/7);if(2>=(Ye.ub+371-Ye.Bb-2)%7&&Er++,Er)Er==53&&((En=(Ye.ub+371-Ye.Bb)%7)==4||En==3&&Pp(Ye.Cb)||(Er=1));else{Er=52;var En=(Ye.ub+7-Ye.Bb-1)%7;(En==4||En==5&&Pp(Ye.Cb%400-1))&&Er++}return Ae(Er,2)},"%w":Ye=>Ye.ub,"%W":Ye=>Ae(Math.floor((Ye.Bb+7-(Ye.ub+6)%7)/7),2),"%y":Ye=>(Ye.Cb+1900).toString().substring(2),"%Y":Ye=>Ye.Cb+1900,"%z":Ye=>{var Er=0<=(Ye=Ye.ic);return Ye=Math.abs(Ye)/60,(Er?"+":"-")+("0000"+(Ye/60*100+Ye%60)).slice(-4)},"%Z":Ye=>Ye.lc,"%%":()=>"%"},D=D.replace(/%%/g,"\0\0"),Lt)D.includes(er)&&(D=D.replace(new RegExp(er,"g"),Lt[er](H)));return er=function(Ye){var Er=Array(hf(Ye)+1);return oh(Ye,Er,0,Er.length),Er}(D=D.replace(/\0\0/g,"%")),er.length>x?0:(z_(er,p),er.length-1)}function B_(p,x,D,H){return Wh(p>>>0,x>>>0,D>>>0,H>>>0)}Y||function(){for(var p=d.numThreads-1;p--;)Jf();up.unshift(()=>{xi++,function(x){Y?x():Promise.all(nd.map(Yf)).then(x)}(()=>Wp())})}();for(var Gh=Array(256),Jp=0;256>Jp;++Jp)Gh[Jp]=String.fromCharCode(Jp);gh=Gh,sd=d.BindingError=class extends Error{constructor(p){super(p),this.name="BindingError"}},d.InternalError=class extends Error{constructor(p){super(p),this.name="InternalError"}},gu.push(0,1,void 0,1,null,1,!0,1,!1,1),d.count_emval_handles=()=>gu.length/2-5-gf.length;var R_=[pf,Hf,Zf,nh,sh,ih,ah,lh,uh,ch,dh,ph,fh,hh,mh,_h,$h,Ih,Dh,zh,Bh,Rh,jh,Nh],Yt=function(){function p(D,H){return Yt=D.exports,Yt=function(){var re=Yt,Ae={};for(let[nt,ht]of Object.entries(re))Ae[nt]=typeof ht=="function"?(...Ct)=>{qp.push(nt);try{return ht(...Ct)}finally{no||(qp.pop(),sl&&id===1&&qp.length===0&&(id=0,cp+=1,Hp(em),typeof Fibers<"u"&&Fibers.sc()))}}:ht;return Ae}(),Yt=function(){var re=Yt,Ae=ht=>Ct=>ht(Ct)>>>0,nt=ht=>()=>ht()>>>0;return(re=Object.assign({},re)).Ca=Ae(re.Ca),re.fb=nt(re.fb),re.gb=Ae(re.gb),re.emscripten_main_runtime_thread_id=nt(re.emscripten_main_runtime_thread_id),re.sb=Ae(re.sb),re.tb=nt(re.tb),re}(),qf.push(Yt.ib),Hn.unshift(Yt.Ba),Vr=H,Wp(),Yt}var x=Gf();if(xi++,d.instantiateWasm)try{return d.instantiateWasm(x,p)}catch(D){Xt(`Module.instantiateWasm callback failed with error: ${D}`),y(D)}return lf||(lf=d.locateFile?Nf("ort-wasm-simd-threaded.jsep.wasm")?"ort-wasm-simd-threaded.jsep.wasm":d.locateFile?d.locateFile("ort-wasm-simd-threaded.jsep.wasm",ft):ft+"ort-wasm-simd-threaded.jsep.wasm":new URL(f("./node_modules/onnxruntime-web/dist/ort-wasm-simd-threaded.jsep.wasm"),f.b).href),function(D,H){var re=lf;return It||typeof WebAssembly.instantiateStreaming!="function"||Nf(re)||Uf(re)||typeof fetch!="function"?Wf(re,D,H):fetch(re,{credentials:"same-origin"}).then(Ae=>WebAssembly.instantiateStreaming(Ae,D).then(H,function(nt){return Xt(`wasm streaming compile failed: ${nt}`),Xt("falling back to ArrayBuffer instantiation"),Wf(re,D,H)}))}(x,function(D){p(D.instance,D.module)}).catch(y),{}}(),Kh=p=>(Kh=Yt.Ca)(p),Hh=()=>(Hh=Yt.Da)();d._OrtInit=(p,x)=>(d._OrtInit=Yt.Ea)(p,x),d._OrtGetLastError=(p,x)=>(d._OrtGetLastError=Yt.Fa)(p,x),d._OrtCreateSessionOptions=(p,x,D,H,re,Ae,nt,ht,Ct,Lt)=>(d._OrtCreateSessionOptions=Yt.Ga)(p,x,D,H,re,Ae,nt,ht,Ct,Lt),d._OrtAppendExecutionProvider=(p,x)=>(d._OrtAppendExecutionProvider=Yt.Ha)(p,x),d._OrtAddFreeDimensionOverride=(p,x,D)=>(d._OrtAddFreeDimensionOverride=Yt.Ia)(p,x,D),d._OrtAddSessionConfigEntry=(p,x,D)=>(d._OrtAddSessionConfigEntry=Yt.Ja)(p,x,D),d._OrtReleaseSessionOptions=p=>(d._OrtReleaseSessionOptions=Yt.Ka)(p),d._OrtCreateSession=(p,x,D)=>(d._OrtCreateSession=Yt.La)(p,x,D),d._OrtReleaseSession=p=>(d._OrtReleaseSession=Yt.Ma)(p),d._OrtGetInputOutputCount=(p,x,D)=>(d._OrtGetInputOutputCount=Yt.Na)(p,x,D),d._OrtGetInputName=(p,x)=>(d._OrtGetInputName=Yt.Oa)(p,x),d._OrtGetOutputName=(p,x)=>(d._OrtGetOutputName=Yt.Pa)(p,x),d._OrtFree=p=>(d._OrtFree=Yt.Qa)(p),d._OrtCreateTensor=(p,x,D,H,re,Ae)=>(d._OrtCreateTensor=Yt.Ra)(p,x,D,H,re,Ae),d._OrtGetTensorData=(p,x,D,H,re)=>(d._OrtGetTensorData=Yt.Sa)(p,x,D,H,re),d._OrtReleaseTensor=p=>(d._OrtReleaseTensor=Yt.Ta)(p),d._OrtCreateRunOptions=(p,x,D,H)=>(d._OrtCreateRunOptions=Yt.Ua)(p,x,D,H),d._OrtAddRunConfigEntry=(p,x,D)=>(d._OrtAddRunConfigEntry=Yt.Va)(p,x,D),d._OrtReleaseRunOptions=p=>(d._OrtReleaseRunOptions=Yt.Wa)(p),d._OrtCreateBinding=p=>(d._OrtCreateBinding=Yt.Xa)(p),d._OrtBindInput=(p,x,D)=>(d._OrtBindInput=Yt.Ya)(p,x,D),d._OrtBindOutput=(p,x,D,H)=>(d._OrtBindOutput=Yt.Za)(p,x,D,H),d._OrtClearBoundOutputs=p=>(d._OrtClearBoundOutputs=Yt._a)(p),d._OrtReleaseBinding=p=>(d._OrtReleaseBinding=Yt.$a)(p),d._OrtRunWithBinding=(p,x,D,H,re)=>(d._OrtRunWithBinding=Yt.ab)(p,x,D,H,re),d._OrtRun=(p,x,D,H,re,Ae,nt,ht)=>(d._OrtRun=Yt.bb)(p,x,D,H,re,Ae,nt,ht),d._OrtEndProfiling=p=>(d._OrtEndProfiling=Yt.cb)(p),d._JsepOutput=(p,x,D)=>(d._JsepOutput=Yt.db)(p,x,D),d._JsepGetNodeName=p=>(d._JsepGetNodeName=Yt.eb)(p);var Zp,Cp=()=>(Cp=Yt.fb)(),ef=d._malloc=p=>(ef=d._malloc=Yt.gb)(p),ol=d._free=p=>(ol=d._free=Yt.hb)(p),Cf=(p,x,D,H,re,Ae)=>(Cf=Yt.kb)(p,x,D,H,re,Ae),qh=()=>(qh=Yt.lb)(),Qh=(p,x,D,H,re)=>(Qh=Yt.mb)(p,x,D,H,re),Sf=p=>(Sf=Yt.nb)(p),tf=p=>(tf=Yt.ob)(p),Xh=()=>(Xh=Yt.pb)(),Yh=(p,x)=>(Yh=Yt.qb)(p,x),rf=p=>(rf=Yt.rb)(p),kf=p=>(kf=Yt.sb)(p),$f=()=>($f=Yt.tb)(),Jh=d.dynCall_ii=(p,x)=>(Jh=d.dynCall_ii=Yt.vb)(p,x),Zh=p=>(Zh=Yt.wb)(p),em=()=>(em=Yt.xb)(),tm=p=>(tm=Yt.yb)(p),rm=()=>(rm=Yt.zb)();function nm(){0<xi||(Y?(v(d),Y||Gp(Hn),startWorker(d)):(Gp(up),0<xi||Zp||(Zp=!0,d.calledRun=!0,no||(Y||Gp(Hn),v(d),Y||Gp(Es)))))}return d.___start_em_js=882450,d.___stop_em_js=882672,d.stackSave=()=>$f(),d.stackRestore=p=>rf(p),d.stackAlloc=p=>kf(p),d.UTF8ToString=ps,d.stringToUTF8=Ep,d.lengthBytesUTF8=hf,rd=function p(){Zp||nm(),Zp||(rd=p)},nm(),S}),Bn=Ps,((e=globalThis.self)==null?void 0:e.name)==="em-pthread"&&Ps()}),fs,Vs,so,Io,ts,oo,io,hs,Cs=E(()=>{var e,r;Ft(),fs=import.meta.url??(typeof document<"u"?(e=document.currentScript)==null?void 0:e.src:typeof self<"u"?(r=self.location)==null?void 0:r.href:void 0),Vs=typeof location>"u"?void 0:location.origin,so=(s,i)=>{try{let a=i??fs;return(a?new URL(s,a):new URL(s)).origin===Vs}catch{return!1}},Io=async s=>{let i=await(await fetch(s,{credentials:"same-origin"})).blob();return URL.createObjectURL(i)},ts=(Pn(),A(gr)).default,oo=async()=>{if(!fs)throw new Error("Failed to load proxy worker: cannot determine the script source URL.");if(so(fs))return[void 0,ts()];let s=await Io(fs);return[s,ts(s)]},io=(Gt(),A(Ns)).default,hs=async(s,i,a)=>[void 0,io]}),Cn,dt,Pt,jt,ln,Ws,ao,Dr,rs=E(()=>{Cs(),dt=!1,Pt=!1,jt=!1,ln=()=>{if(typeof SharedArrayBuffer>"u")return!1;try{return typeof MessageChannel<"u"&&new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11]))}catch{return!1}},Ws=()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch{return!1}},ao=async e=>{if(dt)return Promise.resolve();if(Pt)throw new Error("multiple calls to 'initializeWebAssembly()' detected.");if(jt)throw new Error("previous call to 'initializeWebAssembly()' failed.");Pt=!0;let r=e.initTimeout,s=e.numThreads;if(!Ws())throw new Error("WebAssembly SIMD is not supported in the current environment.");let i=ln();s>1&&!i&&(typeof self<"u"&&!self.crossOriginIsolated&&console.warn("env.wasm.numThreads is set to "+s+", but this will not work unless you enable crossOriginIsolated mode. See https://web.dev/cross-origin-isolation-guide/ for more info."),console.warn("WebAssembly multi-threading is not supported in the current environment. Falling back to single-threading."),e.numThreads=s=1);let a=e.wasmPaths,c=typeof a=="string"?a:void 0,l=a==null?void 0:a.mjs,h=(l==null?void 0:l.href)??l,_=a==null?void 0:a.wasm,w=(_==null?void 0:_.href)??_,v=e.wasmBinary,[y,d]=await hs(h,c,s>1),S=!1,B=[];if(r>0&&B.push(new Promise(j=>{setTimeout(()=>{S=!0,j()},r)})),B.push(new Promise((j,Y)=>{let te={numThreads:s};v?te.wasmBinary=v:(w||c)&&(te.locateFile=(J,ye)=>w??(c??ye)+J),d(te).then(J=>{Pt=!1,dt=!0,Cn=J,j(),y&&URL.revokeObjectURL(y)},J=>{Pt=!1,jt=!0,Y(J)})})),await Promise.race(B),S)throw new Error(`WebAssembly backend initializing failed due to timeout: ${r}ms`)},Dr=()=>{if(dt&&Cn)return Cn;throw new Error("WebAssembly is not initialized yet.")}}),zr,Ss,Sr,lo=E(()=>{rs(),zr=(e,r)=>{let s=Dr(),i=s.lengthBytesUTF8(e)+1,a=s._malloc(i);return s.stringToUTF8(e,a,i),r.push(a),a},Ss=(e,r,s,i)=>{if(typeof e=="object"&&e!==null){if(s.has(e))throw new Error("Circular reference in options");s.add(e)}Object.entries(e).forEach(([a,c])=>{let l=r?r+a:a;if(typeof c=="object")Ss(c,l+".",s,i);else if(typeof c=="string"||typeof c=="number")i(l,c.toString());else if(typeof c=="boolean")i(l,c?"1":"0");else throw new Error(`Can't handle extra config type: ${typeof c}`)})},Sr=e=>{let r=Dr(),s=r.stackSave();try{let i=r.stackAlloc(8);r._OrtGetLastError(i,i+4);let a=r.HEAP32[i/4],c=r.HEAPU32[i/4+1],l=c?r.UTF8ToString(c):"";throw new Error(`${e} ERROR_CODE: ${a}, ERROR_MESSAGE: ${l}`)}finally{r.stackRestore(s)}}}),Ei,ha=E(()=>{rs(),lo(),Ei=e=>{let r=Dr(),s=0,i=[],a=e||{};try{if((e==null?void 0:e.logSeverityLevel)===void 0)a.logSeverityLevel=2;else if(typeof e.logSeverityLevel!="number"||!Number.isInteger(e.logSeverityLevel)||e.logSeverityLevel<0||e.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${e.logSeverityLevel}`);if((e==null?void 0:e.logVerbosityLevel)===void 0)a.logVerbosityLevel=0;else if(typeof e.logVerbosityLevel!="number"||!Number.isInteger(e.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${e.logVerbosityLevel}`);(e==null?void 0:e.terminate)===void 0&&(a.terminate=!1);let c=0;return(e==null?void 0:e.tag)!==void 0&&(c=zr(e.tag,i)),s=r._OrtCreateRunOptions(a.logSeverityLevel,a.logVerbosityLevel,!!a.terminate,c),s===0&&Sr("Can't create run options."),(e==null?void 0:e.extra)!==void 0&&Ss(e.extra,"",new WeakSet,(l,h)=>{let _=zr(l,i),w=zr(h,i);r._OrtAddRunConfigEntry(s,_,w)!==0&&Sr(`Can't set a run config entry: ${l} - ${h}.`)}),[s,i]}catch(c){throw s!==0&&r._OrtReleaseRunOptions(s),i.forEach(l=>r._free(l)),c}}}),Pi,Ci,uo,ma,Yr,il=E(()=>{rs(),lo(),Pi=e=>{switch(e){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${e}`)}},Ci=e=>{switch(e){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${e}`)}},uo=e=>{e.extra||(e.extra={}),e.extra.session||(e.extra.session={});let r=e.extra.session;r.use_ort_model_bytes_directly||(r.use_ort_model_bytes_directly="1"),e.executionProviders&&e.executionProviders.some(s=>(typeof s=="string"?s:s.name)==="webgpu")&&(e.enableMemPattern=!1)},ma=(e,r,s)=>{for(let i of r){let a=typeof i=="string"?i:i.name;switch(a){case"webnn":if(a="WEBNN",typeof i!="string"){let l=i==null?void 0:i.deviceType;if(l){let h=zr("deviceType",s),_=zr(l,s);Dr()._OrtAddSessionConfigEntry(e,h,_)!==0&&Sr(`Can't set a session config entry: 'deviceType' - ${l}.`)}}break;case"webgpu":if(a="JS",typeof i!="string"){let l=i;if(l!=null&&l.preferredLayout){if(l.preferredLayout!=="NCHW"&&l.preferredLayout!=="NHWC")throw new Error(`preferredLayout must be either 'NCHW' or 'NHWC': ${l.preferredLayout}`);let h=zr("preferredLayout",s),_=zr(l.preferredLayout,s);Dr()._OrtAddSessionConfigEntry(e,h,_)!==0&&Sr(`Can't set a session config entry: 'preferredLayout' - ${l.preferredLayout}.`)}}break;case"wasm":case"cpu":continue;default:throw new Error(`not supported execution provider: ${a}`)}let c=zr(a,s);Dr()._OrtAppendExecutionProvider(e,c)!==0&&Sr(`Can't append execution provider: ${a}.`)}},Yr=e=>{let r=Dr(),s=0,i=[],a=e||{};uo(a);try{let c=Pi(a.graphOptimizationLevel??"all"),l=Ci(a.executionMode??"sequential"),h=typeof a.logId=="string"?zr(a.logId,i):0,_=a.logSeverityLevel??2;if(!Number.isInteger(_)||_<0||_>4)throw new Error(`log serverity level is not valid: ${_}`);let w=a.logVerbosityLevel??0;if(!Number.isInteger(w)||w<0||w>4)throw new Error(`log verbosity level is not valid: ${w}`);let v=typeof a.optimizedModelFilePath=="string"?zr(a.optimizedModelFilePath,i):0;if(s=r._OrtCreateSessionOptions(c,!!a.enableCpuMemArena,!!a.enableMemPattern,l,!!a.enableProfiling,0,h,_,w,v),s===0&&Sr("Can't create session options."),a.executionProviders&&ma(s,a.executionProviders,i),a.enableGraphCapture!==void 0){if(typeof a.enableGraphCapture!="boolean")throw new Error(`enableGraphCapture must be a boolean value: ${a.enableGraphCapture}`);let y=zr("enableGraphCapture",i),d=zr(a.enableGraphCapture.toString(),i);r._OrtAddSessionConfigEntry(s,y,d)!==0&&Sr(`Can't set a session config entry: 'enableGraphCapture' - ${a.enableGraphCapture}.`)}if(a.freeDimensionOverrides)for(let[y,d]of Object.entries(a.freeDimensionOverrides)){if(typeof y!="string")throw new Error(`free dimension override name must be a string: ${y}`);if(typeof d!="number"||!Number.isInteger(d)||d<0)throw new Error(`free dimension override value must be a non-negative integer: ${d}`);let S=zr(y,i);r._OrtAddFreeDimensionOverride(s,S,d)!==0&&Sr(`Can't set a free dimension override: ${y} - ${d}.`)}return a.extra!==void 0&&Ss(a.extra,"",new WeakSet,(y,d)=>{let S=zr(y,i),B=zr(d,i);r._OrtAddSessionConfigEntry(s,S,B)!==0&&Sr(`Can't set a session config entry: ${y} - ${d}.`)}),[s,i]}catch(c){throw s!==0&&r._OrtReleaseSessionOptions(s),i.forEach(l=>r._free(l)),c}}}),Gs,ms,Rn,Si,Ao,co,jn,po,Rt=E(()=>{Gs=e=>{switch(e){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float16":return 10;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;case"int4":return 22;case"uint4":return 21;default:throw new Error(`unsupported data type: ${e}`)}},ms=e=>{switch(e){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 10:return"float16";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";case 22:return"int4";case 21:return"uint4";default:throw new Error(`unsupported data type: ${e}`)}},Rn=(e,r)=>{let s=[-1,4,1,1,2,2,4,8,-1,1,2,8,4,8,-1,-1,-1,-1,-1,-1,-1,.5,.5][e],i=typeof r=="number"?r:r.reduce((a,c)=>a*c,1);return s>0?Math.ceil(i*s):void 0},Si=e=>{switch(e){case"float16":return typeof Float16Array<"u"&&Float16Array.from?Float16Array:Uint16Array;case"float32":return Float32Array;case"uint8":return Uint8Array;case"int8":return Int8Array;case"uint16":return Uint16Array;case"int16":return Int16Array;case"int32":return Int32Array;case"bool":return Uint8Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${e}`)}},Ao=e=>{switch(e){case"verbose":return 0;case"info":return 1;case"warning":return 2;case"error":return 3;case"fatal":return 4;default:throw new Error(`unsupported logging level: ${e}`)}},co=e=>e==="float32"||e==="float16"||e==="int32"||e==="int64"||e==="uint32"||e==="uint8"||e==="bool"||e==="uint4"||e==="int4",jn=e=>e==="float32"||e==="float16"||e==="int32"||e==="int64"||e==="uint32"||e==="uint64"||e==="int8"||e==="uint8"||e==="bool",po=e=>{switch(e){case"none":return 0;case"cpu":return 1;case"cpu-pinned":return 2;case"texture":return 3;case"gpu-buffer":return 4;case"ml-tensor":return 5;default:throw new Error(`unsupported data location: ${e}`)}}}),ki,_a=E(()=>{Ft(),ki=async e=>{if(typeof e=="string"){let r=await fetch(e);if(!r.ok)throw new Error(`failed to load external data file: ${e}`);let s=r.headers.get("Content-Length"),i=s?parseInt(s,10):0;if(i<1073741824)return new Uint8Array(await r.arrayBuffer());{if(!r.body)throw new Error(`failed to load external data file: ${e}, no response body.`);let a=r.body.getReader(),c;try{c=new ArrayBuffer(i)}catch(h){if(h instanceof RangeError){let _=Math.ceil(i/65536);c=new WebAssembly.Memory({initial:_,maximum:_}).buffer}else throw h}let l=0;for(;;){let{done:h,value:_}=await a.read();if(h)break;let w=_.byteLength;new Uint8Array(c,l,w).set(_),l+=w}return new Uint8Array(c,0,i)}}else return e instanceof Blob?new Uint8Array(await e.arrayBuffer()):e instanceof Uint8Array?e:new Uint8Array(e)}}),ga,fo,Fo,ho,Ks,ya,kr,Oe=E(()=>{Rt(),ga=["V","I","W","E","F"],fo=(e,r)=>{console.log(`[${ga[e]},${new Date().toISOString()}]${r}`)},Ks=(e,r)=>{Fo=e,ho=r},ya=(e,r)=>{let s=Ao(e),i=Ao(Fo);s>=i&&fo(s,typeof r=="function"?r():r)},kr=(...e)=>{ho&&ya(...e)}}),I,ne=E(()=>{Rt(),I=(e,r)=>new(Si(r))(e)}),we=E(()=>{}),Ie,De,Ge,mt,bt,yt,kt,Zt,xr,ar=E(()=>{Oe(),we(),Ie=new Map([[64,250],[128,200],[256,200],[512,200],[2048,230],[4096,200],[8192,50],[16384,50],[32768,50],[65536,50],[131072,50],[262144,50],[524288,50],[1048576,50],[2097152,30],[4194304,20],[8388608,10],[12582912,10],[16777216,10],[26214400,15],[33554432,22],[44236800,2],[58982400,6],[67108864,6],[134217728,6],[167772160,6]]),De=[],Ge=e=>Math.ceil(e/16)*16,mt=e=>{for(let r=0;r<De.length;r++){let s=De[r];if(e<=s)return s}return Math.ceil(e/16)*16},bt=1,yt=()=>bt++,kt=async(e,r,s,i)=>{let a=Ge(s),c=e.device.createBuffer({size:a,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ});try{let l=e.getCommandEncoder();e.endComputePass(),l.copyBufferToBuffer(r,0,c,0,a),e.flush(),await c.mapAsync(GPUMapMode.READ);let h=c.getMappedRange();if(i){let _=i();return _.set(new Uint8Array(h,0,s)),_}else return new Uint8Array(h.slice(0,s))}finally{c.destroy()}},Zt=class{constructor(e){this.backend=e,this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map,this.buffersForUploadingPending=[],this.buffersPending=[],this.capturedPendingBuffers=new Map;for(let[r]of Ie)De.push(r),this.freeBuffers.set(r,[]),this.freeUniformBuffers.set(r,[])}upload(e,r){let s=r.buffer,i=r.byteOffset,a=r.byteLength,c=Ge(a),l=this.storageCache.get(e);if(!l)throw new Error("gpu data for uploading does not exist");if(l.originalSize!==a)throw new Error(`inconsistent data size. gpu data size=${l.originalSize}, data size=${a}`);let h=this.backend.device.createBuffer({mappedAtCreation:!0,size:c,usage:GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC}),_=h.getMappedRange();new Uint8Array(_).set(new Uint8Array(s,i,a)),h.unmap();let w=this.backend.getCommandEncoder();this.backend.endComputePass(),w.copyBufferToBuffer(h,0,l.gpuData.buffer,0,c),kr("verbose",()=>`[WebGPU] GpuDataManager.upload(id=${e})`),this.buffersForUploadingPending.push(h)}memcpy(e,r){let s=this.storageCache.get(e);if(!s)throw new Error("source gpu data for memcpy does not exist");let i=this.storageCache.get(r);if(!i)throw new Error("destination gpu data for memcpy does not exist");if(s.originalSize!==i.originalSize)throw new Error("inconsistent source and destination gpu data size");let a=Ge(s.originalSize),c=this.backend.getCommandEncoder();this.backend.endComputePass(),c.copyBufferToBuffer(s.gpuData.buffer,0,i.gpuData.buffer,0,a)}registerExternalBuffer(e,r,s){let i;if(s){if(i=s[0],e===s[1])return kr("verbose",()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${r}) => id=${i}, buffer is the same, skip.`),i;if(this.backend.capturedCommandList.has(this.backend.currentSessionId))throw new Error(`Registering a different external buffer under graph capture mode is not supported yet.
             Please use the previous external buffer!`)}else i=yt();return this.storageCache.set(i,{gpuData:{id:i,type:0,buffer:e},originalSize:r}),kr("verbose",()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${r}) => id=${i}, registered.`),i}unregisterExternalBuffer(e){e!==void 0&&(this.storageCache.delete(e),kr("verbose",()=>`[WebGPU] GpuDataManager.unregisterExternalBuffer() => id=${e}`))}create(e,r=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST){let s=mt(e),i,a=(r&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE,c=(r&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM;if(a||c){let h=(a?this.freeBuffers:this.freeUniformBuffers).get(s);h?h.length>0?i=h.pop():i=this.backend.device.createBuffer({size:s,usage:r}):i=this.backend.device.createBuffer({size:s,usage:r})}else i=this.backend.device.createBuffer({size:s,usage:r});let l={id:yt(),type:0,buffer:i};return this.storageCache.set(l.id,{gpuData:l,originalSize:e}),kr("verbose",()=>`[WebGPU] GpuDataManager.create(size=${e}) => id=${l.id}`),l}get(e){var r;return(r=this.storageCache.get(e))==null?void 0:r.gpuData}release(e){let r=this.storageCache.get(e);if(!r)throw new Error("releasing data does not exist");return kr("verbose",()=>`[WebGPU] GpuDataManager.release(id=${e}), gpuDataId=${r.gpuData.id}`),this.storageCache.delete(e),this.buffersPending.push(r.gpuData.buffer),r.originalSize}async download(e,r){let s=this.storageCache.get(e);if(!s)throw new Error("data does not exist");await kt(this.backend,s.gpuData.buffer,s.originalSize,r)}refreshPendingBuffers(){for(let e of this.buffersForUploadingPending)e.destroy();if(this.buffersForUploadingPending=[],this.buffersPending.length!==0)if(this.backend.sessionStatus==="default"){for(let e of this.buffersPending){let r=Ie.get(e.size);if((e.usage&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE){let s=this.freeBuffers.get(e.size)||[];r===void 0||s.length>=r?e.destroy():s.push(e)}else if((e.usage&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM){let s=this.freeUniformBuffers.get(e.size)||[];r===void 0||s.length>=r?e.destroy():s.push(e)}else e.destroy()}this.buffersPending=[]}else{let e=this.capturedPendingBuffers.get(this.backend.currentSessionId);e||(e=[],this.capturedPendingBuffers.set(this.backend.currentSessionId,e));for(let r of this.buffersPending)e.push(r);this.buffersPending=[]}}dispose(){this.freeBuffers.forEach(e=>{e.forEach(r=>{r.destroy()})}),this.freeUniformBuffers.forEach(e=>{e.forEach(r=>{r.destroy()})}),this.storageCache.forEach(e=>{e.gpuData.buffer.destroy()}),this.capturedPendingBuffers.forEach(e=>{e.forEach(r=>{r.destroy()})}),this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map,this.capturedPendingBuffers=new Map}onReleaseSession(e){let r=this.capturedPendingBuffers.get(e);r&&(r.forEach(s=>{s.destroy()}),this.capturedPendingBuffers.delete(e))}},xr=(...e)=>new Zt(...e)}),Fr,Ht,hr=E(()=>{Fr=class{constructor(e){Object.assign(this,e)}get cacheKey(){return this.key||(this.key=Object.getOwnPropertyNames(this).sort().map(e=>`${this[e]}`).join(";")),this.key}},Ht=e=>new Fr(e)}),fn,Nr,Qe,mr,Mn,Qn,Nn,qt=E(()=>{fn=class{static calcMatMulShape(e,r){return e[1]!==r[0]?void 0:[e[0],r[1]]}},Nr=class{static calcShape(e,r,s=!1){let i=e.length,a=r.length;if(i===0)return r;if(a===0)return e;let c=Math.max(e.length,r.length),l=new Array(c);if(s){if(i<2||a<2)return;let h=fn.calcMatMulShape([e[i-2],e[i-1]],[r[a-2],r[a-1]]);if(h===void 0)return;[l[c-2],l[c-1]]=h}for(let h=s?3:1;h<=c;h++){let _=i-h<0?1:e[i-h],w=a-h<0?1:r[a-h];if(_!==w&&_>1&&w>1)return;let v=Math.max(_,w);if(_&&w)l[c-h]=Math.max(_,w);else{if(v>1)return;l[c-h]=0}}return l}static isValidBroadcast(e,r){let s=e.length,i=r.length;if(s>i)return!1;for(let a=1;a<=s;a++)if(e[s-a]!==1&&e[s-a]!==r[i-a])return!1;return!0}},Qe=class sf{static size(r){return sf.getSizeFromDimensionRange(r,0,r.length)}static convertShape(r,s=4){let i=r.length;if(i===0)return[];let a=new Array(i),c=i-1;for(;c>=0;){if(r[c]%s===0){a[c]=r[c]/s;break}if(s%r[c]!==0)throw new Error("cannot convert shape");a[c]=1,s/=r[c],c--}for(c--;c>=0;c--)a[c]=r[c];return a}static sizeFromDimension(r,s){if(s<0||s>r.length)throw new Error(`invalid dimension of ${s} for sizeFromDimension as Tensor has ${r.length} dimensions.`);return sf.getSizeFromDimensionRange(r,s,r.length)}static sizeToDimension(r,s){if(s<0||s>r.length)throw new Error(`invalid dimension of ${s} for sizeToDimension as Tensor has ${r.length} dimensions.`);return sf.getSizeFromDimensionRange(r,0,s)}static getSizeFromDimensionRange(r,s,i){let a=1;for(let c=s;c<i;c++){if(r[c]<0)throw new Error("cannot get valid size from specified dimension range. Most likely the range contains negative values in them.");a*=r[c]}return a}static computeStrides(r){let s=r.length;if(s===0)return[];if(s===1)return[1];let i=new Array(s);i[s-1]=1,i[s-2]=r[s-1];for(let a=s-3;a>=0;--a)i[a]=i[a+1]*r[a+1];return i}static normalizeAxis(r,s){if(r<-s&&r>=s)throw new Error("unsupported axis for this operation.");return r<0?r+s:r}static normalizeAxes(r,s){return r.map(i=>this.normalizeAxis(i,s??r.length))}static sortBasedOnPerm(r,s){return s?s.map(i=>r[i]):r.slice().reverse()}static padShape(r,s){let i=r.length;return r.map((a,c)=>a+s[c]+s[c+i])}static areEqual(r,s){return r.length!==s.length?!1:r.every((i,a)=>i===s[a])}},mr=class Bp{static adjustPoolAttributes(r,s,i,a,c,l){if(!r&&i.length!==s.length-2)throw new Error("length of specified kernel shapes should be 2 less than length of input dimensions");if(r)for(let h=0;h<s.length-2;h++)h>=i.length?i.push(s[h+2]):i[h]=s[h+2];for(let h=0;h<i.length;h++)if(h<a.length){if(a[h]<0)throw new Error("strides should be greater than or equal to 1")}else a.push(1);for(let h=0;h<i.length;h++)if(h<c.length){if(c[h]<0)throw new Error("dilations should be greater than or equal to 1")}else c.push(1);for(let h=0;h<i.length*2;h++)if(h<l.length){if(l[h]<0)throw new Error("pad should be greater than or equal to 1")}else l.push(0);for(let h=0;h<i.length;h++){if(i[h]<=0)throw new Error("kernel shapes need to be greater than 0");if(l[h]>=i[h]||l[h+i.length]>=i[h])throw new Error("pads should be smaller than kernel")}}static adjustPadsBasedOnAutoPad(r,s,i,a,c,l,h){if(h){if(c.length!==2*(r.length-2))throw new Error("length of pads should be twice the length of data dimensions");if(s.length!==r.length-2)throw new Error("length of strides should be the length of data dimensions");if(a.length!==r.length-2)throw new Error("length of kernel shapes should be the length of data dimensions");for(let _=0;_<r.length-2;_++)Bp.adjustPadAndReturnShape(r[_+(l?1:2)],s[_],i[_],a[_],c,_,_+r.length-2,h)}}static computePoolOutputShape(r,s,i,a,c,l,h){if(s.length<=0)throw new Error("input shape must be of size greater than 0");let _=[s[0],s[1]];return Bp.computeShapeHelper(r,s,_,i,a,c,l,h),_}static computeConvOutputShape(r,s,i,a,c,l,h){if(r.length<=0||s.length<=0)throw new Error("invalid input tensor dims or invalid filter tensor dims");let _=[r[0],s[0]];return Bp.computeShapeHelper(!1,r,_,i,a,c,l,h),_}static computeShapeHelper(r,s,i,a,c,l,h,_){if(r)for(let w=0;w<s.length-2;w++)i.push(1);else for(let w=0;w<s.length-2;w++)i.push(Bp.adjustPadAndReturnShape(s[w+2],a[w],c[w],l[w],h,w,w+s.length-2,_))}static adjustPadAndReturnShape(r,s,i,a,c,l,h,_){let w=i*(a-1)+1;if(_&&_!=="NOTSET")switch(_){case"VALID":return c[l]=0,c[h]=0,Math.floor((r-w)/s+1);case"SAME_LOWER":case"SAME_UPPER":if(i!==1)throw new Error("Dilation not supported for SAME_UPPER or SAME_LOWER");{let v=((r+s-1)/s-1)*s+a-r;return c[l]=Math.floor(_==="SAME_LOWER"?(v+1)/2:v/2),c[h]=v-c[l],Math.floor((r+v-a)/s+1)}default:throw new Error("Unsupported AutoPad type")}else return Math.floor((r+c[l]+c[h]-w)/s+1)}},Mn=class{static getShapeOfGemmResult(e,r,s,i,a){if(e.length!==2||s.length!==2)throw new Error("shape need to be of size 2");let c,l,h;r?(c=e[1],l=e[0]):(c=e[0],l=e[1]);let _=-1;if(i?(h=s[0],_=1):(h=s[1],_=0),s[_]!==l)throw new Error("dimension mismatch");if(c<=0||h<=0||l<=0)throw new Error("invalid shape specified");if(a&&!Nr.isValidBroadcast(a,[c,h]))throw new Error("gemm: invalid bias shape for broadcast");return[c,h,l]}},Qn=-34028234663852886e22,Nn=34028234663852886e22}),gn,Sn,_r,$r,Tt,Jt,Jr,ns,Hs,Nt,$i,it,Ut,al,qs,ll,Oo,or=E(()=>{Rt(),qt(),gn=64,Sn=(e,r)=>{if(r===3)throw new Error("vec3 has same alignment as vec4, use vec4 instead");switch(e){case 10:return r>1?`vec${r}<f16>`:"f16";case 1:return r>1?`vec${r}<f32>`:"f32";case 6:return r>1?`vec${r}<i32>`:"i32";case 12:return r>1?`vec${r}<u32>`:"u32";case 7:if(r>1)throw new Error("currently not supported vecX of uint64 yet");return["vec2<u32>","i32"];case 13:if(r>1)throw new Error("currently not supported vecX of uint64 yet");return["vec2<u32>","u32"];case 9:if(r!==4)throw new Error("bool must be vec4");return["u32","vec4<bool>"];case 22:return"i32";case 21:return"u32";default:throw new Error(`Unknown data type: ${e}`)}},_r=(e,r=1)=>{let s=Sn(e,r);return typeof s=="string"?s:s[0]},$r=(e,r=1)=>{let s=Sn(e,r);return typeof s=="string"?s:s[1]},Tt=(...e)=>{let r=[];return e.forEach(s=>{s.length!==0&&r.push({type:12,data:s},{type:12,data:Qe.computeStrides(s)})}),r},Jt=e=>e%4===0?4:e%2===0?2:1,Jr=(e="f32",r,s="0")=>!r||r===1?`${e}(${s})`:`vec${r}<${e}>(${s})`,ns=(e,r,s)=>e==="f32"?s:r===1?`f32(${s})`:`vec${r}<f32>(${s})`,Hs=(e,r)=>r===4?`(${e}.x + ${e}.y + ${e}.z + ${e}.w)`:r===2?`(${e}.x + ${e}.y)`:r===3?`(${e}.x + ${e}.y + ${e}.z)`:e,Nt=(e,r,s,i)=>e.startsWith("uniforms.")&&s>4?typeof r=="string"?i==="f16"?`${e}[(${r}) / 8][(${r}) % 8 / 4][(${r}) % 8 % 4]`:`${e}[(${r}) / 4][(${r}) % 4]`:i==="f16"?`${e}[${Math.floor(r/8)}][${Math.floor(r%8/4)}][${r%8%4}]`:`${e}[${Math.floor(r/4)}][${r%4}]`:s>1?`${e}[${r}]`:e,$i=(e,r,s,i,a)=>{let c=typeof s=="number",l=c?s:s.length,h=[...new Array(l).keys()],_=l<2?"u32":l<=4?`vec${l}<u32>`:`array<u32, ${l}>`,w=Sn(r,a),v=typeof w=="string"?w:w[1],y=typeof w=="string"?w:w[0],d={indices:_,value:v,storage:y,tensor:r},S=et=>typeof et=="string"?et:`${et}u`,B={offsetToIndices:!1,indicesToOffset:!1,broadcastedIndicesToOffset:!1,set:!1,setByIndices:!1,get:!1,getByIndices:!1},j=c?"uniforms.":"",Y=`${j}${e}_shape`,te=`${j}${e}_strides`,J="";for(let et=0;et<l-1;et++)J+=`
    let dim${et} = current / ${Nt(te,et,l)};
    let rest${et} = current % ${Nt(te,et,l)};
    indices[${et}] = dim${et};
    current = rest${et};
    `;J+=`indices[${l-1}] = current;`;let ye=l<2?"":`
  fn o2i_${e}(offset: u32) -> ${d.indices} {
    var indices: ${d.indices};
    var current = offset;
    ${J}
    return indices;
  }`,ve=et=>(B.offsetToIndices=!0,l<2?et:`o2i_${e}(${et})`),Ce=[];if(l>=2)for(let et=l-1;et>=0;et--)Ce.push(`${Nt(te,et,l)} * (indices[${et}])`);let Ze=l<2?"":`
  fn i2o_${e}(indices: ${d.indices}) -> u32 {
    return ${Ce.join("+")};
  }`,Ke=et=>(B.indicesToOffset=!0,l<2?et:`i2o_${e}(${et})`),ft=(...et)=>l===0?"0u":`${d.indices}(${et.map(S).join(",")})`,It=(et,xt)=>l<2?`${et}`:`${Nt(et,xt,l)}`,Bt=(et,xt,rr)=>l<2?`${et}=${rr};`:`${Nt(et,xt,l)}=${rr};`,cr={},fr=(et,xt)=>{B.broadcastedIndicesToOffset=!0;let rr=`${xt.name}broadcastedIndicesTo${e}Offset`;if(rr in cr)return`${rr}(${et})`;let jr=[];for(let Fn=l-1;Fn>=0;Fn--){let zn=xt.indicesGet("outputIndices",Fn+xt.rank-l);jr.push(`${It(te,Fn)} * (${zn} % ${It(Y,Fn)})`)}return cr[rr]=`fn ${rr}(outputIndices: ${xt.type.indices}) -> u32 {
             return ${jr.length>0?jr.join("+"):"0u"};
           }`,`${rr}(${et})`},Xt=(et,xt)=>(()=>{if(d.storage===d.value)return`${e}[${et}]=${xt};`;if(d.storage==="vec2<u32>"&&d.value==="i32")return`${e}[${et}]=vec2<u32>(u32(${xt}), select(0u, 0xFFFFFFFFu, ${xt} < 0));`;if(d.storage==="vec2<u32>"&&d.value==="u32")return`${e}[${et}]=vec2<u32>(u32(${xt}), 0u);`;if(d.storage==="u32"&&d.value==="vec4<bool>")return`${e}[${et}]=dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(${xt}));`;throw new Error(`not supported combination of storage type ${d.storage} and value type ${d.value} yet`)})(),Rr=et=>(()=>{if(d.storage===d.value)return`${e}[${et}]`;if(d.storage==="vec2<u32>"&&d.value==="i32")return`i32(${e}[${et}].x)`;if(d.storage==="vec2<u32>"&&d.value==="u32")return`u32(${e}[${et}].x)`;if(d.storage==="u32"&&d.value==="vec4<bool>")return`vec4<bool>(bool(${e}[${et}] & 0xFFu), bool(${e}[${et}] & 0xFF00u), bool(${e}[${et}] & 0xFF0000u), bool(${e}[${et}] & 0xFF000000u))`;throw new Error(`not supported combination of storage type ${d.storage} and value type ${d.value} yet`)})(),on=l<2?"":`
  fn get_${e}ByIndices(indices: ${d.indices}) -> ${v} {
    return ${Rr(`i2o_${e}(indices)`)};
  }`,yr=l<2?"":(()=>{let et=h.map(rr=>`d${rr}: u32`).join(", "),xt=h.map(rr=>`d${rr}`).join(", ");return`
  fn get_${e}(${et}) -> ${v} {
    return get_${e}ByIndices(${ft(xt)});
  }`})(),Vr=(...et)=>{if(et.length!==l)throw new Error(`indices length must be ${l}`);let xt=et.map(S).join(",");return l===0?Rr("0u"):l===1?Rr(xt[0]):(B.get=!0,B.getByIndices=!0,B.indicesToOffset=!0,`get_${e}(${xt})`)},Wt=et=>l<2?Rr(et):(B.getByIndices=!0,B.indicesToOffset=!0,`get_${e}ByIndices(${et})`),tr=l<2?"":`
  fn set_${e}ByIndices(indices: ${d.indices}, value: ${v}) {
    ${Xt(`i2o_${e}(indices)`,"value")}
  }`,Ir=l<2?"":(()=>{let et=h.map(rr=>`d${rr}: u32`).join(", "),xt=h.map(rr=>`d${rr}`).join(", ");return`
  fn set_${e}(${et}, value: ${v}) {
    set_${e}ByIndices(${ft(xt)}, value);
  }`})();return{impl:()=>{let et=[],xt=!1;return B.offsetToIndices&&(et.push(ye),xt=!0),B.indicesToOffset&&(et.push(Ze),xt=!0),B.broadcastedIndicesToOffset&&(Object.values(cr).forEach(rr=>et.push(rr)),xt=!0),B.set&&(et.push(Ir),xt=!0),B.setByIndices&&(et.push(tr),xt=!0),B.get&&(et.push(yr),xt=!0),B.getByIndices&&(et.push(on),xt=!0),!c&&xt&&et.unshift(`const ${Y} = ${d.indices}(${s.join(",")});`,`const ${te} = ${d.indices}(${Qe.computeStrides(s).join(",")});`),et.join(`
`)},type:d,offsetToIndices:ve,indicesToOffset:Ke,broadcastedIndicesToOffset:fr,indices:ft,indicesGet:It,indicesSet:Bt,set:(...et)=>{if(et.length!==l+1)throw new Error(`indices length must be ${l}`);let xt=et[l];if(typeof xt!="string")throw new Error("value must be string");let rr=et.slice(0,l).map(S).join(",");return l===0?Xt("0u",xt):l===1?Xt(rr[0],xt):(B.set=!0,B.setByIndices=!0,B.indicesToOffset=!0,`set_${e}(${rr}, ${xt})`)},setByOffset:Xt,setByIndices:(et,xt)=>l<2?Xt(et,xt):(B.setByIndices=!0,B.indicesToOffset=!0,`set_${e}ByIndices(${et}, ${xt});`),get:Vr,getByOffset:Rr,getByIndices:Wt,usage:i,name:e,strides:te,shape:Y,rank:l}},it=(e,r,s,i=1)=>$i(e,r,s,"input",i),Ut=(e,r,s,i=1)=>$i(e,r,s,"output",i),al=(e,r,s,i=1)=>$i(e,r,s,"internal",i),qs=class{constructor(e,r){this.normalizedDispatchGroup=e,this.limits=r,this.internalVariables=[],this.variables=[],this.uniforms=[],this.variableIndex=0}guardAgainstOutOfBoundsWorkgroupSizes(e){return`if (global_idx >= ${typeof e=="number"?`${e}u`:e}) { return; }`}mainStart(e=gn){let r=typeof e=="number"?e:e[0],s=typeof e=="number"?1:e[1],i=typeof e=="number"?1:e[2];if(r>this.limits.maxComputeWorkgroupSizeX||s>this.limits.maxComputeWorkgroupSizeY||i>this.limits.maxComputeWorkgroupSizeZ)throw new Error(`workgroup size [${r}, ${s}, ${i}] exceeds the maximum workgroup size [${this.limits.maxComputeWorkgroupSizeX}, ${this.limits.maxComputeWorkgroupSizeY}, ${this.limits.maxComputeWorkgroupSizeZ}].`);if(r*s*i>this.limits.maxComputeInvocationsPerWorkgroup)throw new Error(`workgroup size [${r}, ${s}, ${i}] exceeds the maximum workgroup invocations ${this.limits.maxComputeInvocationsPerWorkgroup}.`);let a=this.normalizedDispatchGroup[1]===1&&this.normalizedDispatchGroup[2]===1,c=a?`@builtin(global_invocation_id) global_id : vec3<u32>,
    @builtin(workgroup_id) workgroup_id : vec3<u32>,
    @builtin(local_invocation_index) local_idx : u32,
    @builtin(local_invocation_id) local_id : vec3<u32>`:`@builtin(global_invocation_id) global_id : vec3<u32>,
                                             @builtin(local_invocation_id) local_id : vec3<u32>,
    @builtin(local_invocation_index) local_idx : u32,
    @builtin(workgroup_id) workgroup_id : vec3<u32>,
    @builtin(num_workgroups) num_workgroups : vec3<u32>`,l=a?`let global_idx = global_id.x;
         let workgroup_index = workgroup_id.x;`:`let workgroup_index = workgroup_id.z * num_workgroups[0] * num_workgroups[1] +
             workgroup_id.y * num_workgroups[0] + workgroup_id.x;
         let global_idx = workgroup_index * ${r*s*i}u + local_idx;`;return`@compute @workgroup_size(${r}, ${s}, ${i})
  fn main(${c}) {
    ${l}
  `}appendVariableUniforms(e){e.rank!==0&&(e.shape.startsWith("uniforms.")&&this.uniforms.push({name:e.shape.replace("uniforms.",""),type:"u32",length:e.rank}),e.strides.startsWith("uniforms.")&&this.uniforms.push({name:e.strides.replace("uniforms.",""),type:"u32",length:e.rank}))}declareVariable(e,r){if(e.usage==="internal")throw new Error("cannot use internal variable with declareVariable(). use registerInternalVariables() instead.");this.variables.push(e),this.appendVariableUniforms(e);let s=e.usage==="input"?"read":"read_write",i=e.type.storage;return`@group(0) @binding(${r}) var<storage, ${s}> ${e.name}: array<${i}>;`}declareVariables(...e){return e.map(r=>this.declareVariable(r,this.variableIndex++)).join(`
`)}registerInternalVariable(e){if(e.usage!=="internal")throw new Error("cannot use input or output variable with registerInternalVariable(). use declareVariables() instead.");this.internalVariables.push(e),this.appendVariableUniforms(e)}registerInternalVariables(...e){return e.forEach(r=>this.registerInternalVariable(r)),this}registerUniform(e,r,s=1){return this.uniforms.push({name:e,type:r,length:s}),this}registerUniforms(e){return this.uniforms=this.uniforms.concat(e),this}uniformDeclaration(){if(this.uniforms.length===0)return"";let e=[];for(let{name:r,type:s,length:i}of this.uniforms)if(i&&i>4)s==="f16"?e.push(`@align(16) ${r}:array<mat2x4<${s}>, ${Math.ceil(i/8)}>`):e.push(`${r}:array<vec4<${s}>, ${Math.ceil(i/4)}>`);else{let a=i==null||i===1?s:`vec${i}<${s}>`;e.push(`${r}:${a}`)}return`
      struct Uniforms { ${e.join(", ")} };
      @group(0) @binding(${this.variableIndex}) var<uniform> uniforms: Uniforms;`}get additionalImplementations(){return this.uniformDeclaration()+this.variables.map(e=>e.impl()).join(`
`)+this.internalVariables.map(e=>e.impl()).join(`
`)}get variablesInfo(){if(this.uniforms.length===0)return;let e=r=>[12,10,1,6][["u32","f16","f32","i32"].indexOf(r)];return this.uniforms.map(r=>[e(r.type),r.length??1])}},ll=(e,r)=>new qs(e,r),Oo=(e,r)=>{let s=e.length,i=[];for(let a=0;a<s;a++){let c=s-1-a,l=e[c]||1;(r[r.length-1-a]||1)>1&&l===1&&i.unshift(c)}return i}}),wa,Lo,vu,Xn,qo,Un,ks,ad,mo=E(()=>{Rt(),qt(),hr(),or(),wa=e=>{if(!e||e.length!==1)throw new Error("Transpose requires 1 input.")},Lo=(e,r)=>r&&r.length!==e?[...new Array(e).keys()].reverse():r,vu=(e,r)=>Qe.sortBasedOnPerm(e,Lo(e.length,r)),Xn=(e,r,s,i)=>{let a=`fn perm(i: ${i.type.indices}) -> ${s.type.indices} {
    var a: ${s.type.indices};`;for(let c=0;c<r;++c)a+=s.indicesSet("a",e[c],`i[${c}]`);return a+="return a;}"},qo=(e,r)=>{let s=[],i=[];for(let a=0;a<e.length;++a)e[a]!==1&&s.push(e[a]),e[r[a]]!==1&&i.push(r[a]);return{newShape:s,newPerm:i}},Un=(e,r)=>{let s=e.dataType,i=e.dims.length,a=Lo(i,r),c=vu(e.dims,a),{newShape:l,newPerm:h}=qo(e.dims,a),_=Qe.areEqual(h,[2,3,1]),w=Qe.areEqual(h,[3,1,2]),v=l.length===2&&h[0]>h[1]||_||w,y=v?l:e.dims,d=c;v&&(y=_?[l[0],l[1]*l[2]]:w?[l[0]*l[1],l[2]]:l,d=[y[1],y[0]]);let S=it("a",s,y.length),B=Ut("output",s,d.length),j=16,Y;return v?Y=te=>`
  ${te.registerUniform("output_size","u32").declareVariables(S,B)}
  var<workgroup> tile : array<array<${B.type.value}, ${j+1}>, ${j}>;
  ${te.mainStart([j,j,1])}
    let stride = (uniforms.output_shape[1] - 1) / ${j} + 1;
    let workgroup_id_x = workgroup_index % stride;
    let workgroup_id_y = workgroup_index / stride;
    let input_col = workgroup_id_y * ${j}u + local_id.x;
    let input_row = workgroup_id_x * ${j}u + local_id.y;
    if (input_row < uniforms.a_shape[0] && input_col < uniforms.a_shape[1]) {
      tile[local_id.y][local_id.x] = ${S.getByIndices(`${S.type.indices}(input_row, input_col)`)};
    }
    workgroupBarrier();

    let output_col = workgroup_id_x * ${j}u + local_id.x;
    let output_row = workgroup_id_y * ${j}u + local_id.y;
    if (output_row < uniforms.output_shape[0] && output_col < uniforms.output_shape[1]) {
      ${B.setByIndices(`${B.type.indices}(output_row, output_col)`,"tile[local_id.x][local_id.y]")}
    }
  }`:Y=te=>`
  ${te.registerUniform("output_size","u32").declareVariables(S,B)}

  ${Xn(a,i,S,B)}

  ${te.mainStart()}
    ${te.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

    let indices = ${B.offsetToIndices("global_idx")};
    let aIndices = perm(indices);

    ${B.setByOffset("global_idx",S.getByIndices("aIndices"))}
  }`,{name:v?"TransposeShared":"Transpose",shaderCache:{hint:`${r}`,inputDependencies:["rank"]},getRunData:()=>{let te=Qe.size(c);return{outputs:[{dims:c,dataType:e.dataType}],dispatchGroup:v?{x:Math.ceil(d[1]/j),y:Math.ceil(d[0]/j)}:{x:Math.ceil(te/64)},programUniforms:[{type:12,data:te},...Tt(y,d)]}},getShaderSource:Y}},ks=(e,r)=>{wa(e.inputs),e.compute(Un(e.inputs[0],r.perm))},ad=e=>Ht({perm:e.perm})}),ul,va,Ma,cl,ld,ud,cd,dl,dd,pl,$s,pd,fd,fl,hd,md,Mu,_d,hl,xu,gd,fp=E(()=>{Rt(),qt(),or(),$u(),mo(),ul={max:"select(bestValue, candidate, candidate > bestValue)",min:"select(bestValue, candidate, candidate < bestValue)",mean:"bestValue + candidate",sum:"bestValue + candidate",prod:"bestValue * candidate",sumSquare:"bestValue + candidate * candidate",logSumExp:"bestValue + exp(candidate)",l1:"bestValue + abs(candidate)",l2:"bestValue + candidate * candidate",logSum:"bestValue + candidate"},va={max:"select(bestValue, candidate, candidate > bestValue)",min:"select(bestValue, candidate, candidate < bestValue)",mean:"bestValue + candidate",sum:"bestValue + candidate",prod:"bestValue * candidate",sumSquare:"bestValue + candidate",logSumExp:"bestValue + candidate",l1:"bestValue + candidate",l2:"bestValue + candidate",logSum:"bestValue + candidate"},Ma={max:"_A[offset]",min:"_A[offset]",mean:"0",sum:"0",prod:"1",sumSquare:"0",logSumExp:"0",l1:"0",l2:"0",logSum:"0"},cl={max:"bestValue",min:"bestValue",sum:"bestValue",prod:"bestValue",sumSquare:"bestValue",logSumExp:"log(bestValue)",l1:"bestValue",l2:"sqrt(bestValue)",logSum:"log(bestValue)"},ld=(e,r)=>{let s=[];for(let i=r-e;i<r;++i)s.push(i);return s},ud=(e,r)=>{let s=[],i=e.length;for(let c=0;c<i;c++)r.indexOf(c)===-1&&s.push(e[c]);let a=r.map(c=>e[c]);return[s,a]},cd=(e,r)=>{let s=e.length+r.length,i=[],a=0;for(let c=0;c<s;c++)r.indexOf(c)===-1?i.push(e[a++]):i.push(1);return i},dl=(e,r)=>{for(let s=0;s<e.length;++s)if(e[e.length-s-1]!==r-1-s)return!1;return!0},dd=(e,r)=>{let s=[];if(!dl(e,r)){for(let i=0;i<r;++i)e.indexOf(i)===-1&&s.push(i);e.forEach(i=>s.push(i))}return s},pl=(e,r,s,i,a,c,l)=>{let h=s[0].dims,_=Qe.size(c),w=Qe.size(l),v=it("_A",s[0].dataType,h),y=Ut("output",a,c),d=32,S=`
          var<workgroup> aBestValues : array<f32, ${d}>;
       `;return{name:e,shaderCache:r,getShaderSource:B=>`
        ${B.registerUniform("reduceSize","u32").declareVariables(v,y)}
        ${S}
        fn DIV_CEIL(a : u32, b : u32) -> u32 {
          return ((a - 1u) / b + 1u);
         }
         ${B.mainStart(d)}

          let outputIndex = global_idx / ${d};
          let offset = outputIndex * uniforms.reduceSize;

          var bestValue = f32(${Ma[i]});
          let Length = uniforms.reduceSize;
          for (var k = local_idx; k < Length; k = k + ${d}) {
           let candidate = f32(${v.getByOffset("offset + k")});
           bestValue = ${ul[i]};
          }
          aBestValues[local_idx] = bestValue;
          workgroupBarrier();

         var reduceSize = min(Length, ${d}u);
         for (var currentSize = reduceSize / 2u; reduceSize > 1u;
             currentSize = reduceSize / 2u) {
           let interval = DIV_CEIL(reduceSize, 2u);
           if (local_idx < currentSize) {
            let candidate = aBestValues[local_idx + interval];
            bestValue = ${va[i]};
            aBestValues[local_idx] = bestValue;
           }
           reduceSize = interval;
           workgroupBarrier();
         }

         if (local_idx == 0u) {
          ${y.setByOffset("outputIndex",`${i==="mean"?`${y.type.storage}(bestValue / f32(uniforms.reduceSize))`:`${y.type.storage}(${cl[i]})`}`)};
         }
        }`,getRunData:()=>({outputs:[{dims:c,dataType:a}],dispatchGroup:{x:_},programUniforms:[{type:12,data:w}]})}},$s=(e,r,s,i)=>{let a=e.inputs.length===1?s:_l(e.inputs,s),c=a.axes;c.length===0&&!a.noopWithEmptyAxes&&(c=e.inputs[0].dims.map((S,B)=>B));let l=Qe.normalizeAxes(c,e.inputs[0].dims.length),h=l,_=e.inputs[0],w=dd(h,e.inputs[0].dims.length);w.length>0&&(_=e.compute(Un(e.inputs[0],w),{inputs:[0],outputs:[-1]})[0],h=ld(h.length,_.dims.length));let[v,y]=ud(_.dims,h),d=v;a.keepDims&&(d=cd(v,l)),e.compute(pl(r,{hint:a.cacheKey,inputDependencies:["type"]},[_],i,e.inputs[0].dataType,d,y),{inputs:[_]})},pd=(e,r)=>{$s(e,"ReduceMeanShared",r,"mean")},fd=(e,r)=>{$s(e,"ReduceL1Shared",r,"l1")},fl=(e,r)=>{$s(e,"ReduceL2Shared",r,"l2")},hd=(e,r)=>{$s(e,"ReduceLogSumExpShared",r,"logSumExp")},md=(e,r)=>{$s(e,"ReduceMaxShared",r,"max")},Mu=(e,r)=>{$s(e,"ReduceMinShared",r,"min")},_d=(e,r)=>{$s(e,"ReduceProdShared",r,"prod")},hl=(e,r)=>{$s(e,"ReduceSumShared",r,"sum")},xu=(e,r)=>{$s(e,"ReduceSumSquareShared",r,"sumSquare")},gd=(e,r)=>{$s(e,"ReduceLogSumShared",r,"logSum")}}),ss,yd,ml,_l,Is,wd,Tu,vd,gl,Qo,Md,bu,yl,Eu,Pu,os,Xo,xd,Cu,Td,Su,wl,Ii,Ai,ku,xa,$u=E(()=>{Rt(),qt(),hr(),or(),fp(),ss=e=>{if(!e||e.length===0||e.length>2)throw new Error("Reduce op requires 1 or 2 inputs.");if(e.length===2&&e[1].dims.length!==1)throw new Error("Invalid axes input dims.")},yd=e=>["","",`var value = ${e.getByIndices("input_indices")};`,""],ml=(e,r,s,i,a,c,l=!1,h=!1)=>{let _=[],w=s[0].dims,v=w.length,y=Qe.normalizeAxes(a,v),d=!h&&y.length===0;w.forEach((j,Y)=>{d||y.indexOf(Y)>=0?l&&_.push(1):_.push(j)});let S=_.length,B=Qe.size(_);return{name:e,shaderCache:r,getShaderSource:j=>{let Y=[],te=it("_A",s[0].dataType,v),J=Ut("output",c,S),ye=i(te,J,y),ve=ye[2];for(let Ce=0,Ze=0;Ce<v;Ce++)d||y.indexOf(Ce)>=0?(l&&Ze++,ve=`for(var j${Ce}: u32 = 0; j${Ce} < ${w[Ce]}; j${Ce}++) {
                  ${ye[2].includes("last_index")?`let last_index = j${Ce};`:""}
                  ${te.indicesSet("input_indices",Ce,`j${Ce}`)}
                  ${ve}
                }`):(Y.push(`${te.indicesSet("input_indices",Ce,J.indicesGet("output_indices",Ze))};`),Ze++);return`

        ${j.registerUniform("output_size","u32").declareVariables(te,J)}

        ${j.mainStart()}
          ${j.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
          var input_indices: ${te.type.indices};
          let output_indices = ${J.offsetToIndices("global_idx")};

          ${Y.join(`
`)}
          ${ye[0]}       // init ops for reduce max/min
          ${ye[1]}
          ${ve}
          ${ye[3]}
          ${ye.length===4?J.setByOffset("global_idx","value"):ye.slice(4).join(`
`)}
        }`},getRunData:()=>({outputs:[{dims:_,dataType:c}],dispatchGroup:{x:Math.ceil(B/64)},programUniforms:[{type:12,data:B},...Tt(w,_)]})}},_l=(e,r)=>{let s=[];return e[1].dims[0]>0&&e[1].getBigInt64Array().forEach(i=>s.push(Number(i))),Ht({axes:s,keepDims:r.keepDims,noopWithEmptyAxes:r.noopWithEmptyAxes})},Is=(e,r,s,i)=>{let a=e.inputs,c=a.length===1?s:_l(a,s);e.compute(ml(r,{hint:c.cacheKey,inputDependencies:["rank"]},[a[0]],c.noopWithEmptyAxes&&c.axes.length===0?yd:i,c.axes,a[0].dataType,c.keepDims,c.noopWithEmptyAxes),{inputs:[0]})},wd=(e,r)=>{ss(e.inputs),Is(e,"ReduceLogSum",r,(s,i)=>[`var value = ${i.type.storage}(0);`,"",`value += ${s.getByIndices("input_indices")};`,"value = log(value);"])},Tu=(e,r)=>{ss(e.inputs),Is(e,"ReduceL1",r,(s,i)=>[`var value = ${i.type.storage}(0);`,"",`value += abs(${s.getByIndices("input_indices")});`,""])},vd=(e,r)=>{ss(e.inputs),Is(e,"ReduceL2",r,(s,i)=>[`var t = ${i.type.value}(0); var value = ${i.type.value}(0);`,"",`t = ${s.getByIndices("input_indices")}; value += (t * t);`,"value = sqrt(value);"])},gl=(e,r)=>{ss(e.inputs),Is(e,"ReduceLogSumExp",r,(s,i)=>[`var value = ${i.type.storage}(0);`,"",`value += exp(${s.getByIndices("input_indices")});`,"value = log(value);"])},Qo=(e,r)=>{ss(e.inputs),Is(e,"ReduceMax",r,(s,i,a)=>{let c=[];for(let l=0;l<s.rank;l++)(a.indexOf(l)>=0||a.length===0)&&c.push(s.indicesSet("input_indices",l,0));return[`${c.join(`
`)}`,`var value = ${s.getByIndices("input_indices")};`,`value = max(value, ${s.getByIndices("input_indices")});`,""]})},Md=(e,r)=>{ss(e.inputs),Is(e,"ReduceMean",r,(s,i,a)=>{let c=1;for(let l=0;l<s.rank;l++)(a.indexOf(l)>=0||a.length===0)&&(c*=e.inputs[0].dims[l]);return["var sum = f32(0);","",`sum += f32(${s.getByIndices("input_indices")});`,`let value = ${i.type.value}(sum / ${c});`]})},bu=(e,r)=>{ss(e.inputs),Is(e,"ReduceMin",r,(s,i,a)=>{let c=[];for(let l=0;l<s.rank;l++)(a.indexOf(l)>=0||a.length===0)&&c.push(`input_indices[${l}] = 0;`);return[`${c.join(`
`)}`,`var value = ${s.getByIndices("input_indices")};`,`value = min(value, ${s.getByIndices("input_indices")});`,""]})},yl=(e,r)=>{ss(e.inputs),Is(e,"ReduceProd",r,(s,i)=>[`var value = ${i.type.storage}(1);`,"",`value *= ${s.getByIndices("input_indices")};`,""])},Eu=(e,r)=>{ss(e.inputs),Is(e,"ReduceSum",r,(s,i)=>[`var value = ${i.type.storage}(0);`,"",`value += ${s.getByIndices("input_indices")};`,""])},Pu=(e,r)=>{ss(e.inputs),Is(e,"ReduceSumSquare",r,(s,i)=>[`var t = ${i.type.value}(0); var value = ${i.type.value}(0);`,"",`t = ${s.getByIndices("input_indices")}; value += t * t;`,""])},os=(e,r,s)=>{if(r.length===0)return s;let i=1,a=1;for(let c=0;c<r.length;c++)r.indexOf(c)===-1?i*=e[c]:a*=e[c];return a<32&&i>1024},Xo=(e,r)=>{os(e.inputs[0].dims,r.axes,r.noopWithEmptyAxes)?Md(e,r):pd(e,r)},xd=(e,r)=>{os(e.inputs[0].dims,r.axes,r.noopWithEmptyAxes)?Tu(e,r):fd(e,r)},Cu=(e,r)=>{os(e.inputs[0].dims,r.axes,r.noopWithEmptyAxes)?vd(e,r):fl(e,r)},Td=(e,r)=>{os(e.inputs[0].dims,r.axes,r.noopWithEmptyAxes)?gl(e,r):hd(e,r)},Su=(e,r)=>{os(e.inputs[0].dims,r.axes,r.noopWithEmptyAxes)?Qo(e,r):md(e,r)},wl=(e,r)=>{os(e.inputs[0].dims,r.axes,r.noopWithEmptyAxes)?bu(e,r):Mu(e,r)},Ii=(e,r)=>{os(e.inputs[0].dims,r.axes,r.noopWithEmptyAxes)?yl(e,r):_d(e,r)},Ai=(e,r)=>{os(e.inputs[0].dims,r.axes,r.noopWithEmptyAxes)?Eu(e,r):hl(e,r)},ku=(e,r)=>{os(e.inputs[0].dims,r.axes,r.noopWithEmptyAxes)?Pu(e,r):xu(e,r)},xa=(e,r)=>{os(e.inputs[0].dims,r.axes,r.noopWithEmptyAxes)?wd(e,r):gd(e,r)}}),Ta,vl,Ml,ba,bd=E(()=>{Rt(),hr(),$u(),Ta=e=>{if(!e||e.length===0||e.length>2)throw new Error("ArgMinMaxOp op requires 1 or 2 inputs.");if(e[0].dataType!==1)throw new Error("Invalid input type.")},vl=(e,r)=>{Ta(e.inputs);let s=(i,a,c)=>{let l=[];for(let h=0;h<i.rank;h++)(c.indexOf(h)>=0||c.length===0)&&l.push(`input_indices[${h}] = 0;`);return[`${l.join(`
`)}`,`var value = ${i.getByIndices("input_indices")};
var best_index : i32 = 0;`,`if (${i.getByIndices("input_indices")} ${r.selectLastIndex>0?"<=":"<"} value) {
         value = ${i.getByIndices("input_indices")};
         best_index = i32(last_index);
       }`,"",a.setByOffset("global_idx","best_index")]};e.compute(ml("ArgMin",{hint:r.cacheKey,inputDependencies:["rank"]},[e.inputs[0]],s,[r.axis],7,r.keepDims),{inputs:[0]})},Ml=(e,r)=>{Ta(e.inputs);let s=(i,a,c)=>{let l=[];for(let h=0;h<i.rank;h++)(c.indexOf(h)>=0||c.length===0)&&l.push(`input_indices[${h}] = 0;`);return[`${l.join(`
`)}`,`var value = ${i.getByIndices("input_indices")};
var best_index : i32 = 0;`,`if (${i.getByIndices("input_indices")} ${r.selectLastIndex>0?">=":">"} value) {
         value = ${i.getByIndices("input_indices")};
         best_index = i32(last_index);
       }`,"",a.setByOffset("global_idx","best_index")]};e.compute(ml("argMax",{hint:r.cacheKey,inputDependencies:["rank"]},[e.inputs[0]],s,[r.axis],7,r.keepDims),{inputs:[0]})},ba=e=>Ht(e)}),Iu,Au,Ed,Pd,Fi,Cd,_s,Do=E(()=>{Rt(),qt(),we(),or(),Iu=(e,r)=>{let s=e[0],i=e[1],a=e[2],c=e[3],l=e[4],h=e[5];if(l&&h)throw new Error("Attention cannot have both past and attention_bias");if(s.dims.length!==3)throw new Error('Input "input" must have 3 dimensions');let _=s.dims[0],w=s.dims[1],v=s.dims[2];if(a.dims.length!==1)throw new Error('Input "bias" is expected to have 1 dimensions');if(i.dims.length!==2)throw new Error('Input "weights" is expected to have 2 dimensions');if(i.dims[0]!==v)throw new Error("Input 1 dimension 0 should have same length as dimension 2 of input 0");if(a.dims[0]!==i.dims[1])throw new Error('Input "bias" dimension 0 should have same length as dimension 1 of input "weights"');let y=a.dims[0]/3,d=y,S=d;if(r.qkvHiddenSizes.length>0){if(r.qkvHiddenSizes.length!==3)throw new Error("qkv_hidden_sizes attribute should have 3 elements");for(let ye of r.qkvHiddenSizes)if(ye%r.numHeads!==0)throw new Error("qkv_hidden_sizes should be divisible by num_heads");y=r.qkvHiddenSizes[0],d=r.qkvHiddenSizes[1],S=r.qkvHiddenSizes[2]}let B=w;if(y!==d)throw new Error("qkv_hidden_sizes first element should be same as the second");if(a.dims[0]!==y+d+S)throw new Error('Input "bias" dimension 0 should have same length as sum of Q/K/V hidden sizes');let j=0;if(l){if(d!==S)throw new Error('Input "past" expect k_hidden_size == v_hidden_size');if(l.dims.length!==5)throw new Error('Input "past" must have 5 dimensions');if(l.dims[0]!==2)throw new Error('Input "past" first dimension must be 2');if(l.dims[1]!==_)throw new Error('Input "past" second dimension must be batch_size');if(l.dims[2]!==r.numHeads)throw new Error('Input "past" third dimension must be num_heads');if(l.dims[4]!==d/r.numHeads)throw new Error('Input "past" fifth dimension must be k_hidden_size / num_heads');r.pastPresentShareBuffer||(j=l.dims[3])}let Y=B+j,te=-1,J=0;if(c)throw new Error("Mask not supported");if(l)throw new Error("past is not supported");if(h){if(h.dims.length!==4)throw new Error('Input "attention_bias" must have 4 dimensions');if(h.dims[0]!==_||h.dims[1]!==r.numHeads||h.dims[2]!==w||h.dims[3]!==Y)throw new Error('Expect "attention_bias" shape (batch_size, num_heads, sequence_length, total_sequence_length)')}return{batchSize:_,sequenceLength:w,pastSequenceLength:j,kvSequenceLength:B,totalSequenceLength:Y,maxSequenceLength:te,inputHiddenSize:v,hiddenSize:y,vHiddenSize:S,headSize:Math.floor(y/r.numHeads),vHeadSize:Math.floor(S/r.numHeads),numHeads:r.numHeads,isUnidirectional:!1,pastPresentShareBuffer:!1,maskFilterValue:r.maskFilterValue,maskType:J,scale:r.scale,broadcastResPosBias:!1,passPastInKv:!1,qkvFormat:1}},Au=(e,r,s)=>{let i=Jt(s),a=64,c=s/i;c<a&&(a=32);let l=Math.ceil(s/i/a),h=[{type:1,data:1/s},{type:12,data:c},{type:12,data:l}],_=_r(e.dataType,i),w=$r(1,i),v=["type"],y=d=>{let S=Ut("x",e.dataType,e.dims,i),B=$r(e.dataType),j=[{name:"d_inv",type:"f32"},{name:"d_comp",type:"u32"},{name:"elements_per_thread",type:"u32"}];return`
  var<workgroup> thread_max: array<f32, ${a}>;
  var<workgroup> thread_sum: array<f32, ${a}>;
  ${d.registerUniforms(j).declareVariables(S)}
  ${d.mainStart([a,1,1])}
    let local_offset = local_idx * uniforms.elements_per_thread;
    let offset = (global_idx / ${a}) * uniforms.d_comp + local_offset;

    var thread_max_vector = ${w}(-3.402823e+38f);
    for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < uniforms.d_comp; i++) {
      thread_max_vector = max(${w}(x[offset + i]), thread_max_vector);
    }
    thread_max[local_idx] = ${(()=>{switch(i){case 1:return"thread_max_vector";case 2:return"max(thread_max_vector.x, thread_max_vector.y)";case 4:return"max(max(thread_max_vector.x, thread_max_vector.y), max(thread_max_vector.z, thread_max_vector.w))";default:throw new Error(`Unsupported components: ${i}`)}})()};
    workgroupBarrier();

    var max_value =  f32(-3.402823e+38f);
    for (var i = 0u; i < ${a}; i++) {
      max_value = max(thread_max[i], max_value);
    }

    var sum_vector = ${w}(0);
    for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < uniforms.d_comp; i++) {
      sum_vector += exp(${w}(x[offset + i]) - max_value);
    }
    thread_sum[local_idx] = ${(()=>{switch(i){case 1:return"sum_vector";case 2:return"sum_vector.x + sum_vector.y";case 4:return"sum_vector.x + sum_vector.y + sum_vector.z + sum_vector.w";default:throw new Error(`Unsupported components: ${i}`)}})()};
    workgroupBarrier();

    var sum: f32 = 0;
    for (var i = 0u; i < ${a}; i++) {
      sum += thread_sum[i];
    }

    if (sum == 0) {
      for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < uniforms.d_comp; i++) {
        x[offset + i] = ${S.type.value}(${B}(uniforms.d_inv));
      }
    } else {
      for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < uniforms.d_comp; i++) {
        var f32input = ${w}(x[offset + i]);
        x[offset + i] = ${S.type.value}(exp(f32input - max_value) / sum);
      }
    }
  }`};return{name:"AttentionProbsSoftmax",shaderCache:{hint:`${a};${_};${i}`,inputDependencies:v},getShaderSource:y,getRunData:()=>({outputs:[],dispatchGroup:{x:r},programUniforms:h})}},Ed=(e,r,s,i,a,c,l,h)=>{let _=h+c.kvSequenceLength,w=[c.batchSize,c.numHeads,c.sequenceLength,_],v=c.kvNumHeads===void 0&&e>1&&i,y=v?[c.batchSize,c.numHeads,_,c.headSize]:void 0,d=l.scale===0?1/Math.sqrt(c.headSize):l.scale,S=Jt(c.headSize),B=c.headSize/S,j=12,Y={x:Math.ceil(_/j),y:Math.ceil(c.sequenceLength/j),z:c.batchSize*c.numHeads},te=[{type:12,data:c.sequenceLength},{type:12,data:B},{type:12,data:_},{type:12,data:c.numHeads},{type:1,data:d},{type:12,data:h},{type:12,data:c.kvSequenceLength}],J=v&&i&&Qe.size(i.dims)>0,ye=["type","type"];J&&ye.push("type"),a&&ye.push("type");let ve=[{dims:w,dataType:r.dataType,gpuDataType:0}];v&&ve.push({dims:y,dataType:r.dataType,gpuDataType:0});let Ce=Ze=>{let Ke=it("q",r.dataType,r.dims,S),ft=it("key",s.dataType,s.dims,S),It=[Ke,ft];if(J){let Rr=it("past_key",i.dataType,i.dims,S);It.push(Rr)}a&&It.push(it("attention_bias",a.dataType,a.dims));let Bt=Ut("output",r.dataType,w),cr=[Bt];v&&cr.push(Ut("present_key",r.dataType,y,S));let fr=$r(1,S),Xt=[{name:"M",type:"u32"},{name:"K",type:"u32"},{name:"N",type:"u32"},{name:"num_heads",type:"u32"},{name:"alpha",type:"f32"},{name:"past_sequence_length",type:"u32"},{name:"kv_sequence_length",type:"u32"}];return`
  const TILE_SIZE = ${j}u;

  var<workgroup> tileQ: array<${Ke.type.storage}, ${j*j}>;
  var<workgroup> tileK: array<${Ke.type.storage}, ${j*j}>;
  ${Ze.registerUniforms(Xt).declareVariables(...It,...cr)}
  ${Ze.mainStart([j,j,1])}
    // x holds the N and y holds the M
    let headIdx = workgroup_id.z;
    let m = workgroup_id.y * TILE_SIZE;
    let n = workgroup_id.x * TILE_SIZE;
    let qOffset = uniforms.M * uniforms.K * headIdx + m * uniforms.K;
    ${J&&v?`
    let kOffset = uniforms.kv_sequence_length * uniforms.K * headIdx;
    let pastKeyOffset = uniforms.past_sequence_length * uniforms.K * headIdx;`:`
    let kOffset = uniforms.N * uniforms.K * headIdx + n * uniforms.K;`}
    ${v?"let presentKeyOffset = headIdx * uniforms.N * uniforms.K;":""}
    var value = ${fr}(0);
    for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {
      if (global_id.y < uniforms.M && w + local_id.x < uniforms.K) {
        tileQ[TILE_SIZE * local_id.y + local_id.x] = q[qOffset + local_id.y * uniforms.K + w + local_id.x];
      }
      if (n + local_id.y < uniforms.N && w + local_id.x < uniforms.K) {
        var idx = TILE_SIZE * local_id.y + local_id.x;
      ${J&&v?`
              if (n + local_id.y < uniforms.past_sequence_length) {
                tileK[idx] = past_key[pastKeyOffset + (n + local_id.y) * uniforms.K + w + local_id.x];
              } else {
                tileK[idx] =
                         key[kOffset + (n + local_id.y - uniforms.past_sequence_length) * uniforms.K + w + local_id.x];
              }`:"tileK[idx] = key[kOffset + local_id.y * uniforms.K + w + local_id.x];"}
      ${v?"present_key[presentKeyOffset + (n + local_id.y) * uniforms.K + w + local_id.x] = tileK[idx];":""}
      }
      workgroupBarrier();

      for (var k: u32 = 0u; k < TILE_SIZE && w+k < uniforms.K; k++) {
        value += ${fr}(tileQ[TILE_SIZE * local_id.y + k] * tileK[TILE_SIZE * local_id.x + k]);
      }

      workgroupBarrier();
    }

    let headOffset = headIdx * uniforms.M * uniforms.N;
    if (global_id.y < uniforms.M && global_id.x < uniforms.N) {
      let outputIdx = headOffset + global_id.y * uniforms.N + global_id.x;
      var sum: f32 = ${(()=>{switch(S){case 1:return"value";case 2:return"value.x + value.y";case 4:return"value.x + value.y + value.z + value.w";default:throw new Error(`Unsupported components: ${S}`)}})()};
        output[outputIdx] = ${Bt.type.value} (sum * uniforms.alpha) + ${a?"attention_bias[outputIdx]":"0.0"};
    }
  }`};return{name:"AttentionProbs",shaderCache:{hint:`${S};${a!==void 0};${i!==void 0};${e}`,inputDependencies:ye},getRunData:()=>({outputs:ve,dispatchGroup:Y,programUniforms:te}),getShaderSource:Ce}},Pd=(e,r,s,i,a,c)=>{let l=c+a.kvSequenceLength,h=a.nReps?a.nReps:1,_=a.vHiddenSize*h,w=a.kvNumHeads==null&&e>1&&i,v=w?[a.batchSize,a.numHeads,l,a.headSize]:void 0,y=[a.batchSize,a.sequenceLength,_],d=12,S={x:Math.ceil(a.vHeadSize/d),y:Math.ceil(a.sequenceLength/d),z:a.batchSize*a.numHeads},B=[{type:12,data:a.sequenceLength},{type:12,data:l},{type:12,data:a.vHeadSize},{type:12,data:a.numHeads},{type:12,data:_},{type:12,data:c},{type:12,data:a.kvSequenceLength}],j=w&&i&&Qe.size(i.dims)>0,Y=["type","type"];j&&Y.push("type");let te=[{dims:y,dataType:r.dataType,gpuDataType:0}];w&&te.push({dims:v,dataType:r.dataType,gpuDataType:0});let J=ye=>{let ve=it("probs",r.dataType,r.dims),Ce=it("v",s.dataType,s.dims),Ze=[ve,Ce];j&&Ze.push(it("past_value",i.dataType,i.dims));let Ke=[Ut("output",r.dataType,y)];w&&Ke.push(Ut("present_value",r.dataType,v));let ft=[{name:"M",type:"u32"},{name:"K",type:"u32"},{name:"N",type:"u32"},{name:"num_heads",type:"u32"},{name:"v_hidden_size",type:"u32"},{name:"past_sequence_length",type:"u32"},{name:"kv_sequence_length",type:"u32"}];return`
  const TILE_SIZE = ${d}u;
  var<workgroup> tileQ: array<${ve.type.value}, ${d*d}>;
  var<workgroup> tileK: array<${ve.type.value}, ${d*d}>;
  ${ye.registerUniforms(ft).declareVariables(...Ze,...Ke)}
  ${ye.mainStart([d,d,1])}
   let headIdx = workgroup_id.z;
   let m = global_id.y;
   let n = global_id.x;

   let offsetA = headIdx * (uniforms.M * uniforms.K) + m * uniforms.K;
   ${j&&w?`
    let pastValueOffset = headIdx * uniforms.N * uniforms.past_sequence_length + n;
    let vOffset = headIdx * uniforms.N * uniforms.kv_sequence_length + n;
      `:`
   let offsetB = headIdx * uniforms.N * uniforms.K + n;
            `}
    ${w?"let presentValueOffset = headIdx * uniforms.N * uniforms.K + n;":""}
   var value = ${ve.type.storage}(0);
   for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {
      if (m < uniforms.M && w + local_id.x < uniforms.K) {
        tileQ[TILE_SIZE * local_id.y + local_id.x] = probs[offsetA + w + local_id.x];
      }
      if (n < uniforms.N && w + local_id.y < uniforms.K) {
        var idx = TILE_SIZE * local_id.y + local_id.x;
        ${j&&w?`
        if (w + local_id.y < uniforms.past_sequence_length) {
          tileK[idx] = past_value[pastValueOffset + (w + local_id.y) * uniforms.N];
        } else {
          tileK[idx] = v[vOffset + (w + local_id.y - uniforms.past_sequence_length) * uniforms.N];
        }
      `:`
        tileK[idx] = v[offsetB + (w + local_id.y) * uniforms.N];
      `}
        ${w?"present_value[presentValueOffset + (w + local_id.y) * uniforms.N] = tileK[idx];":""}
      }
     workgroupBarrier();
     for (var k: u32 = 0u; k < TILE_SIZE && w+k < uniforms.K; k++) {
       value += tileQ[TILE_SIZE * local_id.y + k] * tileK[TILE_SIZE * k + local_id.x];
     }
     workgroupBarrier();
   }

   // we need to transpose output from BNSH_v to BSND_v
   let batchIdx = workgroup_id.z / uniforms.num_heads;
   let currentBatchHeadNumber = workgroup_id.z % uniforms.num_heads;
   if (m < uniforms.M && n < uniforms.N) {
     let outputIdx = batchIdx * uniforms.M * uniforms.v_hidden_size + m * uniforms.v_hidden_size
       + currentBatchHeadNumber * uniforms.N + n;
     output[outputIdx] = value;
   }
  }`};return{name:"AttentionScore",shaderCache:{hint:`${i!==void 0};${e}`,inputDependencies:Y},getRunData:()=>({outputs:te,dispatchGroup:S,programUniforms:B}),getShaderSource:J}},Fi=(e,r,s,i,a,c,l,h,_,w,v)=>{let y=Math.min(e.outputCount,1+(l?1:0)+(h?1:0)),d=w.kvNumHeads!==void 0||y>1?w.pastSequenceLength:0,S=d+w.kvSequenceLength,B=_&&Qe.size(_.dims)>0?_:void 0,j=[r,s];w.kvNumHeads===void 0&&y>1&&l&&Qe.size(l.dims)>0&&j.push(l),B&&j.push(B);let Y=e.compute(Ed(y,r,s,l,B,w,v,d),{inputs:j,outputs:w.kvNumHeads===void 0&&y>1?[-1,1]:[-1]})[0];e.compute(Au(Y,w.batchSize*w.numHeads*w.sequenceLength,S),{inputs:[Y],outputs:[]});let te=[Y,i];w.kvNumHeads===void 0&&y>1&&h&&Qe.size(h.dims)>0&&te.push(h),e.compute(Pd(y,Y,i,h,w,d),{inputs:te,outputs:w.kvNumHeads===void 0&&y>1?[0,2]:[0]})},Cd=(e,r)=>{let s=[r.batchSize,r.numHeads,r.sequenceLength,r.headSize],i=r.sequenceLength,a=r.inputHiddenSize,c=r.headSize,l=12,h={x:Math.ceil(r.headSize/l),y:Math.ceil(r.sequenceLength/l),z:r.batchSize*r.numHeads},_=[e.inputs[0],e.inputs[1],e.inputs[2]],w=[{type:12,data:i},{type:12,data:a},{type:12,data:c},{type:12,data:r.numHeads},{type:12,data:r.headSize},{type:12,data:r.hiddenSize},{type:12,data:r.hiddenSize+r.hiddenSize+r.vHiddenSize}],v=y=>{let d=Ut("output_q",_[0].dataType,s),S=Ut("output_k",_[0].dataType,s),B=Ut("output_v",_[0].dataType,s),j=it("input",_[0].dataType,_[0].dims),Y=it("weight",_[1].dataType,_[1].dims),te=it("bias",_[2].dataType,_[2].dims),J=j.type.storage,ye=[{name:"M",type:"u32"},{name:"K",type:"u32"},{name:"N",type:"u32"},{name:"num_heads",type:"u32"},{name:"head_size",type:"u32"},{name:"hidden_size",type:"u32"},{name:"ldb",type:"u32"}];return`
  const TILE_SIZE = ${l}u;
  var<workgroup> tileInput: array<${J}, ${l*l}>;
  var<workgroup> tileWeightQ: array<${J}, ${l*l}>;
  var<workgroup> tileWeightK: array<${J}, ${l*l}>;
  var<workgroup> tileWeightV: array<${J}, ${l*l}>;
  ${y.registerUniforms(ye).declareVariables(j,Y,te,d,S,B)}
  ${y.mainStart([l,l,1])}
    let batchIndex = workgroup_id.z / uniforms.num_heads;
    let headNumber = workgroup_id.z % uniforms.num_heads;
    let m = global_id.y;
    let n = global_id.x;

    let inputOffset = batchIndex * (uniforms.M * uniforms.K) + m * uniforms.K;
    let biasOffsetQ = headNumber * uniforms.head_size;
    let biasOffsetK = uniforms.hidden_size + biasOffsetQ;
    let biasOffsetV = uniforms.hidden_size + biasOffsetK;

    var valueQ = ${J}(0);
    var valueK = ${J}(0);
    var valueV = ${J}(0);
    for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {
      if (m < uniforms.M && w + local_id.x < uniforms.K) {
        tileInput[TILE_SIZE * local_id.y + local_id.x] = input[inputOffset + w + local_id.x];
      }
      if (n < uniforms.N && w + local_id.y < uniforms.K) {
        let offset = n + (w + local_id.y) * uniforms.ldb;
        tileWeightQ[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetQ + offset];
        tileWeightK[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetK + offset];
        tileWeightV[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetV + offset];
      }
      workgroupBarrier();
      for (var k: u32 = 0u; k<TILE_SIZE && w+k < uniforms.K; k++) {
        let inputTileOffset = TILE_SIZE * local_id.y + k;
        let weightTileOffset = TILE_SIZE * k + local_id.x;
        valueQ += tileInput[inputTileOffset] * tileWeightQ[weightTileOffset];
        valueK += tileInput[inputTileOffset] * tileWeightK[weightTileOffset];
        valueV += tileInput[inputTileOffset] * tileWeightV[weightTileOffset];
      }

      workgroupBarrier();
    }

    let headOffset = (m * uniforms.N + n) % uniforms.head_size;
    valueQ += bias[headOffset + biasOffsetQ];
    valueK += bias[headOffset + biasOffsetK];
    valueV += bias[headOffset + biasOffsetV];

    let offset = workgroup_id.z * uniforms.M * uniforms.N;
    if (m < uniforms.M && n < uniforms.N) {
      let outputIdx = offset + m * uniforms.N + n;
      output_q[outputIdx] = valueQ;
      output_k[outputIdx] = valueK;
      output_v[outputIdx] = valueV;
    }
  }`};return e.compute({name:"AttentionPrepare",shaderCache:{inputDependencies:["type","type","type"]},getRunData:()=>({outputs:[{dims:s,dataType:e.inputs[0].dataType,gpuDataType:0},{dims:s,dataType:e.inputs[0].dataType,gpuDataType:0},{dims:s,dataType:e.inputs[0].dataType,gpuDataType:0}],dispatchGroup:h,programUniforms:w}),getShaderSource:v},{inputs:_,outputs:[-1,-1,-1]})},_s=(e,r)=>{let s=Iu(e.inputs,r),[i,a,c]=Cd(e,s);return Fi(e,i,a,c,e.inputs[4],void 0,void 0,void 0,e.inputs[5],s,r)}}),Fu,Ou,Lu,Du,xl=E(()=>{St(),Rt(),qt(),hr(),or(),Fu=(e,r)=>{if(!e||e.length!==5)throw new Error("BatchNormalization requires 5 inputs");let s=(i,a,c)=>{let l=a.length;if(l!==i.length)throw new Error(`${c}: num dimensions != ${l}`);a.forEach((h,_)=>{if(h!==i[_])throw new Error(`${c}: dim[${_}] do not match`)})};if(e[0].dims.length>1){let i=r.format==="NHWC"?r.spatial?e[0].dims.slice(-1):e[0].dims.slice(-1).concat(e[0].dims.slice(1,e[0].dims.length-1)):e[0].dims.slice(1,r.spatial?2:void 0);s(e[1].dims,i,"Invalid input scale"),s(e[2].dims,i,"Invalid input B"),s(e[3].dims,i,"Invalid input mean"),s(e[4].dims,i,"Invalid input var")}else s(e[1].dims,[1],"Invalid input scale"),s(e[2].dims,[1],"Invalid input B"),s(e[3].dims,[1],"Invalid input mean"),s(e[4].dims,[1],"Invalid input var")},Ou=(e,r)=>{let{epsilon:s,spatial:i,format:a}=r,c=e[0].dims,l=i?Jt(c[c.length-1]):1,h=a==="NHWC"&&c.length>1?l:1,_=Qe.size(c)/l,w=i,v=w?c.length:c,y=it("x",e[0].dataType,e[0].dims,l),d=it("scale",e[1].dataType,e[1].dims,h),S=it("bias",e[2].dataType,e[2].dims,h),B=it("inputMean",e[3].dataType,e[3].dims,h),j=it("inputVar",e[4].dataType,e[4].dims,h),Y=Ut("y",e[0].dataType,v,l),te=()=>{let ye="";if(i)ye=`let cOffset = ${c.length===1?"0u":a==="NHWC"?`outputIndices[${c.length-1}] / ${l}`:"outputIndices[1]"};`;else if(a==="NCHW")ye=`
            ${Y.indicesSet("outputIndices","0","0")}
            let cOffset = ${Y.indicesToOffset("outputIndices")};`;else{ye=`var cIndices = ${d.type.indices}(0);
                       cIndices[0] = outputIndices[${c.length-1}];`;for(let ve=1;ve<d.rank;ve++)ye+=`cIndices[${ve}] = outputIndices[${ve}];`;ye+=`let cOffset = ${d.indicesToOffset("cIndices")};`}return ye},J=ye=>`
  const epsilon = ${s};
  ${ye.registerUniform("outputSize","u32").declareVariables(y,d,S,B,j,Y)}
  ${ye.mainStart()}
  ${ye.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
    var outputIndices = ${Y.offsetToIndices(`global_idx * ${l}`)};
    ${te()}
    let scale = ${d.getByOffset("cOffset")};
    let bias = ${S.getByOffset("cOffset")};
    let inputMean = ${B.getByOffset("cOffset")};
    let inputVar = ${j.getByOffset("cOffset")};
    let x = ${y.getByOffset("global_idx")};
    let value = (x - inputMean) * inverseSqrt(inputVar + epsilon) * scale + bias;
    ${Y.setByOffset("global_idx","value")}
  }`;return{name:"BatchNormalization",shaderCache:{hint:`${r.epsilon}_${r.format}_${i}_${l}`,inputDependencies:w?["rank","type","type","type","type"]:void 0},getShaderSource:J,getRunData:()=>({outputs:[{dims:e[0].dims,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(_/64)},programUniforms:w?[{type:12,data:_},...Tt(c)]:[{type:12,data:_}]})}},Lu=e=>Ht(e),Du=(e,r)=>{let{inputs:s,outputCount:i}=e,a=Lu({...r,outputCount:i});if(L.webgpu.validateInputContent&&Fu(s,a),r.trainingMode)throw new Error("BatchNormalization trainingMode is not supported yet.");e.compute(Ou(s,a))}}),Sd,kd,zo,zu=E(()=>{qt(),or(),Sd=e=>{if(e[0].dims.length!==3)throw new Error("input should have 3 dimensions");if(![320,640,1280].includes(e[0].dims[2]))throw new Error("number of channels should be 320, 640 or 1280");if(e[1].dims.length!==1)throw new Error("bias is expected to have 1 dimensions");if(e[0].dims[2]!==e[1].dims[0])throw new Error("last dimension of input and bias are not the same")},kd=e=>{let r=e[0].dims,s=e[0].dims[2],i=Qe.size(r)/4,a=e[0].dataType,c=it("input",a,r,4),l=it("bias",a,[s],4),h=it("residual",a,r,4),_=Ut("output",a,r,4);return{name:"BiasAdd",getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(i/64)}}),getShaderSource:w=>`
  const channels = ${s}u / 4;
  ${w.declareVariables(c,l,h,_)}

  ${w.mainStart()}
    ${w.guardAgainstOutOfBoundsWorkgroupSizes(i)}
    let value = ${c.getByOffset("global_idx")}
      + ${l.getByOffset("global_idx % channels")} + ${h.getByOffset("global_idx")};
    ${_.setByOffset("global_idx","value")}
  }`}},zo=e=>{Sd(e.inputs),e.compute(kd(e.inputs))}}),Oi,wr,Bu,Ea,Bo,Tl,Ru,Li,ju,Nu,bl,Uu,Vu,Wu,_o,Pa,Yo,$d,El,Di,Gu,Ku,Hu,Gr,Pl,zi,Bi,qu,Cl,Ri,ji,Jo,Qu,Xu,Id,Sl,Ni,Ui,Ca,Sa,kl,$l,Yu,Ju,Ad,ka=E(()=>{Rt(),qt(),hr(),or(),Oi=(e,r,s,i,a,c,l)=>{let h=Math.ceil(r/4),_="";typeof a=="string"?_=`${a}(a)`:_=a("a");let w=it("inputData",s,[h],4),v=Ut("outputData",i,[h],4),y=[{name:"vec_size",type:"u32"}];return l&&y.push(...l),`
      ${e.registerUniforms(y).declareVariables(w,v)}

  ${c??""}

  ${e.mainStart()}
    ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}

    let a = ${w.getByOffset("global_idx")};
    ${v.setByOffset("global_idx",_)}
  }`},wr=(e,r,s,i,a,c=e.dataType,l,h)=>{let _=[{type:12,data:Math.ceil(Qe.size(e.dims)/4)}];return l&&_.push(...l),{name:r,shaderCache:{hint:a,inputDependencies:["type"]},getShaderSource:w=>Oi(w,Qe.size(e.dims),e.dataType,c,s,i,h),getRunData:w=>({outputs:[{dims:e.dims,dataType:c}],dispatchGroup:{x:Math.ceil(Qe.size(w[0].dims)/64/4)},programUniforms:_})}},Bu=e=>{e.compute(wr(e.inputs[0],"Abs","abs"))},Ea=e=>{e.compute(wr(e.inputs[0],"Acos","acos"))},Bo=e=>{e.compute(wr(e.inputs[0],"Acosh","acosh"))},Tl=e=>{e.compute(wr(e.inputs[0],"Asin","asin"))},Ru=e=>{e.compute(wr(e.inputs[0],"Asinh","asinh"))},Li=e=>{e.compute(wr(e.inputs[0],"Atan","atan"))},ju=e=>{e.compute(wr(e.inputs[0],"Atanh","atanh"))},Nu=e=>Ht(e),bl=(e,r)=>{let s;switch(r.to){case 10:s="vec4<f16>";break;case 1:s="vec4<f32>";break;case 12:s="vec4<u32>";break;case 6:s="vec4<i32>";break;case 9:s="vec4<bool>";break;default:throw new RangeError(`not supported type (specified in attribute 'to' from 'Cast' operator): ${r.to}`)}e.compute(wr(e.inputs[0],"Cast",s,void 0,r.cacheKey,r.to))},Uu=e=>{let r,s,i=e.length>=2&&e[1].data!==0,a=e.length>=3&&e[2].data!==0;switch(e[0].dataType){case 1:r=i?e[1].getFloat32Array()[0]:-34028234663852886e22,s=a?e[2].getFloat32Array()[0]:34028234663852886e22;break;case 10:r=i?e[1].getUint16Array()[0]:64511,s=a?e[2].getUint16Array()[0]:31743;break;default:throw new Error("Unsupport data type")}return Ht({min:r,max:s})},Vu=(e,r)=>{let s=r||Uu(e.inputs),i=$r(e.inputs[0].dataType);e.compute(wr(e.inputs[0],"Clip",a=>`clamp(${a}, vec4<${i}>(uniforms.min), vec4<${i}>(uniforms.max))`,void 0,s.cacheKey,void 0,[{type:e.inputs[0].dataType,data:s.min},{type:e.inputs[0].dataType,data:s.max}],[{name:"min",type:i},{name:"max",type:i}]),{inputs:[0]})},Wu=e=>{e.compute(wr(e.inputs[0],"Ceil","ceil"))},_o=e=>{e.compute(wr(e.inputs[0],"Cos","cos"))},Pa=e=>{e.compute(wr(e.inputs[0],"Cosh","cosh"))},Yo=e=>Ht(e),$d=(e,r)=>{let s=$r(e.inputs[0].dataType);e.compute(wr(e.inputs[0],"Elu",i=>`elu_vf32(${i})`,`
  const elu_alpha_ = ${s}(${r.alpha});

  fn elu_f32(a: ${s}) -> ${s} {
  return select((exp(a) - 1.0) * elu_alpha_, a, a >= 0.0);
  }

  fn elu_vf32(v: vec4<${s}>) -> vec4<${s}> {
  return vec4(elu_f32(v.x), elu_f32(v.y), elu_f32(v.z), elu_f32(v.w));
  }`,r.cacheKey))},El=(e="f32")=>`
const r0: ${e} = 0.3275911;
const r1: ${e} = 0.254829592;
const r2: ${e} = -0.284496736;
const r3: ${e} = 1.421413741;
const r4: ${e} = -1.453152027;
const r5: ${e} = 1.061405429;

fn erf_vf32(v: vec4<${e}>) -> vec4<${e}> {
  let absv = abs(v);
  let x = 1.0 / (1.0 + r0 * absv);
  return sign(v) * (1.0 - ((((r5 * x + r4) * x + r3) * x + r2) * x + r1) * x * exp(-absv * absv));
}`,Di=e=>{let r=$r(e.inputs[0].dataType);e.compute(wr(e.inputs[0],"Erf",s=>`erf_vf32(${s})`,El(r)))},Gu=e=>{e.compute(wr(e.inputs[0],"Exp","exp"))},Ku=e=>{e.compute(wr(e.inputs[0],"Floor","floor"))},Hu=e=>{let r=$r(e.inputs[0].dataType);e.compute(wr(e.inputs[0],"Gelu",s=>`0.5 * ${s} * (1.0 + erf_vf32(${s} * 0.7071067811865475))`,El(r)))},Gr=(e,r)=>{let s=$r(e.inputs[0].dataType);e.compute(wr(e.inputs[0],"LeakyRelu",i=>`select(leaky_relu_alpha_ * ${i}, ${i}, ${i} >= vec4<${s}>(0.0))`,`const leaky_relu_alpha_ = ${s}(${r.alpha});`,r.cacheKey))},Pl=e=>{e.compute(wr(e.inputs[0],"Not",r=>`!${r}`))},zi=e=>{e.compute(wr(e.inputs[0],"Neg",r=>`-${r}`))},Bi=e=>{e.compute(wr(e.inputs[0],"Reciprocal",r=>`1.0/${r}`))},qu=e=>{let r=$r(e.inputs[0].dataType);e.compute(wr(e.inputs[0],"Relu",s=>`select(vec4<${r}>(0.0), ${s}, ${s} > vec4<${r}>(0.0))`))},Cl=e=>{e.compute(wr(e.inputs[0],"Sigmoid",r=>`(1.0 / (1.0 + exp(-${r})))`))},Ri=e=>Ht(e),ji=(e,r)=>{let s=$r(e.inputs[0].dataType);e.compute(wr(e.inputs[0],"HardSigmoid",i=>`max(vec4<${s}>(0.0), min(vec4<${s}>(1.0), ${r.alpha} * ${i} + vec4<${s}>(${r.beta})))`,void 0,r.cacheKey))},Jo=e=>{e.compute(wr(e.inputs[0],"Sin","sin"))},Qu=e=>{e.compute(wr(e.inputs[0],"Sinh","sinh"))},Xu=e=>{e.compute(wr(e.inputs[0],"Sqrt","sqrt"))},Id=e=>{e.compute(wr(e.inputs[0],"Tan","tan"))},Sl=e=>`sign(${e}) * (1 - exp(-2 * abs(${e}))) / (1 + exp(-2 * abs(${e})))`,Ni=e=>{e.compute(wr(e.inputs[0],"Tanh",Sl))},Ui=(e="f32")=>`
const fast_gelu_a: ${e} = 0.5;
const fast_gelu_b: ${e} = 0.7978845608028654;
const fast_gelu_c: ${e} = 0.035677408136300125;

fn tanh_v(v: vec4<${e}>) -> vec4<${e}> {
  return ${Sl("v")};
}
`,Ca=e=>`(fast_gelu_a + fast_gelu_a * tanh_v(${e} * (fast_gelu_c * ${e} * ${e} + fast_gelu_b))) * ${e}`,Sa=e=>{let r=$r(e.inputs[0].dataType);e.compute(wr(e.inputs[0],"FastGelu",Ca,Ui(r),void 0,e.inputs[0].dataType))},kl=(e,r)=>{let s=$r(e.inputs[0].dataType);return e.compute(wr(e.inputs[0],"ThresholdedRelu",i=>`select(vec4<${s}>(0.0), ${i}, ${i} > thresholded_relu_alpha_)`,`const thresholded_relu_alpha_ = vec4<${s}>(${r.alpha});`,r.cacheKey)),0},$l=e=>{e.compute(wr(e.inputs[0],"Log","log"))},Yu=(e,r)=>`
const alpha = vec4<${e}>(${r});
const one = ${e}(1.0);
const zero = ${e}(0.0);

fn quick_gelu_impl(x: vec4<${e}>) -> vec4<${e}> {
  let v = x *alpha;
  var x1 : vec4<${e}>;
  for (var i = 0; i < 4; i = i + 1) {
    if (v[i] >= zero) {
      x1[i] = one / (one + exp(-v[i]));
    } else {
      x1[i] = one - one / (one + exp(v[i]));
    }
  }
  return x * x1;
}
`,Ju=e=>`quick_gelu_impl(${e})`,Ad=(e,r)=>{let s=$r(e.inputs[0].dataType);e.compute(wr(e.inputs[0],"QuickGelu",Ju,Yu(s,r.alpha),r.cacheKey,e.inputs[0].dataType))}}),Il,go,Al,Zo=E(()=>{qt(),or(),ka(),Il=e=>{if(e[0].dims.length!==3)throw new Error("input should have 3 dimensions");if(![2560,5120,10240].includes(e[0].dims[2]))throw new Error("hidden state should be 2560, 5120 or 10240");if(e[1].dims.length!==1)throw new Error("bias is expected to have 1 dimensions");if(e[0].dims[2]!==e[1].dims[0])throw new Error("last dimension of input and bias are not the same")},go=e=>{let r=e[0].dims.slice();r[2]=r[2]/2;let s=it("input",e[0].dataType,e[0].dims,4),i=it("bias",e[0].dataType,[e[0].dims[2]],4),a=Ut("output",e[0].dataType,r,4),c=Qe.size(r)/4,l=_r(e[0].dataType);return{name:"BiasSplitGelu",getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(c/64)}}),getShaderSource:h=>`
  const M_SQRT2 = sqrt(2.0);
  const halfChannels = ${e[0].dims[2]/4/2}u;

  ${h.declareVariables(s,i,a)}

  ${El(l)}

  ${h.mainStart()}
    ${h.guardAgainstOutOfBoundsWorkgroupSizes(c)}
    let biasIdx = global_idx % halfChannels;
    let batchIndex = global_idx / halfChannels;
    let inputOffset = biasIdx + batchIndex * halfChannels * 2;
    let valueLeft = input[inputOffset] + bias[biasIdx];
    let valueRight = input[inputOffset + halfChannels] + bias[biasIdx + halfChannels];
    let geluRight = valueRight * 0.5 * (erf_vf32(valueRight / M_SQRT2) + 1);

    ${a.setByOffset("global_idx","valueLeft * geluRight")}
  }`}},Al=e=>{Il(e.inputs),e.compute(go(e.inputs))}}),As,ei,yn,Fl,Fd,Zu,Ro,Vi,ti,Wi,Ol,ri,Qs,Zr=E(()=>{Rt(),qt(),or(),As=(e,r,s,i,a,c,l,h,_,w,v,y)=>{let d,S;typeof h=="string"?d=S=(J,ye)=>`${h}((${J}),(${ye}))`:typeof h=="function"?d=S=h:(d=h.scalar,S=h.vector);let B=Ut("outputData",v,i.length,4),j=it("aData",_,r.length,4),Y=it("bData",w,s.length,4),te;if(a)if(c){let J=Qe.size(r)===1,ye=Qe.size(s)===1,ve=r.length>0&&r[r.length-1]%4===0,Ce=s.length>0&&s[s.length-1]%4===0;J||ye?te=B.setByOffset("global_idx",S(J?`${j.type.value}(${j.getByOffset("0")}.x)`:j.getByOffset("global_idx"),ye?`${Y.type.value}(${Y.getByOffset("0")}.x)`:Y.getByOffset("global_idx"))):te=`
            let outputIndices = ${B.offsetToIndices("global_idx * 4u")};
            let offsetA = ${j.broadcastedIndicesToOffset("outputIndices",B)};
            let offsetB = ${Y.broadcastedIndicesToOffset("outputIndices",B)};
            ${B.setByOffset("global_idx",S(l||ve?j.getByOffset("offsetA / 4u"):`${j.type.value}(${j.getByOffset("offsetA / 4u")}[offsetA % 4u])`,l||Ce?Y.getByOffset("offsetB / 4u"):`${Y.type.value}(${Y.getByOffset("offsetB / 4u")}[offsetB % 4u])`))}
          `}else te=B.setByOffset("global_idx",S(j.getByOffset("global_idx"),Y.getByOffset("global_idx")));else{if(!c)throw new Error("no necessary to use scalar implementation for element-wise binary op implementation.");let J=(ye,ve,Ce="")=>{let Ze=`aData[indexA${ve}][componentA${ve}]`,Ke=`bData[indexB${ve}][componentB${ve}]`;return`
            let outputIndices${ve} = ${B.offsetToIndices(`global_idx * 4u + ${ve}u`)};
            let offsetA${ve} = ${j.broadcastedIndicesToOffset(`outputIndices${ve}`,B)};
            let offsetB${ve} = ${Y.broadcastedIndicesToOffset(`outputIndices${ve}`,B)};
            let indexA${ve} = offsetA${ve} / 4u;
            let indexB${ve} = offsetB${ve} / 4u;
            let componentA${ve} = offsetA${ve} % 4u;
            let componentB${ve} = offsetB${ve} % 4u;
            ${ye}[${ve}] = ${Ce}(${d(Ze,Ke)});
          `};v===9?te=`
            var data = vec4<u32>(0);
            ${J("data",0,"u32")}
            ${J("data",1,"u32")}
            ${J("data",2,"u32")}
            ${J("data",3,"u32")}
            outputData[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:te=`
            ${J("outputData[global_idx]",0)}
            ${J("outputData[global_idx]",1)}
            ${J("outputData[global_idx]",2)}
            ${J("outputData[global_idx]",3)}
          `}return`
        ${e.registerUniform("vec_size","u32").declareVariables(j,Y,B)}

        ${y??""}

        ${e.mainStart()}
        ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}
        ${te}
      }`},ei=(e,r,s,i,a,c,l=s.dataType)=>{let h=!Qe.areEqual(s.dims,i.dims),_=s.dims,w=Qe.size(s.dims),v=!1,y=!1,d=[h];if(h){let S=Nr.calcShape(s.dims,i.dims,!1);if(!S)throw new Error("Can't perform binary op on the given tensors");_=S,w=Qe.size(_);let B=Qe.size(s.dims)===1,j=Qe.size(i.dims)===1,Y=s.dims.length>0&&s.dims[s.dims.length-1]%4===0,te=i.dims.length>0&&i.dims[i.dims.length-1]%4===0;d.push(B),d.push(j),d.push(Y),d.push(te);let J=1;for(let ye=1;ye<_.length;ye++){let ve=s.dims[s.dims.length-ye]??1,Ce=i.dims[i.dims.length-ye]??1;if(ve===Ce)J*=ve;else break}J%4===0?(y=!0,v=!0):(B||j||Y||te)&&(v=!0)}else v=!0;return d.push(v),{name:e,shaderCache:{hint:r+d.map(S=>S.toString()).join("_"),inputDependencies:["rank","rank"]},getShaderSource:S=>As(S,s.dims,i.dims,_,v,h,y,a,s.dataType,i.dataType,l,c),getRunData:()=>({outputs:[{dims:_,dataType:l}],dispatchGroup:{x:Math.ceil(w/64/4)},programUniforms:[{type:12,data:Math.ceil(Qe.size(_)/4)},...Tt(s.dims,i.dims,_)]})}},yn=(e,r,s,i,a,c)=>{e.compute(ei(r,a??"",e.inputs[0],e.inputs[1],s,i,c))},Fl=e=>{yn(e,"Add",(r,s)=>`${r}+${s}`)},Fd=e=>{yn(e,"Div",(r,s)=>`${r}/${s}`)},Zu=e=>{yn(e,"Equal",{scalar:(r,s)=>`u32(${r}==${s})`,vector:(r,s)=>`vec4<u32>(${r}==${s})`},void 0,void 0,9)},Ro=e=>{yn(e,"Mul",(r,s)=>`${r}*${s}`)},Vi=e=>{let r=it("input",e.inputs[0].dataType,e.inputs[0].dims).type.value;yn(e,"Pow",{scalar:(s,i)=>`pow_custom(${s},${i})`,vector:(s,i)=>`pow_vector_custom(${s},${i})`},`
    fn pow_custom(a : ${r}, b : ${r}) -> ${r} {
      if (b == ${r}(0.0)) {
        return ${r}(1.0);
      } else if (a < ${r}(0.0) && f32(b) != floor(f32(b))) {
        return ${r}(pow(f32(a), f32(b))); // NaN
      }
      return select(sign(a), ${r}(1.0), round(f32(abs(b) % ${r}(2.0))) != 1.0) * ${r}(${r==="i32"?"round":""}(pow(f32(abs(a)), f32(b))));
    }
    fn pow_vector_custom(a : vec4<${r}>, b : vec4<${r}>) -> vec4<${r}> {
      // TODO: implement vectorized pow
      return vec4<${r}>(pow_custom(a.x, b.x), pow_custom(a.y, b.y), pow_custom(a.z, b.z), pow_custom(a.w, b.w));
    }
      `)},ti=e=>{yn(e,"Sub",(r,s)=>`${r}-${s}`)},Wi=e=>{yn(e,"Greater",{scalar:(r,s)=>`u32(${r}>${s})`,vector:(r,s)=>`vec4<u32>(${r}>${s})`},void 0,void 0,9)},Ol=e=>{yn(e,"Less",{scalar:(r,s)=>`u32(${r}<${s})`,vector:(r,s)=>`vec4<u32>(${r}<${s})`},void 0,void 0,9)},ri=e=>{yn(e,"GreaterOrEqual",{scalar:(r,s)=>`u32(${r}>=${s})`,vector:(r,s)=>`vec4<u32>(${r}>=${s})`},void 0,void 0,9)},Qs=e=>{yn(e,"LessOrEqual",{scalar:(r,s)=>`u32(${r}<=${s})`,vector:(r,s)=>`vec4<u32>(${r}<=${s})`},void 0,void 0,9)}}),Ur,Xs,kn,Vn,yo,ni,Yn=E(()=>{Rt(),qt(),hr(),or(),Ur=(e,r)=>{if(!e||e.length<1)throw new Error("too few inputs");let s=0,i=e[s],a=i.dataType,c=i.dims.length;e.forEach((l,h)=>{if(h!==s){if(l.dataType!==a)throw new Error("input tensors should be one type");if(l.dims.length!==c)throw new Error("input tensors should have the same shape");l.dims.forEach((_,w)=>{if(w!==r&&_!==i.dims[w])throw new Error("non concat dimensions must match")})}})},Xs=(e,r)=>`
  fn calculateInputIndex(index: u32) -> u32 {
    let sizeInConcatAxis = array<u32, ${e}u>(${r});
    for (var i: u32 = 0u; i < ${e}; i += 1u ) {
      if (index < sizeInConcatAxis[i]) {
        return i;
      }
    }
    return ${e}u;
  }`,kn=(e,r)=>{let s=e.length,i=[];for(let a=0;a<s;++a){let c=r.setByOffset("global_idx",e[a].getByIndices("indices"));s===1?i.push(c):a===0?i.push(`if (inputIndex == ${a}u) { ${c} }`):a===s-1?i.push(`else { ${c} }`):i.push(`else if (inputIndex == ${a}) { ${c} }`)}return i.join(`
`)},Vn=(e,r,s,i)=>{let a=Qe.size(s),c=new Array(e.length),l=new Array(e.length),h=0,_=[],w=[],v=[{type:12,data:a}];for(let j=0;j<e.length;++j)h+=e[j].dims[r],c[j]=h,w.push(e[j].dims.length),l[j]=it(`input${j}`,i,w[j]),_.push("rank"),v.push({type:12,data:c[j]});for(let j=0;j<e.length;++j)v.push(...Tt(e[j].dims));v.push(...Tt(s));let y=Ut("output",i,s.length),d=y.indicesGet("indices",r),S=Array.from(Array(c.length).keys()).map(j=>`uniforms.sizeInConcatAxis${j}`).join(","),B=j=>`

  ${(()=>{j.registerUniform("outputSize","u32");for(let Y=0;Y<e.length;Y++)j.registerUniform(`sizeInConcatAxis${Y}`,"u32");return j.declareVariables(...l,y)})()}

  ${Xs(c.length,S)}

  ${j.mainStart()}
    ${j.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}

    var indices = ${y.offsetToIndices("global_idx")};

    let inputIndex = calculateInputIndex(${d});
    if (inputIndex != 0u) {
      let sizeInConcatAxis = array<u32, ${c.length}u>(${S});
      ${d} -= sizeInConcatAxis[inputIndex - 1u];
    }

    ${kn(l,y)}
  }`;return{name:"Concat",shaderCache:{hint:`${r}`,inputDependencies:_},getRunData:()=>({outputs:[{dims:s,dataType:i}],dispatchGroup:{x:Math.ceil(a/64)},programUniforms:v}),getShaderSource:B}},yo=(e,r)=>{let s=e.inputs,i=s[0].dims,a=Qe.normalizeAxis(r.axis,i.length);Ur(s,a);let c=i.slice();c[a]=s.reduce((h,_)=>h+(_.dims.length>a?_.dims[a]:0),0);let l=s.filter(h=>Qe.size(h.dims)>0);e.compute(Vn(l,a,c,s[0].dataType),{inputs:l})},ni=e=>Ht({axis:e.axis})}),gs,wo,vo,si,Mo=E(()=>{Rt(),qt(),gs=(e,r,s="f32")=>{switch(e.activation){case"Relu":return`value = max(value, ${r}(0.0));`;case"Sigmoid":return`value = (${r}(1.0) / (${r}(1.0) + exp(-value)));`;case"Clip":return`value = clamp(value, ${r}(${s}(uniforms.clip_min)), ${r}(${s}(uniforms.clip_max)));`;case"HardSigmoid":return`value = max(${r}(0.0), min(${r}(1.0), ${s}(uniforms.alpha) * value + ${s}(uniforms.beta)));`;case"LeakyRelu":return`value = select(${s}(uniforms.alpha) * value, value, value >= ${r}(0.0));`;case"Tanh":return`let e2x = exp(-2.0 * abs(value));
              value = sign(value) * (1.0 - e2x) / (1.0 + e2x);
        `;case"":return"";default:throw new Error(`Unsupported activation ${e.activation}`)}},wo=(e,r)=>{e.activation==="Clip"?r.push({type:1,data:e.clipMax},{type:1,data:e.clipMin}):e.activation==="HardSigmoid"?r.push({type:1,data:e.alpha},{type:1,data:e.beta}):e.activation==="LeakyRelu"&&r.push({type:1,data:e.alpha})},vo=(e,r)=>{e.activation==="Clip"?r.push({name:"clip_max",type:"f32"},{name:"clip_min",type:"f32"}):e.activation==="HardSigmoid"?r.push({name:"alpha",type:"f32"},{name:"beta",type:"f32"}):e.activation==="LeakyRelu"&&r.push({name:"alpha",type:"f32"})},si=e=>{let r=(e==null?void 0:e.activation)||"";if(r==="HardSigmoid"){let[s,i]=(e==null?void 0:e.activation_params)||[.2,.5];return{activation:r,alpha:s,beta:i}}else if(r==="Clip"){let[s,i]=(e==null?void 0:e.activation_params)||[Qn,Nn];return{activation:r,clipMax:i,clipMin:s}}else if(r==="LeakyRelu"){let[s]=(e==null?void 0:e.activation_params)||[.01];return{activation:r,alpha:s}}return{activation:r}}}),nn,Gi,Ki=E(()=>{nn=(e,r)=>{switch(e){case 1:return r;case 2:return`vec2<${r}>`;case 3:return`vec3<${r}>`;case 4:return`vec4<${r}>`;default:throw new Error(`${e}-component is not supported.`)}},Gi=e=>`
      ${e?"value = value + getBiasByOutputCoords(coords);":""}
      `}),Hi,Od=E(()=>{Hi=e=>`
fn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {
  return dot(coords, vec4<i32>(
      shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));
}
fn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {
  return dot(coords, vec4<i32>(
    i32(${e}.x), i32(${e}.y), i32(${e}.z), 1));
}
`}),xo,oi,To,qi,Qi,Wn,is,Ys,ys=E(()=>{Rt(),qt(),or(),Mo(),Ki(),xo=(e,r)=>e?`
        mm_Asub[inputRow][inputCol] = mm_readA(batch,
          kStart + inputRow,
          globalRowStart / innerElementSize + inputCol${r?", batchIndices":""});
        `:`
        mm_Asub[inputRow][inputCol] = mm_readA(batch,
          globalRow + innerRow,
          kStart / innerElementSize + inputCol${r?", batchIndices":""});
        `,oi=(e,r)=>e?`
        let ACached0 = mm_Asub[k * innerElementSize][localRow];
        let ACached1 = mm_Asub[k * innerElementSize + 1][localRow];
        let ACached2 = mm_Asub[k * innerElementSize + 2][localRow];
        ${r===3?"":"let ACached3 = mm_Asub[k * innerElementSize + 3][localRow];"}
        for (var i = 0; i < rowPerThread; i = i + 1) {
          acc[i] = BCached0 * ACached0[i] + acc[i];
          acc[i] = BCached1 * ACached1[i] + acc[i];
          acc[i] = BCached2 * ACached2[i] + acc[i];
          ${r===3?"":"acc[i] = BCached3 * ACached3[i] + acc[i];"}
        }`:`
        for (var i = 0; i < rowPerThread; i = i + 1) {
          let ACached = mm_Asub[tileRow + i][k];
          acc[i] = BCached0 * ACached.x + acc[i];
          acc[i] = BCached1 * ACached.y + acc[i];
          acc[i] = BCached2 * ACached.z + acc[i];
          ${r===3?"":"acc[i] = BCached3 * ACached.w + acc[i];"}
        }`,To=(e,r,s="f32",i,a=!1,c=32,l=!1,h=32)=>{let _=r[1]*e[1],w=r[0]*e[0],v=a?_:c,y=a?c:_,d=v/r[0],S=c/r[1];if(!((a&&d===4&&e[1]===4||!a&&(d===3||d===4))&&v%r[0]===0&&c%r[1]===0&&e[0]===4))throw new Error(`If transposeA ${a} is true, innerElementSize ${d} and workPerThread[1] ${e[1]} must be 4.
      Otherwise, innerElementSize ${d} must be 3 or 4.
  tileAWidth ${v} must be divisible by workgroupSize[0]${r[0]}. tileInner ${c} must be divisible by workgroupSize[1] ${r[1]}. colPerThread ${e[0]} must be 4.`);return`
var<workgroup> mm_Asub: array<array<vec${d}<${s}>, ${v/d}>, ${y}>;
var<workgroup> mm_Bsub: array<array<vec4<${s}>, ${w/e[0]}>, ${c}>;

const rowPerThread = ${e[1]};
const colPerThread = ${e[0]};
const innerElementSize = ${d};
const tileInner = ${c};

@compute @workgroup_size(${r[0]}, ${r[1]}, ${r[2]})
fn main(@builtin(local_invocation_id) localId : vec3<u32>,
        @builtin(global_invocation_id) globalId : vec3<u32>,
        @builtin(workgroup_id) workgroupId : vec3<u32>) {
  let localRow = i32(localId.y);
  let tileRow = localRow * rowPerThread;
  let tileCol = i32(localId.x);

  let globalRow =i32(globalId.y) * rowPerThread;
  let globalCol = i32(globalId.x);
  let batch = ${l?"0":"i32(globalId.z)"};
  ${i?`let batchIndices = ${i.offsetToIndices("u32(batch)")};`:""}
  let globalRowStart = i32(workgroupId.y) * ${_};

  let num_tiles = ${l?`${Math.ceil(h/c)}`:"(uniforms.dim_inner - 1) / tileInner + 1"};
  var kStart = ${l?`i32(globalId.z) * ${h}`:"0"};

  var acc: array<vec4<${s}>, rowPerThread>;

  // Loop over shared dimension.
  let tileRowB = localRow * ${S};
  for (var t = 0; t < num_tiles; t = t + 1) {
      // Load one tile of A into local memory.
      for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
          let inputRow = tileRow + innerRow;
          let inputCol = tileCol;
          ${xo(a,i)}
      }

      // Load one tile of B into local memory.
      for (var innerRow = 0; innerRow < ${S}; innerRow = innerRow + 1) {
          let inputRow = tileRowB + innerRow;
          let inputCol = tileCol;
          mm_Bsub[inputRow][inputCol] = mm_readB(batch, kStart + inputRow, globalCol${i?", batchIndices":""});
      }
      kStart = kStart + tileInner;
      workgroupBarrier();

      // Compute acc values for a single thread.
      for (var k = 0; k < tileInner / innerElementSize; k = k + 1) {
          let BCached0 = mm_Bsub[k * innerElementSize][tileCol];
          let BCached1 = mm_Bsub[k * innerElementSize + 1][tileCol];
          let BCached2 = mm_Bsub[k * innerElementSize + 2][tileCol];
          ${d===3?"":"let BCached3 = mm_Bsub[k * innerElementSize + 3][tileCol];"}

          ${oi(a,d)}
      }

      workgroupBarrier();
  }

  for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);
  }
}`},qi=(e,r)=>e?`
            mm_Asub[inputRow][inputCol] = mm_readA(batch,
              kStart + inputRow,
              globalRowStart + inputCol${r?", batchIndices":""});
            `:`
            mm_Asub[inputRow][inputCol] = mm_readA(batch,
              globalRowStart + inputRow,
              kStart + inputCol${r?", batchIndices":""});
            `,Qi=e=>e?"let ACached = mm_Asub[k][tileRow + innerRow];":"let ACached = mm_Asub[tileRow + innerRow][k];",Wn=(e,r,s="f32",i,a=!1,c=32,l=!1,h=32,_=!1)=>{let w=e[1]*r[1],v=e[0]*r[0],y=a?w:c,d=a?c:w;if(!(d%r[1]===0&&y%r[0]===0&&c%r[1]===0))throw new Error(`tileAHight ${d} must be divisible by workgroupSize[1]${r[1]}, tileAWidth ${y} must be divisible by workgroupSize[0]${r[0]}, tileInner ${c} must be divisible by workgroupSize[1]${r[1]}`);let S=d/r[1],B=y/r[0],j=c/r[1],Y=_?`
    let localRow = i32(localId.y);
    let localCol = i32(localId.x);
    let globalRowStart = i32(workgroupId.y) * ${w};
    let globalColStart = i32(workgroupId.x) * ${v};

    // Loop over shared dimension.
    for (var t = 0; t < num_tiles; t = t + 1) {
      // Load one tile of A into local memory.
      for (var inputRow = localRow; inputRow < ${d}; inputRow = inputRow + ${r[1]}) {
        for (var inputCol = localCol; inputCol < ${y}; inputCol = inputCol + ${r[0]}) {
          ${qi(a,i)}
        }
      }
      // Load one tile of B into local memory.
      for (var inputRow = localRow; inputRow < ${c}; inputRow = inputRow + ${r[1]}) {
            for (var inputCol = localCol; inputCol < ${v}; inputCol = inputCol + ${r[0]}) {
          mm_Bsub[inputRow][inputCol] = mm_readB(batch,
            kStart + inputRow,
            globalColStart + inputCol${i?", batchIndices":""});
        }
      }
      kStart = kStart + tileInner;
      workgroupBarrier();

      // Compute acc values for a single thread.
      var BCached : array<${s}, colPerThread>;
      for (var k = 0; k < tileInner; k = k + 1) {
        for (var inner = 0; inner < colPerThread; inner = inner + 1) {
          BCached[inner] = mm_Bsub[k][localCol + inner * ${r[0]}];
        }
        for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
          let ACached = ${a?`mm_Asub[k][localRow + innerRow * ${r[1]}];`:`mm_Asub[localRow + innerRow * ${r[1]}][k];`}
          for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
            acc[innerRow][innerCol] = acc[innerRow][innerCol] +
                ACached * BCached[innerCol];
          }
        }
      }
      workgroupBarrier();
    }
    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      let gRow = globalRowStart + localRow + innerRow * ${r[1]};
      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
        let gCol = globalColStart + localCol + innerCol * ${r[0]};
        mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);
      }
    }
    `:`
let tileRow = i32(localId.y) * rowPerThread;
let tileCol = i32(localId.x) * colPerThread;

let globalRow = i32(globalId.y) * rowPerThread;
let globalCol = i32(globalId.x) * colPerThread;
let globalRowStart = i32(workgroupId.y) * ${w};

let tileRowA = i32(localId.y) * ${S};
let tileColA = i32(localId.x) * ${B};
let tileRowB = i32(localId.y) * ${j};
// Loop over shared dimension.
for (var t = 0; t < num_tiles; t = t + 1) {
  // Load one tile of A into local memory.
  for (var innerRow = 0; innerRow < ${S}; innerRow = innerRow + 1) {
    for (var innerCol = 0; innerCol < ${B}; innerCol = innerCol + 1) {
      let inputRow = tileRowA + innerRow;
      let inputCol = tileColA + innerCol;
      ${qi(a,i)}
    }
  }

  // Load one tile of B into local memory.
  for (var innerRow = 0; innerRow < ${j}; innerRow = innerRow + 1) {
    for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
      let inputRow = tileRowB + innerRow;
      let inputCol = tileCol + innerCol;
      mm_Bsub[inputRow][inputCol] = mm_readB(batch,
        kStart + inputRow,
        globalCol + innerCol${i?", batchIndices":""});
    }
  }
  kStart = kStart + tileInner;
  workgroupBarrier();

  // Compute acc values for a single thread.
  var BCached : array<${s}, colPerThread>;
  for (var k = 0; k < tileInner; k = k + 1) {
    for (var inner = 0; inner < colPerThread; inner = inner + 1) {
      BCached[inner] = mm_Bsub[k][tileCol + inner];
    }

    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      ${Qi(a)}
      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
        acc[innerRow][innerCol] = acc[innerRow][innerCol] + ACached * BCached[innerCol];
      }
    }
  }

  workgroupBarrier();
}

for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
  for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
    mm_write(batch, globalRow + innerRow, globalCol + innerCol,
        acc[innerRow][innerCol]);
  }
}
`;return`
  var<workgroup> mm_Asub : array<array<${s}, ${y}>, ${d}>;
  var<workgroup> mm_Bsub : array<array<${s}, ${v}>, ${c}>;
  const rowPerThread = ${e[1]};
  const colPerThread = ${e[0]};
  const tileInner = ${c};

@compute @workgroup_size(${r[0]}, ${r[1]}, ${r[2]})
fn main(@builtin(local_invocation_id) localId : vec3<u32>,
        @builtin(global_invocation_id) globalId : vec3<u32>,
        @builtin(workgroup_id) workgroupId : vec3<u32>) {
    let batch = ${l?"0":"i32(globalId.z)"};
    ${i?`let batchIndices = ${i.offsetToIndices("u32(batch)")};`:""}
    let num_tiles = ${l?`${Math.ceil(h/c)}`:"(uniforms.dim_inner - 1) / tileInner + 1"};
    var kStart = ${l?`i32(globalId.z) * ${h}`:"0"};

    var acc : array<array<${s}, colPerThread>, rowPerThread>;
    ${Y}
  }
`},is=(e,r,s,i,a,c=!1)=>{let[l,h,_]=a,[w,v,y,d]=i,S=Oo(l,_),B=Oo(h,_),j=_r(i[0].type.tensor),Y=()=>{let J=v.rank,ye=w.rank,ve=`var aIndices: ${v.type.indices};`;for(let Ce=J-2-1,Ze=ye-1;Ce>=0;Ce--,Ze--)ve+=`
aIndices[${Ce}] = ${ye>1?`batchIndices[${Ze}]`:"batchIndices"};`;return S.forEach(Ce=>{ve+=`
aIndices[${Ce}] = 0;`}),ve+=`
aIndices[${J-2}] = u32(row);
                   aIndices[${J-1}] = u32(colIn);`,ve},te=()=>{let J=y.rank,ye=w.rank,ve=`var bIndices: ${y.type.indices};`;for(let Ce=J-2-1,Ze=ye-1;Ce>=0;Ce--,Ze--)ve+=`
bIndices[${Ce}] = ${ye>1?`batchIndices[${Ze}]`:"batchIndices"};`;return B.forEach(Ce=>{ve+=`
bIndices[${Ce}] = 0;`}),ve+=`
bIndices[${J-2}] = u32(row);
                   bIndices[${J-1}] = u32(colIn);`,ve};return`
    fn mm_readA(batch: i32, row: i32, colIn: i32, batchIndices: ${w.type.indices}) -> ${nn(e,j)} {
      var value = ${nn(e,j)}(0.0);
      let col = colIn * ${e};
      if(row < uniforms.dim_a_outer && col < uniforms.dim_inner)
      {
        ${Y()}
        value = ${v.getByIndices("aIndices")};
      }
      return value;
    }

    fn mm_readB(batch: i32, row: i32, colIn: i32, batchIndices: ${w.type.indices}) -> ${nn(e,j)} {
      var value = ${nn(e,j)}(0.0);
      let col = colIn * ${e};
      if(row < uniforms.dim_inner && col < uniforms.dim_b_outer)
      {
        ${te()}
        value = ${y.getByIndices("bIndices")};
      }
      return value;
    }

    fn mm_write(batch: i32, row: i32, colIn: i32, valueIn: ${nn(e,j)}) {
      let col = colIn * ${e};
      if (row < uniforms.dim_a_outer && col < uniforms.dim_b_outer) {
        var value = valueIn;
        let coords = vec3<i32>(batch, row, colIn);
        ${r?`value = value + ${c?"bias[colIn]":`${nn(e,j)}(bias[row])`};`:""}
        ${s}
        ${d.setByIndices("vec3<u32>(coords)","value")}
      }
    }
    `},Ys=(e,r,s,i,a=!1,c)=>{let l=e[0].dims,h=e[1].dims,_=l.slice(0,-2),w=h.slice(0,-2),v=i?i.slice(0,-2):s.slice(0,-2),y=Qe.size(v),d=l[l.length-2],S=l[l.length-1],B=h[h.length-1],j=S%4===0&&B%4===0,Y=d<=8?[4,1,1]:[4,4,1],te=[8,8,1],J=[Math.ceil(B/te[0]/Y[0]),Math.ceil(d/te[1]/Y[1]),Math.ceil(y/te[2]/Y[2])],ye=j?4:1,ve=[..._,d,S/ye],Ce=ve.length,Ze=[...w,S,B/ye],Ke=Ze.length,ft=[y,d,B/ye],It=[{type:6,data:d},{type:6,data:B},{type:6,data:S}];wo(r,It),It.push(...Tt(v,ve,Ze));let Bt=["rank","rank"],cr=e.length>2;cr&&(It.push(...Tt(e[2].dims)),Bt.push("rank")),It.push(...Tt(ft));let fr=Xt=>{let Rr=v.length,on=al("batchDims",e[0].dataType,Rr,1),yr=_r(e[0].dataType),Vr=it("a",e[0].dataType,Ce,ye),Wt=it("b",e[1].dataType,Ke,ye),tr=Ut("result",e[0].dataType,ft.length,ye),Ir=[Vr,Wt];if(cr){let Fn=a?ye:1;Ir.push(it("bias",e[2].dataType,e[2].dims.length,Fn))}let et=[{name:"dim_a_outer",type:"i32"},{name:"dim_b_outer",type:"i32"},{name:"dim_inner",type:"i32"}];vo(r,et);let xt=_r(tr.type.tensor),rr=gs(r,tr.type.value,xt),jr=is(ye,cr,rr,[on,Vr,Wt,tr],[_,w,v],a);return`
  ${Xt.registerUniforms(et).registerInternalVariables(on).declareVariables(...Ir,tr)}
  ${jr}
  ${j?To(Y,te,yr,on):Wn(Y,te,yr,on)}
                   `};return{name:"MatMul",shaderCache:{hint:`${Y};${r.activation};${j};${a}`,inputDependencies:Bt},getRunData:()=>({outputs:[{dims:c?c(s):s,dataType:e[0].dataType}],dispatchGroup:{x:J[0],y:J[1],z:J[2]},programUniforms:It}),getShaderSource:fr}}}),Js,jo,Ld=E(()=>{Rt(),Oe(),or(),Mo(),Ki(),Od(),ys(),Js=(e,r,s,i,a=!1,c,l=4,h=4,_=4,w="f32")=>{let v=It=>{switch(It){case 1:return"resData = x[xIndex];";case 3:return`resData = vec3<${w}>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);`;case 4:return"resData = x[xIndex / 4];";default:throw new Error(`innerElementSize ${It} is not supported.`)}},y=It=>{switch(It){case 1:return"return w[row * i32(uniforms.w_shape[3]) + colIn];";case 4:return"return w[row * i32(uniforms.w_shape[3]) / 4 + colIn];";default:throw new Error(`innerElementSize ${It} is not supported.`)}},d=e?`
    let coord = vec4<i32>(batch, xRow, xCol, xCh);
    `:`
    let coord = vec4<i32>(batch, xCh, xRow, xCol);
    `,S=e?`
    let coords = vec4<i32>(
      batch,
      row / outWidth,
      row % outWidth,
      col);
    `:`
    let coords = vec4<i32>(
      batch,
      row,
      col / outWidth,
      col % outWidth);
    `,B=e?"i32(uniforms.x_shape[1])":"i32(uniforms.x_shape[2])",j=e?"i32(uniforms.x_shape[2])":"i32(uniforms.x_shape[3])",Y=e?"row":"col",te=e?"col":"row",J=`
    let inChannels = i32(uniforms.w_shape[2]);
    let outWidth = ${e?"i32(uniforms.result_shape[2])":"i32(uniforms.result_shape[3])"};
    let outRow = ${Y} / outWidth;
    let outCol = ${Y} % outWidth;

    let WRow = ${te} / (i32(uniforms.w_shape[1]) * inChannels);
    let WCol = ${te} / inChannels % i32(uniforms.w_shape[1]);
    let xRow = outRow * uniforms.stride[0] + uniforms.dilation[0] * WRow - uniforms.pad[0];
    let xCol = outCol * uniforms.stride[1] + uniforms.dilation[1] * WCol - uniforms.pad[1];
    let xCh = ${te} % inChannels;
    var resData = ${nn(l,w)}(0.0);
    // The bounds checking is always needed since we use it to pad zero for
    // the 'same' padding type.
    if (xRow >= 0 && xRow < ${B} && xCol >= 0 && xCol < ${j}) {
      ${d}
      let xIndex = getIndexFromCoords4D(coord, vec4<i32>(uniforms.x_shape));
      ${v(l)}
    }
    return resData;`,ye=e?r&&i?`
    let col = colIn * ${l};
    ${J}`:`
    let col = colIn * ${l};
    if (row < uniforms.dim_a_outer && col < uniforms.dim_inner) {
      ${J}
    }
    return ${nn(l,w)}(0.0);`:i&&s?`
    let col = colIn * ${l};
    ${J}`:`
    let col = colIn * ${l};
    if (row < uniforms.dim_inner && col < uniforms.dim_b_outer) {
      ${J}
    }
    return ${nn(l,w)}(0.0);`,ve=`${y(h)}`,Ce=nn(_,w),Ze=nn(e?l:h,w),Ke=nn(e?h:l,w),ft=gs(c,Ce,w);return`
    fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${Ze} {
      ${e?ye:ve}
    }

    fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${Ke} {
      ${e?ve:ye}
    }

    fn mm_write(batch: i32, row : i32, colIn : i32, valueIn : ${Ce}) {
      let col = colIn * ${_};
      if (row < uniforms.dim_a_outer && col < uniforms.dim_b_outer)
      {
      var value = valueIn;
      let outWidth = ${e?"i32(uniforms.result_shape[2])":"i32(uniforms.result_shape[3])"};
      ${S}
      ${Gi(a)}
      ${ft}
      setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
      }
    }`},jo=(e,r,s,i,a,c,l,h,_)=>{let w=r.format==="NHWC",v=w?e[0].dims[3]:e[0].dims[1],y=s[0],d=w?s[2]:s[3],S=w?s[1]:s[2],B=w?s[3]:s[1],j=w&&(v%4===0||v%3===0)&&B%4===0,Y=w?B:d*S,te=w?d*S:B,J=[8,8,1],ye=i<=8?[4,1,1]:[4,4,1],ve=[Math.ceil(Y/J[0]/ye[0]),Math.ceil(te/J[1]/ye[1]),Math.ceil(y/J[2]/ye[2])];kr("verbose",()=>`[conv2d_mm_webgpu] dispatch = ${ve}`);let Ce=j?w&&v%4!==0?3:4:1,Ze=J[1]*ye[1],Ke=J[0]*ye[0],ft=Math.max(J[0]*Ce,J[1]),It=i%Ze===0,Bt=a%Ke===0,cr=c%ft===0,fr=j?[Ce,4,4]:[1,1,1],Xt=[{type:6,data:i},{type:6,data:a},{type:6,data:c},{type:6,data:[r.pads[0],r.pads[1]]},{type:6,data:r.strides},{type:6,data:r.dilations}];wo(r,Xt),Xt.push(...Tt(e[0].dims,e[1].dims));let Rr=["rank","rank"];l&&(Xt.push(...Tt(e[2].dims)),Rr.push("rank")),Xt.push(...Tt(s));let on=yr=>{let Vr=[{name:"dim_a_outer",type:"i32"},{name:"dim_b_outer",type:"i32"},{name:"dim_inner",type:"i32"},{name:"pad",type:"i32",length:2},{name:"stride",type:"i32",length:2},{name:"dilation",type:"i32",length:2}];vo(r,Vr);let Wt=j?4:1,tr=_r(e[0].dataType),Ir=`
      fn setOutputAtIndex(flatIndex : i32, value : ${j?`vec4<${tr}>`:tr}) {
        result[flatIndex] = ${j?`vec4<${tr}>`:tr}(value);
      }
      fn setOutputAtCoords(d0 : i32, d1 : i32, d2 : i32, d3 : i32, value : ${j?`vec4<${tr}>`:tr}) {
        let flatIndex = getOutputIndexFromCoords(vec4<i32>(d0, d1, d2, d3));
        setOutputAtIndex(flatIndex ${j?"/ 4":""}, value);
      }`,et=it("x",e[0].dataType,e[0].dims.length,Ce===3?1:Ce),xt=it("w",e[1].dataType,e[1].dims.length,Wt),rr=[et,xt],jr=Ut("result",e[0].dataType,s.length,Wt);if(l){let Fn=it("bias",e[2].dataType,e[2].dims.length,Wt);rr.push(Fn),Ir+=`
        fn getBiasByOutputCoords(coords : vec4<i32>) -> ${j?`vec4<${tr}>`:tr} {
          return bias[coords.${w?"w":"y"}${j?"/ 4":""}];
        }`}return`
        ${Hi("uniforms.result_strides")}
        //struct Uniforms { xShape : vec4<i32>, wShape : vec4<i32>, outShape : vec4<i32>,
        //  outShapeStrides: vec3<i32>, filterDims : vec2<i32>, pad : vec2<i32>, stride : vec2<i32>,
        //  dilation : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32 };
        ${yr.registerUniforms(Vr).declareVariables(...rr,jr)}
        ${Ir}
        ${Js(w,It,Bt,cr,l,r,fr[0],fr[1],fr[2],tr)}
        ${j?To(ye,J,tr,void 0,!w,ft):Wn(ye,J,tr,void 0,!w,ft,!1,void 0,h)}`};return{name:"Conv2DMatMul",shaderCache:{hint:`${r.cacheKey};${Ce};${j};${It};${Bt};${cr};${Ze};${Ke};${ft}`,inputDependencies:Rr},getRunData:()=>({outputs:[{dims:_?_(s):s,dataType:e[0].dataType}],dispatchGroup:{x:ve[0],y:ve[1],z:ve[2]},programUniforms:Xt}),getShaderSource:on}}}),$a,Ia,$n,Gn,Kr,ws,Ll,ec,tc=E(()=>{Rt(),Oe(),qt(),or(),Mo(),Ki(),$a=e=>{let r=1;for(let s=0;s<e.length;s++)r*=e[s];return r},Ia=e=>typeof e=="number"?[e,e,e]:e,$n=(e,r)=>r<=1?e:e+(e-1)*(r-1),Gn=(e,r,s,i=1)=>{let a=$n(r,i);return Math.floor((e[0]*(s-1)-s+a)/2)},Kr=(e,r,s,i,a)=>{a==null&&(a=Gn(e,r[0],i[0]));let c=[0,0,0,s];for(let l=0;l<3;l++)e[l]+2*a>=r[l]&&(c[l]=Math.trunc((e[l]-r[l]+2*a)/i[l]+1));return c},ws=(e,r,s,i,a,c,l,h,_,w)=>{let v,y,d,S;if(e==="VALID"&&(e=0),typeof e=="number"){v={top:e,bottom:e,left:e,right:e,front:e,back:e};let B=Kr([r,s,i,1],[h,_,w],1,[a,c,l],e);y=B[0],d=B[1],S=B[2]}else if(Array.isArray(e)){if(!e.every((j,Y,te)=>j===te[0]))throw Error(`Unsupported padding parameter: ${e}`);v={top:e[0],bottom:e[1],left:e[2],right:e[3],front:e[4],back:e[5]};let B=Kr([r,s,i,1],[h,_,w],1,[a,c,l],e[0]);y=B[0],d=B[1],S=B[2]}else if(e==="SAME_UPPER"){y=Math.ceil(r/a),d=Math.ceil(s/c),S=Math.ceil(i/l);let B=(y-1)*a+h-r,j=(d-1)*c+_-s,Y=(S-1)*l+w-i,te=Math.floor(B/2),J=B-te,ye=Math.floor(j/2),ve=j-ye,Ce=Math.floor(Y/2),Ze=Y-Ce;v={top:ye,bottom:ve,left:Ce,right:Ze,front:te,back:J}}else throw Error(`Unknown padding parameter: ${e}`);return{padInfo:v,outDepth:y,outHeight:d,outWidth:S}},Ll=(e,r,s,i,a,c=!1,l="channelsLast")=>{let h,_,w,v,y;if(l==="channelsLast")[h,_,w,v,y]=e;else if(l==="channelsFirst")[h,y,_,w,v]=e;else throw new Error(`Unknown dataFormat ${l}`);let[d,,S,B,j]=r,[Y,te,J]=Ia(s),[ye,ve,Ce]=Ia(i),Ze=$n(S,ye),Ke=$n(B,ve),ft=$n(j,Ce),{padInfo:It,outDepth:Bt,outHeight:cr,outWidth:fr}=ws(a,_,w,v,Y,te,J,Ze,Ke,ft),Xt=c?d*y:d,Rr=[0,0,0,0,0];return l==="channelsFirst"?Rr=[h,Xt,Bt,cr,fr]:l==="channelsLast"&&(Rr=[h,Bt,cr,fr,Xt]),{batchSize:h,dataFormat:l,inDepth:_,inHeight:w,inWidth:v,inChannels:y,outDepth:Bt,outHeight:cr,outWidth:fr,outChannels:Xt,padInfo:It,strideDepth:Y,strideHeight:te,strideWidth:J,filterDepth:S,filterHeight:B,filterWidth:j,effectiveFilterDepth:Ze,effectiveFilterHeight:Ke,effectiveFilterWidth:ft,dilationDepth:ye,dilationHeight:ve,dilationWidth:Ce,inShape:e,outShape:Rr,filterShape:r}},ec=(e,r,s,i,a,c)=>{let l=c==="channelsLast";l?e[0].dims[3]:e[0].dims[1];let h=[64,1,1],_={x:s.map((Y,te)=>te)},w=[Math.ceil($a(_.x.map(Y=>s[Y]))/h[0]),1,1];kr("verbose",()=>`[conv3d_naive_webgpu] dispatch = ${w}`);let v=1,y=Qe.size(s),d=[{type:12,data:y},{type:12,data:i},{type:12,data:a},{type:12,data:r.strides},{type:12,data:r.dilations}];wo(r,d),d.push(...Tt(e[0].dims,e[1].dims));let S=["rank","rank"],B=e.length===3;B&&(d.push(...Tt(e[2].dims)),S.push("rank")),d.push(...Tt(s));let j=Y=>{let te=[{name:"output_size",type:"u32"},{name:"filter_dims",type:"u32",length:i.length},{name:"pads",type:"u32",length:a.length},{name:"strides",type:"u32",length:r.strides.length},{name:"dilations",type:"u32",length:r.dilations.length}];vo(r,te);let J=1,ye=_r(e[0].dataType),ve=it("x",e[0].dataType,e[0].dims.length,v),Ce=it("W",e[1].dataType,e[1].dims.length,J),Ze=[ve,Ce],Ke=Ut("result",e[0].dataType,s.length,J),ft="";if(B){let cr=it("bias",e[2].dataType,e[2].dims.length,J);Ze.push(cr),ft+=`
        fn getBiasByOutputCoords(coords : array<u32, 5>) -> ${ye} {
          return bias[${l?Nt("coords",4,5):Nt("coords",1,5)}];
        }`}let It=nn(v,ye),Bt=gs(r,It,ye);return`
            ${ft}
            fn getX(d0 : u32, d1 : u32, d2 : u32, d3 : u32, d4 : u32) -> f32 {
              let aIndices = array<u32, 5>(d0, d1, d2, d3, d4);
              return ${ve.getByIndices("aIndices")};
            }
            fn getW(d0 : u32, d1 : u32, d2 : u32, d3 : u32, d4 : u32) -> f32 {
              let aIndices = array<u32, 5>(d0, d1, d2, d3, d4);
              return ${Ce.getByIndices("aIndices")};
            }
          ${Y.registerUniforms(te).declareVariables(...Ze,Ke)}
          ${Y.mainStart()}
          ${Y.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
              let coords = ${Ke.offsetToIndices("global_idx")};
              let batch = ${Nt("coords",0,ve.rank)};
              let d2 = ${l?Nt("coords",ve.rank-1,ve.rank):Nt("coords",1,ve.rank)};
              let xFRCCorner = vec3<u32>(${l?Nt("coords",1,ve.rank):Nt("coords",2,ve.rank)},
              ${l?Nt("coords",2,ve.rank):Nt("coords",3,ve.rank)},
              ${l?Nt("coords",3,ve.rank):Nt("coords",4,ve.rank)}) * uniforms.strides - uniforms.pads;
              let xFCorner = xFRCCorner.x;
              let xRCorner = xFRCCorner.y;
              let xCCorner = xFRCCorner.z;
              let xShapeY = ${l?Nt("uniforms.x_shape",1,ve.rank):Nt("uniforms.x_shape",2,ve.rank)};
              let xShapeZ = ${l?Nt("uniforms.x_shape",2,ve.rank):Nt("uniforms.x_shape",3,ve.rank)};
              let xShapeW = ${l?Nt("uniforms.x_shape",3,ve.rank):Nt("uniforms.x_shape",4,ve.rank)};
              let xShapeU = ${l?Nt("uniforms.x_shape",4,ve.rank):Nt("uniforms.x_shape",1,ve.rank)};
              let inputDepthNearestVec4 = (xShapeU / 4) * 4;
              let inputDepthVec4Remainder = xShapeU % 4;

              var value = 0.0;
              for (var wF = 0u; wF < uniforms.filter_dims[0]; wF++) {
                let xF = xFCorner + wF * uniforms.dilations[0];
                if (xF < 0 || xF >= xShapeY) {
                  continue;
                }

                for (var wR = 0u; wR < uniforms.filter_dims[1]; wR++) {
                  let xR = xRCorner + wR * uniforms.dilations[1];
                  if (xR < 0 || xR >= xShapeZ) {
                    continue;
                  }

                  for (var wC = 0u; wC < uniforms.filter_dims[2]; wC++) {
                    let xC = xCCorner + wC * uniforms.dilations[2];
                    if (xC < 0 || xC >= xShapeW) {
                      continue;
                    }

                    for (var d1 = 0u; d1 < inputDepthNearestVec4; d1 += 4) {
                      ${l?`let xValues = vec4<f32>(
                               getX(batch, xF, xR, xC, d1),
                               getX(batch, xF, xR, xC, d1 + 1),
                               getX(batch, xF, xR, xC, d1 + 2),
                               getX(batch, xF, xR, xC, d1 + 3));
                            `:`let xValues = vec4<f32>(
                               getX(batch, d1, xF, xR, xC),
                               getX(batch, d1 + 1, xF, xR, xC),
                               getX(batch, d1 + 2, xF, xR, xC),
                               getX(batch, d1 + 3, xF, xR, xC));
                            `}
                            let wValues = vec4<f32>(
                              getW(d2, d1, wF, wR, wC),
                              getW(d2, d1 + 1, wF, wR, wC),
                              getW(d2, d1 + 2, wF, wR, wC),
                              getW(d2, d1 + 3, wF, wR, wC));
                      value += dot(xValues, wValues);
                    }
                    if (inputDepthVec4Remainder == 1) {
                        ${l?`value += getX(batch, xF, xR, xC, inputDepthNearestVec4)
                          * getW(d2, inputDepthNearestVec4, wF, wR, wC);`:`value += getX(batch, inputDepthNearestVec4, xF, xR, xC)
                          * getW(d2, inputDepthNearestVec4, wF, wR, wC);`}
                    } else if (inputDepthVec4Remainder == 2) {
                      ${l?`let xValues = vec2<f32>(
                        getX(batch, xF, xR, xC, inputDepthNearestVec4),
                        getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1));
                      `:`let xValues = vec2<f32>(
                        getX(batch, inputDepthNearestVec4, xF, xR, xC),
                        getX(batch, inputDepthNearestVec4 + 1, xF, xR, xC));
                    `}
                    let wValues = vec2<f32>(
                      getW(d2, inputDepthNearestVec4, wF, wR, wC),
                      getW(d2, inputDepthNearestVec4 + 1, wF, wR, wC));
                      value += dot(xValues, wValues);
                    } else if (inputDepthVec4Remainder == 3) {
                      ${l?`let xValues = vec3<f32>(
                        getX(batch, xF, xR, xC, inputDepthNearestVec4),
                        getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1),
                        getX(batch, xF, xR, xC, inputDepthNearestVec4 + 2));
                      `:`let xValues = vec3<f32>(
                        getX(batch, inputDepthNearestVec4, xF, xR, xC),
                        getX(batch, inputDepthNearestVec4 + 1, xF, xR, xC),
                        getX(batch, inputDepthNearestVec4 + 2, xF, xR, xC));
                    `}
                    let wValues = vec3<f32>(
                      getW(d2, inputDepthNearestVec4, wF, wR, wC),
                      getW(d2, inputDepthNearestVec4 + 1, wF, wR, wC),
                      getW(d2, inputDepthNearestVec4 + 2, wF, wR, wC));
                      value += dot(xValues, wValues);
                    }
                  }
                }
              }
              ${B?"value = value + getBiasByOutputCoords(coords)":""};
              ${Bt}
              result[global_idx] = f32(value);
          }`};return{name:"Conv3DNaive",shaderCache:{hint:`${r.cacheKey};${l};${v};${B}`,inputDependencies:S},getRunData:()=>({outputs:[{dims:s,dataType:e[0].dataType}],dispatchGroup:{x:w[0],y:w[1],z:w[2]},programUniforms:d}),getShaderSource:j}}}),Aa,rc,Dl=E(()=>{Rt(),qt(),or(),Mo(),Aa=(e,r,s,i)=>{let a=e.length>2,c=a?"value += b[output_channel];":"",l=e[0].dims,h=e[1].dims,_=r.format==="NHWC",w=_?s[3]:s[1],v=w/r.group,y=_&&v>=4?Jt(w):1,d=Qe.size(s)/y,S=[{type:12,data:d},{type:12,data:r.dilations},{type:12,data:[r.strides[0],r.strides[1]]},{type:12,data:[r.pads[0],r.pads[1]]},{type:12,data:v}];wo(r,S),S.push(...Tt(l,[h[0],h[1],h[2],h[3]/y]));let B=a?["rank","rank","rank"]:["rank","rank"];S.push(...Tt([s[0],s[1],s[2],s[3]/y]));let j=Y=>{let te=Ut("output",e[0].dataType,s.length,y),J=_r(te.type.tensor),ye=gs(r,te.type.value,J),ve=it("x",e[0].dataType,l.length),Ce=it("w",e[1].dataType,h.length,y),Ze=[ve,Ce];a&&Ze.push(it("b",e[2].dataType,e[2].dims,y));let Ke=[{name:"output_size",type:"u32"},{name:"dilations",type:"u32",length:r.dilations.length},{name:"strides",type:"u32",length:2},{name:"pads",type:"u32",length:2},{name:"output_channels_per_group",type:"u32"}];vo(r,Ke);let ft=_?`
      for (var wHeight: u32 = 0u; wHeight < uniforms.w_shape[0]; wHeight++) {
        let xHeight = xRCCorner.x + wHeight * uniforms.dilations[0];

        if (xHeight < 0u || xHeight >= uniforms.x_shape[1]) {
          continue;
        }

        for (var wWidth: u32 = 0u; wWidth < uniforms.w_shape[1]; wWidth++) {
          let xWidth = xRCCorner.y + wWidth * uniforms.dilations[1];
          if (xWidth < 0u || xWidth >= uniforms.x_shape[2]) {
            continue;
          }

          for (var wInChannel: u32 = 0u; wInChannel < uniforms.w_shape[2]; wInChannel++) {
            let input_channel = in_channel_offset + wInChannel;
            let xVal = ${ve.get("batch","xHeight","xWidth","input_channel")};
            let wVal = ${Ce.get("wHeight","wWidth","wInChannel","output_channel")};
            value += xVal * wVal;
          }
        }
      }
      `:`
      for (var wInChannel: u32 = 0u; wInChannel < uniforms.w_shape[1]; wInChannel++) {
        let input_channel = in_channel_offset + wInChannel;
        for (var wHeight: u32 = 0u; wHeight < uniforms.w_shape[2]; wHeight++) {
          let xHeight = xRCCorner.x + wHeight * uniforms.dilations[0];

          if (xHeight < 0u || xHeight >= uniforms.x_shape[2]) {
            continue;
          }

          for (var wWidth: u32 = 0u; wWidth < uniforms.w_shape[3]; wWidth++) {
            let xWidth = xRCCorner.y + wWidth * uniforms.dilations[1];
            if (xWidth < 0u || xWidth >= uniforms.x_shape[3]) {
              continue;
            }

            let xVal = ${ve.get("batch","input_channel","xHeight","xWidth")};
            let wVal = ${Ce.get("output_channel","wInChannel","wHeight","wWidth")};
            value += xVal * wVal;
          }
        }
      }
      `;return`
  ${Y.registerUniforms(Ke).declareVariables(...Ze,te)}

  ${Y.mainStart()}
    ${Y.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

    let outputIndices = ${te.offsetToIndices("global_idx")};
    let batch: u32 = outputIndices[0];
    let output_channel: u32 = outputIndices[${_?3:1}];
    let xRCCorner: vec2<u32> = vec2<u32>(outputIndices[${_?1:2}], outputIndices[${_?2:3}]) * uniforms.strides - uniforms.pads;
    let group_id: u32 = output_channel * ${y} / uniforms.output_channels_per_group;
    var in_channel_offset = group_id * uniforms.w_shape[${_?2:1}];

    var value: ${te.type.value} = ${te.type.value}(0);
    ${ft}
    ${c}
    ${ye}
    ${te.setByOffset("global_idx","value")}
  }`};return{name:"GroupedConv",shaderCache:{hint:`${r.cacheKey}_${y}`,inputDependencies:B},getRunData:()=>({outputs:[{dims:i?i(s):s,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(d/64)},programUniforms:S}),getShaderSource:j}},rc=(e,r,s,i)=>{let a=e.length>2,c=Jt(s[3]),l=Jt(s[2]),h=Qe.size(s)/c/l,_=[e[0].dims[0],e[0].dims[1],e[0].dims[2],e[0].dims[3]/c],w=[e[1].dims[0],e[1].dims[1],e[1].dims[2],e[1].dims[3]/c],v=[s[0],s[1],s[2],s[3]/c],y=[{type:12,data:h},{type:6,data:[r.strides[0],r.strides[1]]},{type:6,data:[r.pads[0],r.pads[1]]}];wo(r,y),y.push(...Tt(_,w,v));let d=(l-1)*r.strides[1]+w[1],S=B=>{let j=Ut("output",e[0].dataType,v.length,c),Y=_r(j.type.tensor),te=gs(r,j.type.value,Y),J=it("x",e[0].dataType,_.length,c),ye=it("w",e[1].dataType,w.length,c),ve=[J,ye];a&&ve.push(it("b",e[2].dataType,e[2].dims,c));let Ce=a?"value += b[output_channel];":"",Ze=[{name:"output_size",type:"u32"},{name:"strides",type:"i32",length:2},{name:"pads",type:"i32",length:2}];return vo(r,Ze),`
  ${B.registerUniforms(Ze).declareVariables(...ve,j)}
  ${B.mainStart()}
    ${B.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    let width0 = uniforms.output_shape[3];
    let output_channel = global_idx % width0;
    var index1 = global_idx / width0;
    let width1 = uniforms.output_shape[2] / ${l}u;
    let col = (index1 % width1) * ${l}u;
    index1 = index1 / width1;
    let row = index1 % uniforms.output_shape[1];
    let batch = index1 / uniforms.output_shape[1];

    let x_corner = vec2<i32>(i32(row), i32(col)) * uniforms.strides - uniforms.pads;

    var x_vals: array<${J.type.value}, ${d}>;
    var values: array<${j.type.value}, ${l}>;
    let input_channel = output_channel;
    // Use constant instead of uniform can give better performance for w's height/width.
    for (var w_height: u32 = 0u; w_height < ${w[0]}; w_height++) {
      let x_height = x_corner.x + i32(w_height);
      if (x_height >= 0 && u32(x_height) < uniforms.x_shape[1]) {
        for (var i = 0; i < ${d}; i++) {
          let x_width = x_corner.y + i;
          if (x_width >= 0 && u32(x_width) < uniforms.x_shape[2]) {
            x_vals[i] = ${J.get("batch","u32(x_height)","u32(x_width)","input_channel")};
          } else {
            x_vals[i] = ${J.type.value}(0);
          }
        }
        for (var w_width: u32 = 0u; w_width < ${w[1]}; w_width++) {
          let w_val = ${ye.get("w_height","w_width","0","output_channel")};
          for (var i = 0u; i < ${l}u; i++) {
            values[i] = fma(x_vals[i * u32(uniforms.strides[1]) + w_width], w_val, values[i]);
          }
        }
      }
    }

    for (var i = 0u; i < ${l}u; i++) {
      var value = values[i];
      ${Ce}
      ${te}
      ${j.set("batch","row","col + i","output_channel","value")};
    }
  }`};return{name:"GroupedConv-Vectorize",shaderCache:{hint:`${r.cacheKey};${c};${l};${d};${w[0]};${w[1]}`,inputDependencies:a?["rank","rank","type"]:["rank","rank"]},getRunData:()=>({outputs:[{dims:i?i(s):s,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(h/64)},programUniforms:y}),getShaderSource:S}}}),zl,ii,Bl,Dd=E(()=>{Rt(),qt(),ys(),or(),Mo(),zl=(e,r,s,i,a=!1,c)=>{let l=e[0].dims,h=e[1].dims,_=l[l.length-2],w=h[h.length-1],v=l[l.length-1],y=Jt(w),d=Jt(v),S=Jt(_),B=Qe.size(s)/y/S,j=e.length>2,Y=i?i.slice(0,-2):s.slice(0,-2),te=[Qe.size(Y),_,w],J=[{type:12,data:B},{type:12,data:_},{type:12,data:w},{type:12,data:v}];wo(r,J),J.push(...Tt(Y,l,h)),j&&J.push(...Tt(e[2].dims)),J.push(...Tt(te));let ye=ve=>{let Ce=al("batch_dims",e[0].dataType,Y.length),Ze=it("a",e[0].dataType,l.length,d),Ke=it("b",e[1].dataType,h.length,y),ft=Ut("output",e[0].dataType,te.length,y),It=_r(ft.type.tensor),Bt=gs(r,ft.type.value,It),cr=[Ze,Ke],fr="";if(j){let Ir=a?y:1;cr.push(it("bias",e[2].dataType,e[2].dims.length,Ir)),fr=`${a?`value += bias[col / ${Ir}];`:`value += ${ft.type.value}(bias[row + i]);`}`}let Xt=l.slice(0,-2),Rr=h.slice(0,-2),on=Oo(Xt,Y),yr=Oo(Rr,Y),Vr=[{name:"output_size",type:"u32"},{name:"M",type:"u32"},{name:"N",type:"u32"},{name:"K",type:"u32"}];vo(r,Vr);let Wt=(Ir,et)=>{let xt=Ir.rank,rr=Ir.name;if(xt===2)return`var ${rr}_indices = ${Ir.type.indices}(0u, 0u);`;let jr=Ce.rank,Fn=`var ${rr}_indices: ${Ir.type.indices};`;for(let zn=xt-2-1,td=jr-1;zn>=0;zn--,td--)Fn+=`
${rr}_indices[${zn}] = ${jr>1?`batch_indices[${td}]`:"batch_indices"};`;return et.forEach(zn=>{Fn+=`
${rr}_indices[${zn}] = 0;`}),Fn+=`${rr}_indices[${xt-2}] = 0u;
                     ${rr}_indices[${xt-1}] = 0u;`,Fn},tr=()=>{let Ir=`var a_data: ${Ze.type.value};`;for(let et=0;et<d;et++)Ir+=`
              let b_data${et} = b[(b_offset + (k + ${et}) * uniforms.N + col) / ${y}];`;for(let et=0;et<S;et++){Ir+=`a_data = a[(a_offset + (row + ${et}) * uniforms.K + k) / ${d}];`;for(let xt=0;xt<d;xt++)Ir+=`
            values[${et}] = fma(${Ke.type.value}(a_data${d===1?"":`[${xt}]`}), b_data${xt}, values[${et}]);
`}return Ir};return`
  ${ve.registerUniforms(Vr).registerInternalVariables(Ce).declareVariables(...cr,ft)}
  ${ve.mainStart()}
    ${ve.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    let col = (global_idx % (uniforms.N / ${y})) * ${y};
    var index1 = global_idx / (uniforms.N / ${y});
    let stride1 = uniforms.M / ${S};
    let row = (index1 % stride1) * ${S};
    let batch = index1 / stride1;

    ${s.length===2?"":`let batch_indices = ${Ce.offsetToIndices("batch")};`}
    ${Wt(Ze,on)}
    let a_offset = ${Ze.indicesToOffset("a_indices")};
    ${Wt(Ke,yr)}
    let b_offset = ${Ke.indicesToOffset("b_indices")};
    var values: array<${ft.type.value}, ${S}>;
    for (var k: u32 = 0u; k < uniforms.K; k = k + ${d}) {
      ${tr()}
    }
    for (var i = 0u; i < ${S}u; i++) {
      var value = values[i];
      ${fr}
      ${Bt}
      let cur_indices = ${ft.type.indices}(batch, row + i, col);
      let offset = ${ft.indicesToOffset("cur_indices")};
      ${ft.setByOffset(`offset / ${y}`,"value")};
    }
  }
  `};return{name:"MatMulNaive",shaderCache:{hint:`${r.activation};${y};${d};${S};${a}`,inputDependencies:j?["rank","rank","rank"]:["rank","rank"]},getRunData:()=>({outputs:[{dims:c?c(s):s,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(B/64)},programUniforms:J}),getShaderSource:ye}},ii=e=>{if(!e||e.length!==2)throw new Error("MatMul requires 2 inputs.");if(e[0].dims[e[0].dims.length-1]!==e[1].dims[e[1].dims.length-2])throw new Error("shared dimension does not match.")},Bl=e=>{ii(e.inputs);let r=Nr.calcShape(e.inputs[0].dims,e.inputs[1].dims,!0);if(!r)throw new Error("Can't use matmul on the given tensors");let s=r[r.length-1],i=e.inputs[0].dims[e.inputs[0].dims.length-1];s<8&&i<8?e.compute(zl(e.inputs,{activation:""},r)):e.compute(Ys(e.inputs,{activation:""},r))}}),ai,li,nc,Xi,No,Rl,Fs,Fa,Uo,sc=E(()=>{qt(),Ld(),tc(),ys(),Dl(),Mo(),Dd(),mo(),ai=(e,r,s,i,a,c)=>{let l=e[0],h=e.slice(c?1:2,c?3:4),_=h.length,w=r[0],v=r.slice(2).map((d,S)=>d+(d-1)*(s[S]-1)),y=h.map((d,S)=>d+i[S]+i[S+_]).map((d,S)=>Math.floor((d-v[S]+a[S])/a[S]));return y.splice(0,0,l),y.splice(c?3:1,0,w),y},li=[2,3,1,0],nc=(e,r)=>{if(!e||e.length!==2&&e.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(e[0].dims.length>5)throw new Error("greater than 5D is not supported");if(e[0].dims.length!==e[1].dims.length)throw new Error("filter does not have same dimension as input");let s=e[0].dims[r.format==="NHWC"?e[0].dims.length-1:1],i=e[1].dims[1]*r.group;if(s!==i)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");if(e.length===3&&(e[2].dims.length!==1||e[1].dims[0]!==e[2].dims[0]))throw new Error("invalid bias");let a=e[0].dims.length-2;if(r.dilations.length!==a)throw new Error(`dilations should be ${a}D`);if(r.strides.length!==a)throw new Error(`strides should be ${a}D`);if(r.pads.length!==a*2)throw new Error(`pads should be ${a*2}D`);if(r.kernelShape.length!==0&&r.kernelShape.length!==e[1].dims.length-2)throw new Error("invalid kernel shape")},Xi=(e,r)=>{let s=e.kernelShape.slice();s.length<r[1].dims.length-2&&s.push(...Array(r[1].dims.length-2-s.length).fill(0));for(let c=2;c<r[1].dims.length;++c)s[c-2]===0&&(s[c-2]=r[1].dims[c]);let i=e.pads.slice();mr.adjustPadsBasedOnAutoPad(r[0].dims,e.strides,e.dilations,s,i,e.format==="NHWC",e.autoPad);let a=Object.assign({},e);return Object.assign(a,{kernelShape:s,pads:i}),a},No=e=>{let r=si(e),s=e.format,i=["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][e.auto_pad],a=e.dilations,c=e.group,l=e.kernel_shape,h=e.pads,_=e.strides,w=e.w_is_const();return{autoPad:i,format:s,dilations:a,group:c,kernelShape:l,pads:h,strides:_,wIsConst:w,...r,cacheKey:`${e.format};${r.activation};`}},Rl=(e,r,s,i)=>{let a=s.format==="NHWC",c=ai(r[0].dims,r[1].dims,s.dilations,s.pads,s.strides,a);if(s.group!==1){let Ze=[r[0]];if(a){let Ke=e.kernelCustomData.wT??e.compute(Un(r[1],li),{inputs:[1],outputs:[s.wIsConst?-2:-1]})[0];s.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=Ke),Ze.push(Ke)}else Ze.push(r[1]);r.length===3&&Ze.push(r[2]),!e.adapterInfo.isArchitecture("ampere")&&a&&r[1].dims[0]===s.group&&r[1].dims[1]===1&&s.dilations[0]===1&&s.dilations[1]===1?e.compute(rc(Ze,s,c,i),{inputs:Ze}):e.compute(Aa(Ze,s,c,i),{inputs:Ze});return}let l=r.length===3,h=r[0].dims[a?1:2],_=r[0].dims[a?2:3],w=r[0].dims[a?3:1],v=r[1].dims[2],y=r[1].dims[3],d=c[a?1:2],S=c[a?2:3],B=c[a?3:1],j=a&&v===h&&y===_&&s.pads[0]===0&&s.pads[1]===0;if(j||v===1&&y===1&&s.dilations[0]===1&&s.dilations[1]===1&&s.strides[0]===1&&s.strides[1]===1&&s.pads[0]===0&&s.pads[1]===0){let Ze=c[0],Ke,ft,It,Bt=[];if(a){let Xt=e.kernelCustomData.wT??e.compute(Un(r[1],li),{inputs:[1],outputs:[s.wIsConst?-2:-1]})[0];if(s.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=Xt),j){let Rr=h*_*w;Ke=r[0].reshape([1,Ze,Rr]),ft=Xt.reshape([1,Rr,B]),It=[1,Ze,B]}else Ke=r[0].reshape([Ze,h*_,w]),ft=Xt.reshape([1,w,B]),It=[Ze,d*S,B];Bt.push(Ke),Bt.push(ft)}else Ke=r[0].reshape([Ze,w,h*_]),ft=r[1].reshape([1,B,w]),It=[Ze,B,d*S],Bt.push(ft),Bt.push(Ke);l&&Bt.push(r[2]);let cr=It[2],fr=Bt[0].dims[Bt[0].dims.length-1];cr<8&&fr<8?e.compute(zl(Bt,s,c,It,a,i),{inputs:Bt}):e.compute(Ys(Bt,s,c,It,a,i),{inputs:Bt});return}let Y=!0,te=e.kernelCustomData.wT??e.compute(Un(r[1],li),{inputs:[1],outputs:[s.wIsConst?-2:-1]})[0];s.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=te);let J=[r[0],te];l&&J.push(r[2]);let ye=a?d*S:B,ve=a?B:d*S,Ce=v*y*w;e.compute(jo(J,s,c,ye,ve,Ce,l,Y,i),{inputs:J})},Fs=(e,r)=>{let s=r.format==="NHWC",i=[e.inputs[0].reshape(s?[e.inputs[0].dims[0],1,e.inputs[0].dims[1],e.inputs[0].dims[2]]:[e.inputs[0].dims[0],e.inputs[0].dims[1],1,e.inputs[0].dims[2]]),e.inputs[1].reshape([e.inputs[1].dims[0],e.inputs[1].dims[1],1,e.inputs[1].dims[2]])];e.inputs.length===3&&i.push(e.inputs[2]);let a=[0,r.pads[0],0,r.pads[1]],c=[1].concat(r.strides),l=[1].concat(r.dilations),h=[1].concat(r.kernelShape),_=Xi({...r,pads:a,strides:c,dilations:l,kernelShape:h},i);Rl(e,i,_,w=>s?[w[0],w[2],w[3]]:[w[0],w[1],w[3]])},Fa=(e,r,s)=>{let i=s.format==="NHWC"?"channelsLast":"channelsFirst",a=Xi(s,r),c=s.autoPad==="NOTSET"?s.pads:s.autoPad,l=Ll(r[0].dims,r[1].dims,s.strides,s.dilations,c,!1,i);e.compute(ec(r,a,l.outShape,[l.filterDepth,l.filterHeight,l.filterWidth],[l.padInfo.front,l.padInfo.top,l.padInfo.left],i))},Uo=(e,r)=>{if(nc(e.inputs,r),e.inputs[0].dims.length===3)Fs(e,r);else if(e.inputs[0].dims.length===5)Fa(e,e.inputs,r);else{let s=Xi(r,e.inputs);Rl(e,e.inputs,s)}}}),jl,Oa,oc=E(()=>{Rt(),Oe(),or(),Mo(),Ki(),Od(),ys(),jl=(e,r=!1,s,i,a=4)=>{let c=Y=>{switch(Y){case 1:return"return w[getIndexFromCoords4D(coord, vec4<i32>(uniforms.w_shape))];";case 4:return`
            let coord1 = vec4<i32>(coordX, coordY, col + 1, rowInner);
            let coord2 = vec4<i32>(coordX, coordY, col + 2, rowInner);
            let coord3 = vec4<i32>(coordX, coordY, col + 3, rowInner);
            let v0 = w[getIndexFromCoords4D(coord, vec4<i32>(uniforms.w_shape))];
            let v1 = w[getIndexFromCoords4D(coord1, vec4<i32>(uniforms.w_shape))];
            let v2 = w[getIndexFromCoords4D(coord2, vec4<i32>(uniforms.w_shape))];
            let v3 = w[getIndexFromCoords4D(coord3, vec4<i32>(uniforms.w_shape))];
            return ${i}(v0, v1, v2, v3);
            `;default:throw new Error(`innerElementSize ${Y} is not supported.`)}},l=e?`
      let coord = vec4<i32>(batch, iXR, iXC, xCh);
      `:`
      let coord = vec4<i32>(batch, xCh, iXR, iXC);
      `,h=e?`
    let coords = vec4<i32>(
      batch,
      row / outWidth,
      row % outWidth,
      col);
    `:`
    let coords = vec4<i32>(
      batch,
      row,
      col / outWidth,
      col % outWidth);
    `,_=e?"i32(uniforms.x_shape[1])":"i32(uniforms.x_shape[2])",w=e?"i32(uniforms.x_shape[2])":"i32(uniforms.x_shape[3])",v=e?"row":"col",y=e?"col":"row",d=`
      let inChannels = ${e?"i32(uniforms.x_shape[3])":"i32(uniforms.x_shape[1])"};
      let outWidth = ${e?"i32(uniforms.result_shape[2])":"i32(uniforms.result_shape[3])"};
      let outRow = ${v} / outWidth;
      let outCol = ${v} % outWidth;

      let WRow = ${y} / (uniforms.filter_dims[1] * inChannels);
      let WCol = ${y} / inChannels % uniforms.filter_dims[1];
      let xR = f32(outRow - uniforms.pads[0] + uniforms.dilations[0] * WRow) / f32(uniforms.strides[0]);
      let xC = f32(outCol - uniforms.pads[1] + uniforms.dilations[1] * WCol) / f32(uniforms.strides[1]);
      if (xR < 0.0 || xR >= f32(${_}) || fract(xR) > 0.0) {
        return ${i}(0.0);
      }
      if (xC < 0.0 || xC >= f32(${w}) || fract(xC) > 0.0) {
        return ${i}(0.0);
      }
      let iXR = i32(xR);
      let iXC = i32(xC);
      let xCh = ${y} % inChannels;
      ${l}
      return x[getIndexFromCoords4D(coord, vec4<i32>(uniforms.x_shape))/${a}];`,S=e?`
      let col = colIn * ${a};
      if (row < uniforms.dim_a_outer && col < uniforms.dim_inner) {
        ${d}
      }
      return ${i}(0.0);`:`
      let col = colIn * ${a};
      if (row < uniforms.dim_inner && col < uniforms.dim_b_outer) {
        ${d}
      }
      return ${i}(0.0);`,B=`
      let col = colIn * ${a};
      let inChannels = ${e?"i32(uniforms.x_shape[3])":"i32(uniforms.x_shape[1])"};
      let coordX = uniforms.filter_dims[0] - 1 - row / (uniforms.filter_dims[1] * inChannels);
      let coordY = uniforms.filter_dims[1] - 1 - (row / inChannels) % uniforms.filter_dims[1];
      if (${e?"row < uniforms.dim_inner && col < uniforms.dim_b_outer":"row < uniforms.dim_inner && col < uniforms.dim_a_outer"}  && coordX >= 0 && coordY >= 0) {
        let rowInner = row % inChannels;
        let coord = vec4<i32>(coordX, coordY, col, rowInner);
        ${c(a)}
      }
      return ${i}(0.0);
      `,j=gs(s,i);return`
  fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${i} {
    ${e?S:B}
  }

  fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${i} {
    ${e?B:S}
  }

  fn mm_write(batch: i32, row : i32, colIn : i32, valueInput : ${i}) {
    let col = colIn * ${a};
    if (row < uniforms.dim_a_outer && col < uniforms.dim_b_outer) {
      var value = valueInput;
      let outWidth = ${e?"i32(uniforms.result_shape[2])":"i32(uniforms.result_shape[3])"};
      ${h}
      ${Gi(r)}
      ${j}
      result[getIndexFromCoords4D(coords, vec4<i32>(uniforms.result_shape))/${a}] = value;
    }
  }`},Oa=(e,r,s,i,a,c,l,h)=>{let _=r.format==="NHWC",w=_?e[0].dims[3]:e[0].dims[1],v=s[0],y=_?s[2]:s[3],d=_?s[1]:s[2],S=_?s[3]:s[1],B=_&&w%4===0&&w%3&&S%4===0,j=_?S:y*d,Y=_?y*d:S,te=[8,8,1],J=i<=8?[4,1,1]:[4,4,1],ye=[Math.ceil(j/te[0]/J[0]),Math.ceil(Y/te[1]/J[1]),Math.ceil(v/te[2]/J[2])];kr("verbose",()=>`[conv_backprop_mm_webgpu] dispatch = ${ye}`);let ve=B?4:1,Ce=Math.max(te[0]*ve,te[1]),Ze=B?4:1,Ke=[r.kernelShape[_?1:2],r.kernelShape[_?2:3]],ft=[Ke[0]+(r.dilations[0]<=1?0:(Ke[0]-1)*(r.dilations[0]-1)),Ke[1]+(r.dilations[1]<=1?0:(Ke[1]-1)*(r.dilations[1]-1))],It=[ft[0]-1-Math.floor((r.pads[0]+r.pads[2])/2),ft[1]-1-Math.floor((r.pads[1]+r.pads[3])/2)],Bt=[{type:6,data:i},{type:6,data:a},{type:6,data:c},{type:6,data:r.strides},{type:6,data:r.dilations},{type:6,data:Ke},{type:6,data:It}];wo(r,Bt),Bt.push(...Tt(e[0].dims,e[1].dims));let cr=["rank","rank"];l&&(Bt.push(...Tt(e[2].dims)),cr.push("rank")),Bt.push(...Tt(s));let fr=Xt=>{let Rr=it("x",e[0].dataType,e[0].dims.length,Ze),on=it("w",e[1].dataType,e[1].dims.length,1),yr=Ut("result",e[0].dataType,s.length,Ze),Vr=[Rr,on],Wt="";if(l){let et=it("bias",e[2].dataType,e[2].dims.length,Ze);Vr.push(et),Wt+=`
          fn getBiasByOutputCoords(coords : vec4<i32>) -> ${et.type.value} {
            return bias[coords.${_?"w":"y"}${B?"/ 4":""}];
          }`}let tr=[{name:"dim_a_outer",type:"i32"},{name:"dim_b_outer",type:"i32"},{name:"dim_inner",type:"i32"},{name:"strides",type:"i32",length:2},{name:"dilations",type:"i32",length:2},{name:"filter_dims",type:"i32",length:Ke.length},{name:"pads",type:"i32",length:It.length}];vo(r,tr);let Ir=_r(e[0].dataType,1);if(Ir!=="f16"&&Ir!=="f32")throw new Error(`elemType ${Ir} is not supported.`);return`
        ${Hi("uniforms.result_strides")}
        ${Xt.registerUniforms(tr).declareVariables(...Vr,yr)};
        ${Wt}
        ${jl(_,l,r,Rr.type.value,ve)}
        ${B?To(J,te,Ir,void 0,!_,Ce):Wn(J,te,Ir,void 0,!_,Ce,!1,void 0,h)}`};return{name:"Conv2DTransposeMatMul",shaderCache:{hint:`${r.cacheKey};${J};${te};${B}`,inputDependencies:cr},getRunData:()=>({outputs:[{dims:s,dataType:e[0].dataType}],dispatchGroup:{x:ye[0],y:ye[1],z:ye[2]},programUniforms:Bt}),getShaderSource:fr}}}),ui,Jn,ci=E(()=>{Rt(),Oe(),qt(),or(),ui=(e,r,s,i,a,c=!1,l,h,_=!1)=>{let w=_?1:2,v=_?2:3,y=_?3:1,d=c?2:1,S=`
  fn setOutputAtIndex(flatIndex : u32, value : ${c?`vec4<${l}>`:l}) {
    result[flatIndex] = ${c?`vec4<${l}>`:l}(value);
  }`;i&&(S+=`
    fn getBiasByOutputCoords(coords : vec4<u32>) -> ${c?`vec4<${l}>`:l} {
      return bias[coords.${_?"w":"y"}${c?"/ 4":""}];
    }`);let B=c?4:1,j=it("W",r[1].dataType,r[1].dims.length,B),Y=it("Dy",r[0].dataType,r[0].dims.length,B),te=[Y,j];i&&te.push(it("bias",r[2].dataType,[s[y]].length,B));let J=Ut("result",r[0].dataType,s.length,B),ye=`{
        let batch: u32 = ${a?"global_id.z":"workgroup_id.z"} / uniforms.result_shape[1];
        let r = ${a?"global_id.z":"workgroup_id.z"} % uniforms.result_shape[1];
        let c = ${a?"global_id.y":"workgroup_id.y"} * ${d};
        let d1: u32 = ${a?"global_id.x":"workgroup_id.x"} * 4;

        let dyCorner = vec2<i32>(i32(r), i32(c)) - vec2<i32>(uniforms.pads);

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        var dotProd: array<vec4<${l}>, ${d}>;
        for (var i = 0; i < ${d}; i++) {
          dotProd[i] = vec4<${l}>(0.0);
        }
        for (var wR: u32 = 0; wR < uniforms.filter_dims[0]; wR = wR + 1) {
          var dyR = (${l}(dyCorner.x) + ${l}(wR)) / ${l}(uniforms.strides.x);
          let wRPerm = uniforms.filter_dims[0] - 1 - wR;
          if (dyR < 0.0 || dyR >= ${l}(uniforms.Dy_shape[1]) ||
              fract(dyR) > 0.0 || wRPerm < 0) {
            continue;
          }
          let idyR: u32 = u32(dyR);

          for (var wC: u32 = 0; wC < uniforms.filter_dims[1]; wC = wC + 1) {
            let dyC = (${l}(dyCorner.y) + ${l}(wC)) / ${l}(uniforms.strides.y);
            let dyC2 = (${l}(dyCorner.y) + 1.0 + ${l}(wC)) / ${l}(uniforms.strides.y);
            let wCPerm = uniforms.filter_dims[1] - 1 - wC;
            if (wCPerm < 0) {
              continue;
            }
            var bDyCVal = true;
            var bDyCVal2 = true;
            if (dyC < 0.0 || dyC >= ${l}(uniforms.Dy_shape[2]) ||
                fract(dyC) > 0.0) {
              bDyCVal = false;
            }
            if (dyC2 < 0.0 || dyC2 >= ${l}(uniforms.Dy_shape[2]) ||
                fract(dyC2) > 0.0) {
              bDyCVal2 = false;
            }

            let idyC: u32 = u32(dyC);
            let idyC2: u32 = u32(dyC2);
            if (bDyCVal && bDyCVal2) {
              let d2Length = uniforms.Dy_shape[3];
              for (var d2 :u32 = 0; d2 < d2Length; d2 = d2 + 4) {
                let wValue0 = ${j.get("u32(wRPerm)","u32(wCPerm)","d1","d2")};
                let wValue1 = ${j.get("u32(wRPerm)","u32(wCPerm)","d1 + 1","d2")};
                let wValue2 = ${j.get("u32(wRPerm)","u32(wCPerm)","d1 + 2","d2")};
                let wValue3 = ${j.get("u32(wRPerm)","u32(wCPerm)","d1 + 3","d2")};

                var xValue = ${Y.get("batch","idyR","idyC","d2")};
                let tmpval = vec4<${l}>(dot(xValue, wValue0),
                                      dot(xValue, wValue1),
                                      dot(xValue, wValue2),
                                      dot(xValue, wValue3));
                dotProd[0] = dotProd[0] + tmpval;

                xValue =  ${Y.get("batch","idyR","idyC2","d2")};

                dotProd[1] = dotProd[1] + vec4<${l}>(dot(xValue, wValue0),
                                                    dot(xValue, wValue1),
                                                    dot(xValue, wValue2),
                                                    dot(xValue, wValue3));
              }
            } else if (bDyCVal) {
              let d2Length = uniforms.Dy_shape[${y}];
              for (var d2: u32 = 0; d2 < d2Length; d2 = d2 + 4) {
                let wValue0 = ${j.get("u32(wRPerm)","u32(wCPerm)","d1","d2")};
                let wValue1 = ${j.get("u32(wRPerm)","u32(wCPerm)","d1 + 1","d2")};
                let wValue2 = ${j.get("u32(wRPerm)","u32(wCPerm)","d1 + 2","d2")};
                let wValue3 = ${j.get("u32(wRPerm)","u32(wCPerm)","d1 + 3","d2")};

                var xValue = ${Y.get("batch","idyR","idyC","d2")};
                let tmpval = vec4<${l}>(dot(xValue, wValue0),
                                      dot(xValue, wValue1),
                                      dot(xValue, wValue2),
                                      dot(xValue, wValue3));
                dotProd[0] = dotProd[0] + tmpval;
              }
            } else if (bDyCVal2) {
              let d2Length = uniforms.Dy_shape[3];
              for (var d2: u32 = 0; d2 < d2Length; d2 = d2 + 4) {
                let wValue0 = ${j.get("u32(wRPerm)","u32(wCPerm)","d1","d2")};
                let wValue1 = ${j.get("u32(wRPerm)","u32(wCPerm)","d1 + 1","d2")};
                let wValue2 = ${j.get("u32(wRPerm)","u32(wCPerm)","d1 + 2","d2")};
                let wValue3 = ${j.get("u32(wRPerm)","u32(wCPerm)","d1 + 3","d2")};

                var xValue = ${Y.get("batch","idyR","idyC2","d2")};
                let tmpval = vec4<${l}>(dot(xValue, wValue0),
                                      dot(xValue, wValue1),
                                      dot(xValue, wValue2),
                                      dot(xValue, wValue3));
                dotProd[1] = dotProd[1] + tmpval;
              }
            }
          }
        }

        for (var i: u32 = 0; i < ${d}; i = i + 1) {
          let value = dotProd[i] + ${i?"bias[c+i]":`vec4<${l}>(0.0)`};
          ${J.set("batch","r","c + i","d1","value")};
        }
      }`,ve=`
          let outputIndices = ${J.offsetToIndices("global_idx")};
          let batch = ${J.indicesGet("outputIndices",0)};
          let d1 = ${J.indicesGet("outputIndices",y)};
          let r = ${J.indicesGet("outputIndices",w)};
          let c = ${J.indicesGet("outputIndices",v)};
          let dyCorner = vec2<i32>(i32(r), i32(c)) - uniforms.pads;
          let dyRCorner = dyCorner.x;
          let dyCCorner = dyCorner.y;
          let groupId = d1 / uniforms.output_channels_per_group;
          let wOutChannel = d1 - groupId * uniforms.output_channels_per_group;
          // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
          // ? = to be determined. : = across all values in that axis.
          var dotProd = ${l}(0.0);
          for (var wR: u32 = 0; wR < uniforms.effective_filter_dims.x; wR = wR + 1) {
            if (wR % uniforms.dilations.x != 0) {
              continue;
            }
            let dyR = (${l}(dyRCorner) + ${l}(wR)) / ${l}(uniforms.strides[0]);
            let wRPerm = uniforms.filter_dims.x - 1 - wR / uniforms.dilations.x;
            if (dyR < 0.0 || dyR >= ${l}(uniforms.Dy_shape[${w}]) || fract(dyR) > 0.0 ||
                wRPerm < 0) {
              continue;
            }
            let idyR: u32 = u32(dyR);

            for (var wC: u32 = 0; wC < uniforms.effective_filter_dims.y; wC = wC + 1) {
              if (wC % uniforms.dilations.y != 0) {
                continue;
              }
              let dyC = (${l}(dyCCorner) + ${l}(wC)) / ${l}(uniforms.strides.y);
              let wCPerm = uniforms.filter_dims.y - 1 - wC / uniforms.dilations.y;
              if (dyC < 0.0 || dyC >= ${l}(uniforms.Dy_shape[${v}]) ||
                  fract(dyC) > 0.0 || wCPerm < 0) {
                continue;
              }
              let idyC: u32 = u32(dyC);
              var inputChannel = groupId * uniforms.input_channels_per_group;
              for (var d2: u32 = 0; d2 < uniforms.input_channels_per_group; d2 = d2 + 1) {
                let xValue = ${_?Y.get("batch","idyR","idyC","inputChannel"):Y.get("batch","inputChannel","idyR","idyC")};
                let wValue = ${j.get("inputChannel","wOutChannel","u32(wRPerm)","u32(wCPerm)")};
                dotProd = dotProd + xValue * wValue;
                inputChannel = inputChannel + 1;
              }
            }
          }
          let value = dotProd + ${i?"bias[d1]":`${l}(0.0)`};
          ${J.setByOffset("global_idx","value")};
        `;return`
  ${e.registerUniforms(h).declareVariables(...te,J)}
  ${S}

    ${e.mainStart()}
    ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")};
  ${c?ye:ve}}`},Jn=(e,r,s)=>{let i=e.length>2,a=r.outputShape,c=Qe.size(a),l=[Math.ceil(c/64),1,1];kr("verbose",()=>`[conv2d_backprop_webgpu] dispatch = ${l}`);let h=r.format==="NHWC",_=["rank","rank"],w=[r.strides[0],r.strides[1]],v=[r.kernelShape[h?1:2],r.kernelShape[h?2:3]],y=[r.dilations[0],r.dilations[1]],d=[v[0]+(r.dilations[0]<=1?0:(r.kernelShape[h?1:2]-1)*(r.dilations[0]-1)),v[1]+(r.dilations[1]<=1?0:(r.kernelShape[h?2:3]-1)*(r.dilations[1]-1))],S=[d[0]-1-Math.floor((r.pads[0]+r.pads[2])/2),d[1]-1-Math.floor(r.pads[1]+r.pads[3])/2],B=!1,j=r.group,Y=e[1].dims,te=Y[0]/j,J=Y[1],ye=[{type:12,data:c},{type:12,data:w},{type:12,data:v},{type:12,data:y},{type:12,data:d},{type:6,data:S},{type:12,data:te},{type:12,data:J},...Tt(e[0].dims,e[1].dims)];i&&(ye.push(...Tt(e[2].dims)),_.push("rank")),ye.push(...Tt(a));let ve=l[1]===1&&l[2]===1,Ce=Ze=>{let Ke=[{name:"output_size",type:"u32"},{name:"strides",type:"u32",length:w.length},{name:"filter_dims",type:"u32",length:v.length},{name:"dilations",type:"u32",length:v.length},{name:"effective_filter_dims",type:"u32",length:d.length},{name:"pads",type:"i32",length:S.length},{name:"input_channels_per_group",type:"u32"},{name:"output_channels_per_group",type:"u32"}],ft=_r(e[0].dataType);return`${ui(Ze,e,a,i,ve,B,ft,Ke,h)}`};return{name:"ConvTranspose2D",shaderCache:{hint:`${r.cacheKey};`,inputDependencies:_},getRunData:()=>({dispatchGroup:{x:l[0],y:l[1],z:l[2]},outputs:[{dims:s?s(a):a,dataType:e[0].dataType}],programUniforms:ye}),getShaderSource:Ce}}}),Yi,ic,Zs,eo,di,ac,to,bo,La,Da,Nl=E(()=>{oc(),ci(),Mo(),mo(),Yi=(e,r,s,i,a,c)=>(e-1)*r+s+(i-1)*a+1-c,ic=(e,r,s,i,a)=>{let c=Math.floor(e/2);r==="SAME_UPPER"?(s[i]=c,s[a]=e-c):r==="SAME_LOWER"&&(s[i]=e-c,s[a]=c)},Zs=(e,r,s,i,a,c,l,h,_,w)=>{let v=e.length-2,y=w.length===0;_.length<v&&_.push(...Array(v-_.length).fill(0));let d=e[0],S=r[h?3:1]*a;for(let B=0,j=e.length-v-(h?1:0);B<v;++B,++j){let Y=e[j],te=y?Y*l[B]:w[B],J=Yi(Y,l[B],c[B],r[j],s[B],te);ic(J,i,c,B,B+v),y&&w.push(l[B]*(Y-1)+_[B]+(r[j]-1)*s[B]+1-c[B]-c[B+v])}w.splice(0,0,d),w.splice(h?3:1,0,S)},eo=(e,r)=>{let s=e.kernelShape.slice();if(e.kernelShape.length===0||e.kernelShape.reduce((y,d)=>y*d,1)===0){s.length=0;for(let y=2;y<r[1].dims.length;++y)s.push(r[1].dims[y])}let i=e.format==="NHWC";s.splice(0,0,r[1].dims[0]),s.splice(i?3:1,0,r[1].dims[1]);let a=e.pads.slice(),c=e.outputShape.slice(),l=e.outputPadding.slice(),h=r[0].dims,_=e.dilations.slice();if(_.reduce((y,d)=>y+d,0)===0){let y=r[0].dims.length-2;_=new Array(y).fill(1)}let w=e.strides.slice();if(w.reduce((y,d)=>y+d,0)===0){let y=r[0].dims.length-2;w=new Array(y).fill(1)}Zs(h,s,_,e.autoPad,e.group,a,w,i,l,c);let v=Object.assign({},e);return Object.assign(v,{kernelShape:s,pads:a,outputPadding:l,outputShape:c,dilations:_,strides:w}),v},di=e=>{let r=si(e),s=e.format,i=["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][typeof e.autoPad>"u"?0:e.autoPad],a=e.dilations,c=e.group,l=e.kernelShape,h=e.pads,_=e.strides,w=e.wIsConst(),v=e.outputPadding,y=e.outputShape;return{autoPad:i,format:s,dilations:a,group:c,kernelShape:l,outputPadding:v,outputShape:y,pads:h,strides:_,wIsConst:w,...r,cacheKey:`${e.format};${r.activation};`}},ac=(e,r)=>{if(!e||e.length!==2&&e.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(e[0].dims.length!==4&&e[0].dims.length!==3)throw new Error("currently only support 2-dimensional conv");if(e[0].dims.length!==e[1].dims.length)throw new Error("filter does not have same dimension as input");let s=e[0].dims[r.format==="NHWC"?e[0].dims.length-1:1],i=e[1].dims[0];if(s!==i)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");let a=e[1].dims[1]*r.group;if(e.length===3&&(e[2].dims.length!==1||e[2].dims[0]!==a))throw new Error("invalid bias");let c=e[0].dims.length-2;if(r.dilations.reduce((l,h)=>l+h,0)>0&&r.dilations.length!==c)throw new Error(`dilations should be ${c}D`);if(r.strides.reduce((l,h)=>l+h,0)>0&&r.strides.length!==c)throw new Error(`strides should be ${c}D`);if(r.pads.reduce((l,h)=>l+h,0)>0&&r.pads.length!==c*2)throw new Error(`pads should be ${c*2}D`);if(r.outputPadding.length!==c&&r.outputPadding.length!==0)throw new Error(`output_padding should be ${c}D`);if(r.kernelShape.reduce((l,h)=>l+h,0)>0&&r.kernelShape.length!==0&&r.kernelShape.length!==e[1].dims.length-2)throw new Error("invalid kernel shape");if(r.outputShape.length!==0&&r.outputShape.length!==e[0].dims.length-2)throw new Error("invalid output shape")},to=[2,3,1,0],bo=(e,r,s)=>{let i=eo(s,r),a=s.format==="NHWC",c=i.outputShape,l=c[a?3:1],h=r[0].dims[a?3:1];if(i.group!==1||l===1&&h===1){e.compute(Jn(r,i));return}let _=c[a?1:2],w=c[a?2:3],v=r[1].dims[2],y=r[1].dims[3],d=a?_*w:l,S=a?l:_*w,B=v*y*h,j=!0,Y=e.kernelCustomData.wT??e.compute(Un(r[1],to),{inputs:[1],outputs:[s.wIsConst?-2:-1]})[0];s.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=Y);let te=[r[0],Y],J=r.length===3;J&&(!a&&r[2].dims.length===1?te.push(r[2].reshape([r[2].dims[0],1,1])):te.push(r[2])),e.compute(Oa(te,i,c,d,S,B,J,j),{inputs:te})},La=(e,r)=>{let s=r.format==="NHWC",i=[e.inputs[0].reshape(s?[e.inputs[0].dims[0],1,e.inputs[0].dims[1],e.inputs[0].dims[2]]:[e.inputs[0].dims[0],e.inputs[0].dims[1],1,e.inputs[0].dims[2]]),e.inputs[1].reshape([e.inputs[1].dims[0],e.inputs[1].dims[1],1,e.inputs[1].dims[2]])];e.inputs.length===3&&i.push(e.inputs[2]);let a=r.kernelShape;(a.length===0||a[0]===0)&&(a=[e.inputs[1].dims[2]]);let c=r.dilations;(c.length===0||c[0]===0)&&(c=[1]);let l=r.strides;(l.length===0||l[0]===0)&&(l=[1]);let h=r.pads;h.length===0&&(h=[0,0]),h=[0,h[0],0,h[1]],l=[1].concat(l),c=[1].concat(c),a=[1].concat(a);let _=eo({...r,pads:h,strides:l,dilations:c,kernelShape:a},i);e.compute(Jn(i,_,w=>s?[w[0],w[2],w[3]]:[w[0],w[1],w[3]]))},Da=(e,r)=>{ac(e.inputs,r),e.inputs[0].dims.length===3?La(e,r):bo(e,e.inputs,r)}}),lc,Ji,ro,za=E(()=>{Rt(),qt(),hr(),or(),lc=(e,r,s,i)=>{let a=Qe.size(r),c=r.length,l=it("input",e,c),h=Ut("output",e,c),_=s.dataType===6?s.getInt32Array()[0]:Number(s.getBigInt64Array()[0]),w=Qe.normalizeAxis(_,c),v=y=>{let d=` i32(${l.indicesGet("inputIndices","uniforms.axis")}) `,S=Nt("uniforms.input_shape","uniforms.axis",c),B=i.reverse?d+(i.exclusive?" + 1":""):"0",j=i.reverse?S:d+(i.exclusive?"":" + 1");return`
                ${y.registerUniform("outputSize","u32").registerUniform("axis","u32").declareVariables(l,h)}
                ${y.mainStart()}
                  ${y.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
                  var inputIndices = ${h.offsetToIndices("global_idx")};
                  var sum = ${h.type.value}(0);
                  let first : i32 = ${B};
                  let last : i32 = ${j};
                  for (var i : i32 = first; i < last; i++) {
                    ${l.indicesSet("inputIndices","uniforms.axis","u32(i)")};
                    sum = sum + ${l.getByIndices("inputIndices")};
                  }
                  ${h.setByOffset("global_idx","sum")};
                }`};return{name:"CumSum",shaderCache:{hint:i.cacheKey,inputDependencies:["rank"]},getRunData:()=>({outputs:[{dims:r,dataType:e}],dispatchGroup:{x:Math.ceil(a/64)},programUniforms:[{type:12,data:a},{type:12,data:w},...Tt(r,r)]}),getShaderSource:v}},Ji=(e,r)=>{let s=e.inputs[0].dims,i=e.inputs[0].dataType,a=e.inputs[1];e.compute(lc(i,s,a,r),{inputs:[0]})},ro=e=>{let r=e.exclusive===1,s=e.reverse===1;return Ht({exclusive:r,reverse:s})}}),Zi,Vo,Wo,pi,uc,cc=E(()=>{Rt(),qt(),hr(),or(),Zi=e=>{if(!e||e.length!==1)throw new Error("DepthToSpace requires 1 input.");if(e[0].dims.length!==4)throw new Error("DepthToSpace requires 4D input.")},Vo=(e,r,s,i)=>{let a=[];a.push(`fn perm(i: ${i.type.indices}) -> ${s.type.indices} {
    var a: ${s.type.indices};`);for(let c=0;c<r;++c)a.push(s.indicesSet("a",e[c],`i[${c}]`));return a.push("return a;}"),a.join(`
`)},Wo=(e,r)=>{let s,i,a,c,l,h,_=r.format==="NHWC",w=r.blocksize,v=r.mode==="DCR";_?([s,i,a,c]=e.dims,l=v?[s,i,a,w,w,c/w**2]:[s,i,a,c/w**2,w,w],h=v?[0,1,3,2,4,5]:[0,1,4,2,5,3]):([s,i,a,c]=[e.dims[0],e.dims[2],e.dims[3],e.dims[1]],l=v?[s,w,w,c/w**2,i,a]:[s,c/w**2,w,w,i,a],h=v?[0,3,4,1,5,2]:[0,1,4,2,5,3]);let y=e.reshape(l),d=y.dims.length,S=e.dataType,B=it("a",S,d),j=Ut("output",S,d),Y=te=>`
  ${te.registerUniform("output_size","u32").declareVariables(B,j)}

  ${Vo(h,d,B,j)}

  ${te.mainStart()}
    ${te.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

    let indices = ${j.offsetToIndices("global_idx")};
    let aIndices = perm(indices);

    ${j.setByOffset("global_idx",B.getByIndices("aIndices"))}
  }`;return{name:"DepthToSpace",shaderCache:{hint:`${e.dims};${r.blocksize};${r.mode}`,inputDependencies:["rank"]},getRunData:te=>{let J=_?[s,i*w,a*w,c/w**2]:[s,c/w**2,i*w,a*w],ye=Qe.size(J),ve=y.dims,Ce=Qe.sortBasedOnPerm(ve,h);return{outputs:[{dims:J,dataType:te[0].dataType}],dispatchGroup:{x:Math.ceil(ye/64)},programUniforms:[{type:12,data:ye},...Tt(ve,Ce)]}},getShaderSource:Y}},pi=(e,r)=>{Zi(e.inputs),e.compute(Wo(e.inputs[0],r))},uc=e=>Ht({blocksize:e.blocksize,mode:e.mode,format:e.format})}),Hr,Go,fi,dc,Ba,Ul,Ko,en,hn,mn,Ra,ja=E(()=>{Rt(),qt(),hr(),or(),Hr="[a-zA-Z]|\\.\\.\\.",Go="("+Hr+")+",fi="^"+Go+"$",dc="("+Go+",)*"+Go,Ba="^"+dc+"$",Ul=class{constructor(e=-1){this.symbolToIndices=new Map,this.inputIndex=e}addSymbol(e,r){let s=this.symbolToIndices.get(e);s===void 0?s=[r]:s.push(r),this.symbolToIndices.set(e,s)}},Ko=class{constructor(e,r){var a;this.equation=r,this.hasEllipsis=!1,this.symbolToInfo=new Map,this.lhs=new Array,this.outputDims=[];let[s,i]=r.includes("->")?r.split("->",2):[r,""];if(!s.match(RegExp(Ba)))throw new Error("Invalid LHS term");if(s.split(",").forEach((c,l)=>{let h=e[l].dims.slice();if(!c.match(RegExp(fi)))throw new Error("Invalid LHS term");let _=this.processTerm(c,!0,h,l);this.lhs.push(_)}),i==="")i+=[...this.symbolToInfo.entries()].filter(([c,l])=>l.count===1||c==="...").map(([c])=>c).join("");else if(!i.match(RegExp(Go)))throw new Error("Invalid RHS");(a=i.match(RegExp(Hr,"g")))==null||a.forEach(c=>{if(c==="...")this.outputDims=this.outputDims.concat(this.ellipsisDims);else{let l=this.symbolToInfo.get(c);if(l===void 0)throw new Error("Invalid RHS symbol");this.outputDims.push(l.dimValue)}}),this.rhs=this.processTerm(i,!1,this.outputDims)}addSymbol(e,r,s){let i=this.symbolToInfo.get(e);if(i!==void 0){if(i.dimValue!==r&&i.count!==1)throw new Error("Dimension mismatch");i.count++,i.inputIndices.push(s)}else i={count:1,dimValue:r,inputIndices:[s]};this.symbolToInfo.set(e,i)}processTerm(e,r,s,i=-1){let a=s.length,c=!1,l=[],h=0;if(!e.match(RegExp(fi))&&!r&&e!=="")throw new Error("Invalid LHS term");let _=e.match(RegExp(Hr,"g")),w=new Ul(i);return _==null||_.forEach((v,y)=>{if(v==="..."){if(c)throw new Error("Only one ellipsis is allowed per input term");c=!0;let d=a-_.length+1;if(d<0)throw new Error("Ellipsis out of bounds");if(l=s.slice(h,h+d),this.hasEllipsis){if(this.ellipsisDims.length!==l.length||this.ellipsisDims.toString()!==l.toString())throw new Error("Ellipsis dimensions mismatch")}else if(r)this.hasEllipsis=!0,this.ellipsisDims=l;else throw new Error("Ellipsis must be specified in the LHS");for(let S=0;S<l.length;S++){let B=String.fromCharCode(48+S);w.addSymbol(B,y+S),this.addSymbol(B,s[h++],i)}}else w.addSymbol(v,y+(this.hasEllipsis?this.ellipsisDims.length-1:0)),this.addSymbol(v,s[h++],i)}),w}},en=e=>e+"_max",hn=(e,r,s,i)=>{let a=e.map(w=>w.length).map((w,v)=>it(`input${v}`,r,w)),c=Qe.size(i),l=Ut("output",r,i.length),h=[...s.symbolToInfo.keys()].filter(w=>!s.rhs.symbolToIndices.has(w)),_=w=>{let v=[],y="var prod = 1.0;",d="var sum = 0.0;",S="sum += prod;",B=[],j=[],Y=[],te=[],J=s.symbolToInfo.size===s.rhs.symbolToIndices.size;s.symbolToInfo.forEach((ve,Ce)=>{var Ze;if(s.rhs.symbolToIndices.has(Ce)){let Ke=(Ze=s.rhs.symbolToIndices.get(Ce))==null?void 0:Ze[0];Ke!==void 0&&s.lhs.forEach((ft,It)=>{if(ve.inputIndices.includes(It)){let Bt=ft.symbolToIndices.get(Ce);if(Bt===void 0)throw new Error("Invalid symbol error");Bt.forEach(cr=>{v.push(`${a[It].indicesSet(`input${It}Indices`,cr,l.indicesGet("outputIndices",Ke))}`)})}})}else s.lhs.forEach((Ke,ft)=>{if(ve.inputIndices.includes(ft)){let It=Ke.symbolToIndices.get(Ce);if(It===void 0)throw new Error("Invalid symbol error");It.forEach(Bt=>{B.push(`${a[ft].indicesSet(`input${ft}Indices`,Bt,`${Ce}`)}`)}),te.push(`prod *= ${a[ft].getByIndices(`input${ft}Indices`)};`)}}),j.push(`for(var ${Ce}: u32 = 0; ${Ce} < uniforms.${en(Ce)}; ${Ce}++) {`),Y.push("}")});let ye=J?[...v,`let sum = ${a.map((ve,Ce)=>ve.getByIndices(`input${Ce}Indices`)).join(" * ")};`]:[...v,d,...j,...B,y,...te,S,...Y];return`
            ${w.registerUniforms(h.map(ve=>({name:`${en(ve)}`,type:"u32"}))).registerUniform("outputSize","u32").declareVariables(...a,l)}

            ${w.mainStart()}
            ${w.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
            var outputIndices = ${l.offsetToIndices("global_idx")};
            ${a.map((ve,Ce)=>`var input${Ce}Indices: ${a[Ce].type.indices};`).join(`
`)}
            ${ye.join(`
`)};
            ${l.setByOffset("global_idx","sum")};
          }`};return{name:"Einsum",shaderCache:{hint:s.equation,inputDependencies:e.map(()=>"rank")},getRunData:()=>{let w=h.filter(y=>s.symbolToInfo.has(y)).map(y=>{var d;return{type:12,data:((d=s.symbolToInfo.get(y))==null?void 0:d.dimValue)||0}});w.push({type:12,data:c});let v=e.map((y,d)=>[...Tt(y)]).reduce((y,d)=>y.concat(d),w);return v.push(...Tt(i)),{outputs:[{dims:i,dataType:r}],dispatchGroup:{x:Math.ceil(c/64)},programUniforms:v}},getShaderSource:_}},mn=(e,r)=>{let s=new Ko(e.inputs,r.equation),i=s.outputDims,a=e.inputs.map((c,l)=>c.dims);e.compute(hn(a,e.inputs[0].dataType,s,i))},Ra=e=>{let r=e.equation.replace(/\s+/g,"");return Ht({equation:r})}}),hi,pc,In,Na,Vl,fc=E(()=>{Rt(),qt(),or(),hi=e=>{if(!e||e.length!==2)throw new Error("Expand requires 2 input.");let r=e[0].dims,s=Array.from(e[1].getBigInt64Array(),Number),i=s.length<r.length?0:s.length-r.length,a=r.length<s.length?0:r.length-s.length;for(;i<s.length&&a<r.length;++i,++a)if(s[i]!==r[a]&&s[i]!==1&&r[a]!==1)throw new Error("Expand requires shape to be broadcastable to input")},pc=(e,r)=>{let s=e.length-r.length,i=[];for(let a=0;a<s;++a)i.push(e[a]);for(let a=0;a<r.length;++a)i.push(r[a]===1?e[a+s]:r[a]);return i},In=(e,r)=>e.length>r.length?pc(e,r):pc(r,e),Na=e=>{let r=e[0].dims,s=Array.from(e[1].getBigInt64Array(),Number),i=In(r,s),a=e[0].dataType,c=a===9?4:1,l=Math.ceil(Qe.size(i)/c),h=w=>{let v=it("input",a,r.length,c),y=Ut("output",a,i.length,c),d;if(a===9){let S=(B,j,Y="")=>`
          let outputIndices${j} = ${y.offsetToIndices(`outputOffset + ${j}u`)};
          let offset${j} = ${v.broadcastedIndicesToOffset(`outputIndices${j}`,y)};
          let index${j} = offset${j} / 4u;
          let component${j} = offset${j} % 4u;
          ${B}[${j}] = ${Y}(${v.getByOffset(`index${j}`)}[component${j}]);
        `;d=`
        let outputOffset = global_idx * ${c};
        var data = vec4<u32>(0);
        ${S("data",0,"u32")}
        ${S("data",1,"u32")}
        ${S("data",2,"u32")}
        ${S("data",3,"u32")}
        ${y.setByOffset("global_idx","data")}
      }`}else d=`
        let outputIndices = ${y.offsetToIndices("global_idx")};
        let inputOffset = ${v.broadcastedIndicesToOffset("outputIndices",y)};
        ${y.setByOffset("global_idx",v.getByOffset("inputOffset"))}
      }`;return`
    ${w.registerUniform("vec_size","u32").declareVariables(v,y)}
    ${w.mainStart()}
    ${w.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}
    ${d}`},_=[{type:12,data:l},...Tt(r,i)];return{name:"Expand",shaderCache:{hint:`${i.length}`,inputDependencies:["rank"]},getShaderSource:h,getRunData:()=>({outputs:[{dims:i,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(l/64)},programUniforms:_})}},Vl=e=>{hi(e.inputs),e.compute(Na(e.inputs),{inputs:[0]})}}),as,ls,Ua=E(()=>{Rt(),qt(),or(),ka(),as=e=>{let r=e[0].dataType,s=Qe.size(e[0].dims),i=Qe.size(e[1].dims),a=i%4===0,c=l=>{let h=it("x",r,[1],4),_=it("bias",r,[1],4),w=Ut("y",r,[1],4),v=[{name:"output_vec_size",type:"u32"},{name:"bias_size",type:"u32"}],y=S=>`
      let bias${S}_offset: u32 = (global_idx * 4 + ${S}) % uniforms.bias_size;
      let bias${S} = ${_.getByOffset(`bias${S}_offset / 4`)}[bias${S}_offset % 4];`,d=a?`
      let bias = ${_.getByOffset("global_idx % (uniforms.bias_size / 4)")};`:`${y(0)}${y(1)}${y(2)}${y(3)}
      let bias = ${h.type.value}(bias0, bias1, bias2, bias3);`;return`${l.registerUniforms(v).declareVariables(h,_,w)}

    ${Ui($r(r))}

    ${l.mainStart(gn)}
      ${l.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_vec_size")}

      let x = ${h.getByOffset("global_idx")};
      ${d}
      let x_in = x + bias;
      ${w.setByOffset("global_idx",Ca("x_in"))}
    }`};return{name:"FastGeluWithBias",shaderCache:{hint:`${a}`,inputDependencies:["type","type"]},getShaderSource:c,getRunData:l=>({outputs:[{dims:l[0].dims,dataType:l[0].dataType}],programUniforms:[{type:12,data:Math.ceil(s/4)},{type:12,data:i}],dispatchGroup:{x:Math.ceil(s/gn/4)}})}},ls=e=>{e.inputs.length<2||Qe.size(e.inputs[1].dims)===0?Sa(e):e.compute(as(e.inputs))}}),Wl,Gl,Kl,Va,hp=E(()=>{Rt(),qt(),hr(),or(),Wl=e=>{if(!e||e.length!==2)throw new Error("Gather requires 2 inputs.")},Gl=(e,r)=>{let s=e[0].dims,i=e[1].dims,a=s.length,c=Qe.normalizeAxis(r.axis,a),l=s.slice(0);l.splice(c,1,...i);let h=s[c],_=e[0].dataType===9?4:1,w=Math.ceil(Qe.size(l)/_),v=[{type:12,data:w},{type:6,data:h},{type:12,data:c},...Tt(e[0].dims,e[1].dims,l)],y=d=>{let S=it("data",e[0].dataType,e[0].dims.length,_),B=it("inputIndices",e[1].dataType,e[1].dims.length),j=Ut("output",e[0].dataType,l.length,_),Y=J=>{let ye=i.length,ve=`var indicesIndices${J}  = ${B.type.indices}(0);`;for(let Ce=0;Ce<ye;Ce++)ve+=`${ye>1?`indicesIndices${J}[${Ce}]`:`indicesIndices${J}`} = ${l.length>1?`outputIndices${J}[uniforms.axis + ${Ce}]`:`outputIndices${J}`};`;ve+=`
          var idx${J} = ${B.getByIndices(`indicesIndices${J}`)};
          if (idx${J} < 0) {
            idx${J} = idx${J} + uniforms.axisDimLimit;
          }
          var dataIndices${J} : ${S.type.indices};
        `;for(let Ce=0,Ze=0;Ce<a;Ce++)Ce===c?(ve+=`${a>1?`dataIndices${J}[${Ce}]`:`dataIndices${J}`} = u32(idx${J});`,Ze+=ye):(ve+=`${a>1?`dataIndices${J}[${Ce}]`:`dataIndices${J}`} = ${l.length>1?`outputIndices${J}[${Ze}]`:`outputIndices${J}`};`,Ze++);return ve},te;if(e[0].dataType===9){let J=(ye,ve,Ce="")=>`
          let outputIndices${ve} = ${j.offsetToIndices(`outputOffset + ${ve}u`)};
          ${Y(ve)};
          let offset${ve} = ${S.indicesToOffset(`dataIndices${ve}`)};
          let index${ve} = offset${ve} / 4u;
          let component${ve} = offset${ve} % 4u;
          ${ye}[${ve}] = ${Ce}(${S.getByOffset(`index${ve}`)}[component${ve}]);
        `;te=`
        let outputOffset = global_idx * ${_};
        var value = vec4<u32>(0);
        ${J("value",0,"u32")}
        ${J("value",1,"u32")}
        ${J("value",2,"u32")}
        ${J("value",3,"u32")}
        ${j.setByOffset("global_idx","value")}
      `}else te=`
      let outputIndices = ${j.offsetToIndices("global_idx")};
      ${Y("")};
      let value = ${S.getByIndices("dataIndices")};
      ${j.setByOffset("global_idx","value")};
      `;return`
      ${d.registerUniform("outputSize","u32").registerUniform("axisDimLimit","i32").registerUniform("axis","u32").declareVariables(S,B,j)}
      ${d.mainStart()}
        ${d.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
        ${te}
      }`};return{name:"Gather",shaderCache:{hint:r.cacheKey,inputDependencies:["rank","rank"]},getRunData:()=>({outputs:[{dims:l,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(w/64)},programUniforms:v}),getShaderSource:y}},Kl=e=>Ht({axis:e.axis}),Va=(e,r)=>{let s=e.inputs;Wl(s),e.compute(Gl(e.inputs,r))}}),hc,mc,Hl,_c,zd=E(()=>{Rt(),qt(),hr(),or(),hc=(e,r)=>{if(e.length<3||e.length>4)throw new Error("GatherBlockQuantized requires 3 or 4 inputs.");let s=Qe.normalizeAxis(r.quantizeAxis,e[0].dims.length),i=r.blockSize,a=e[0],c=e[2],l=e.length===4?e[3]:void 0;if(c.dims.length!==a.dims.length||!a.dims.map((h,_)=>_===s?Math.ceil(h/i)===c.dims[_]:h===c.dims[_]).reduce((h,_)=>h&&_,!0))throw new Error("Scales must have the same rank as the input tensor and the dims should match except on gatherAxis.");if(l){if(l.dataType!==a.dataType)throw new Error("Zero point must have the same data type as the input tensor.");if(l.dims.length!==c.dims.length||!l.dims.map((h,_)=>h===c.dims[_]).reduce((h,_)=>h&&_,!0))throw new Error("Zero point must have the same rank as the input tensor and the dims should match except on quantizeAxis.")}},mc=(e,r)=>{let s=e[0].dims,i=e[1].dims,a=s.length,c=Qe.normalizeAxis(r.gatherAxis,a),l=Qe.normalizeAxis(r.quantizeAxis,a),h=s.slice(0);h.splice(c,1,...i);let _=Qe.size(h),w=e[2].dataType,v=e[0].dataType===22,y=[{type:12,data:_},{type:12,data:l},{type:12,data:c},{type:12,data:r.blockSize},...Tt(...e.map((S,B)=>S.dims),h)],d=S=>{let B=it("data",e[0].dataType,e[0].dims.length),j=it("inputIndices",e[1].dataType,e[1].dims.length),Y=it("scales",e[2].dataType,e[2].dims.length),te=e.length>3?it("zeroPoint",e[3].dataType,e[3].dims.length):void 0,J=Ut("output",w,h.length),ye=[B,j,Y];te&&ye.push(te);let ve=[{name:"output_size",type:"u32"},{name:"quantize_axis",type:"u32"},{name:"gather_axis",type:"u32"},{name:"block_size",type:"u32"}];return`
        ${S.registerUniforms(ve).declareVariables(...ye,J)}
        ${S.mainStart()}
        let output_indices = ${J.offsetToIndices("global_idx")};
        var indices_indices = ${j.type.indices}(0);
        ${i.length>1?`
          for (var i: u32 = 0; i < ${i.length}; i++) {
            let index = ${J.indicesGet("output_indices","uniforms.gather_axis + i")};
            ${j.indicesSet("indices_indices","i","index")};
          }`:`indices_indices = ${J.indicesGet("output_indices","uniforms.gather_axis")};`};
        var data_indices = ${B.type.indices}(0);
        for (var i: u32 = 0; i < uniforms.gather_axis; i++) {
          let index = ${J.indicesGet("output_indices","i")};
          ${B.indicesSet("data_indices","i","index")};
        }
        var index_from_indices = ${j.getByIndices("indices_indices")};
        if (index_from_indices < 0) {
          index_from_indices += ${s[c]};
        }
        ${B.indicesSet("data_indices","uniforms.gather_axis","u32(index_from_indices)")};
        for (var i = uniforms.gather_axis + 1; i < ${h.length}; i++) {
          let index = ${J.indicesGet("output_indices",`i + ${i.length} - 1`)};
          ${B.indicesSet("data_indices","i","index")};
        }
        let data_offset = ${B.indicesToOffset("data_indices")};
        let data_index = data_offset % 8;
        // Convert 4-bit packed data to 8-bit packed data.
        let packed_4bit_quantized_data = ${B.getByOffset("data_offset / 8")};
        let packed_8bit_quantized_data = (packed_4bit_quantized_data >> (4 * (data_index % 2))) & 0x0f0f0f0f;
        let quantized_data_vec = ${v?"unpack4xI8":"unpack4xU8"}(u32(packed_8bit_quantized_data));
        let quantized_data = quantized_data_vec[data_index / 2];
        var scale_indices = data_indices;
        let quantize_axis_index = ${Y.indicesGet("data_indices","uniforms.quantize_axis")} / uniforms.block_size;
        ${Y.indicesSet("scale_indices","uniforms.quantize_axis","quantize_axis_index")};
        var scale = ${Y.getByIndices("scale_indices")};
        ${te?`
              let zero_point_indices = scale_indices;
              let zero_point_offset = ${te.indicesToOffset("zero_point_indices")};
              let zero_point_index = zero_point_offset % 8;
              let packed_4bit_zero_points = ${te.getByOffset("zero_point_offset / 8")};
              let packed_8bit_zero_points = (packed_4bit_zero_points >> (4 * (zero_point_index % 2))) & 0x0f0f0f0f;
              let zero_point_vec = ${v?"unpack4xI8":"unpack4xU8"}(u32(packed_8bit_zero_points));
              let zero_point = zero_point_vec[zero_point_index / 2];`:"var zero_point = 0"};
        let dequantized_data = ${$r(w)}(quantized_data - zero_point) * scale;
        ${J.setByOffset("global_idx","dequantized_data")};
    }`};return{name:"GatherBlockQuantized",shaderCache:{hint:`${r.cacheKey};${e.filter((S,B)=>B!==1).map(S=>S.dims.join("_")).join(";")}`,inputDependencies:Array.from({length:e.length},(S,B)=>"rank")},getRunData:()=>({outputs:[{dims:h,dataType:w}],dispatchGroup:{x:Math.ceil(_/64)},programUniforms:y}),getShaderSource:d}},Hl=(e,r)=>{let s=e.inputs;hc(s,r),e.compute(mc(e.inputs,r))},_c=e=>Ht({blockSize:e.blockSize,gatherAxis:e.gatherAxis,quantizeAxis:e.quantizeAxis})}),mi,gc,Wa,ea,mp=E(()=>{Rt(),qt(),hr(),or(),mi=e=>{if(!e||e.length!==2)throw new Error("GatherElements requires 2 inputs.");if(e[0].dims.length<1)throw new Error("GatherElements requires that the data input be rank >= 1.");if(e[0].dims.length!==e[1].dims.length)throw new Error(`GatherElements requires that the data input and
                     indices input tensors be of same rank.`)},gc=(e,r)=>{let s=e[0].dims,i=e[0].dataType,a=s.length,c=e[1].dims,l=e[1].dataType,h=Qe.normalizeAxis(r.axis,a),_=s[h],w=c.slice(0),v=Qe.size(w),y=it("input",i,a),d=it("indicesInput",l,c.length),S=Ut("output",i,w.length),B=[{type:12,data:v},{type:6,data:_},{type:12,data:h}];return B.push(...Tt(s,c,w)),{name:"GatherElements",shaderCache:{inputDependencies:["rank","rank"]},getRunData:()=>({outputs:[{dims:w,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(v/64)},programUniforms:B}),getShaderSource:j=>`
      ${j.registerUniform("outputSize","u32").registerUniform("axisDimLimit","i32").registerUniform("axis","u32").declareVariables(y,d,S)}
      ${j.mainStart()}
      ${j.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}

      let outputIndices = ${S.offsetToIndices("global_idx")};

      var idx = ${d.getByOffset("global_idx")};
      if (idx < 0) {
        idx = idx + uniforms.axisDimLimit;
      }
      var inputIndices = ${y.type.indices}(outputIndices);
      ${y.indicesSet("inputIndices","uniforms.axis","u32(idx)")};
      let value = ${y.getByIndices("inputIndices")};

      ${S.setByOffset("global_idx","value")};
  }`}},Wa=e=>Ht({axis:e.axis}),ea=(e,r)=>{let s=e.inputs;mi(s),e.compute(gc(e.inputs,r))}}),yc,ql,Ql,wc,Bd=E(()=>{Rt(),qt(),or(),yc=e=>{if(!e)throw new Error("Input is missing");if(e.length<2||e.length>3)throw new Error("Invaid input number.");if(e.length===3&&e[2].dims.length>2)throw new Error("Invalid input shape of C");if(e[0].dataType!==e[1].dataType||e.length===3&&e[0].dataType!==e[2].dataType)throw new Error("Input types are mismatched")},ql=(e,r)=>{let s=e[0].dims.slice(),i=e[1].dims.slice(),[a,c,l]=Mn.getShapeOfGemmResult(s,r.transA,i,r.transB,e.length===3?e[2].dims:void 0),h=[a,c];if(!h)throw new Error("Can't use gemm on the given tensors");let _=Qe.size(h),w=[{type:12,data:_},{type:12,data:a},{type:12,data:c},{type:12,data:l},{type:1,data:r.alpha},{type:1,data:r.beta}],v=["type","type"];e.length===3&&(w.push(...Tt(e[2].dims)),v.push("rank")),w.push(...Tt(h));let y=d=>{let S="";r.transA&&r.transB?S="value += a[k * uniforms.M + m] * b[n * uniforms.K + k];":r.transA&&!r.transB?S="value += a[k * uniforms.M + m] * b[k * uniforms.N + n];":!r.transA&&r.transB?S="value += a[m * uniforms.K + k] * b[n * uniforms.K + k];":!r.transA&&!r.transB&&(S="value += a[m * uniforms.K + k] * b[k * uniforms.N + n];");let B=r.alpha===1?"":"value *= uniforms.alpha;",j=it("a",e[0].dataType,e[0].dims),Y=it("b",e[1].dataType,e[1].dims),te=j.type.value,J=null,ye=[j,Y];e.length===3&&(J=it("c",e[2].dataType,e[2].dims.length),ye.push(J));let ve=Ut("output",e[0].dataType,h.length);ye.push(ve);let Ce=[{name:"output_size",type:"u32"},{name:"M",type:"u32"},{name:"N",type:"u32"},{name:"K",type:"u32"},{name:"alpha",type:"f32"},{name:"beta",type:"f32"}];return`
  ${d.registerUniforms(Ce).declareVariables(...ye)}

  ${d.mainStart()}
    ${d.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

    let m = global_idx / uniforms.N;
    let n = global_idx % uniforms.N;

    var value = ${te}(0);
    for (var k: u32 = 0u; k < uniforms.K; k++) {
      ${S}
    }

    ${B}
    ${J!=null?`let cOffset = ${J.broadcastedIndicesToOffset("vec2(m, n)",ve)}; value += ${te}(uniforms.beta) * ${J.getByOffset("cOffset")};`:""}
    output[global_idx] = value;
  }`};return{name:"Gemm",shaderCache:{hint:`${r.cacheKey}`,inputDependencies:v},getRunData:()=>({outputs:[{dims:h,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(_/64)},programUniforms:w}),getShaderSource:y}},Ql=e=>{let r=e.transA,s=e.transB,i=e.alpha,a=e.beta;return{transA:r,transB:s,alpha:i,beta:a,cacheKey:`${e.transA};${e.transB};${e.alpha===1}`}},wc=(e,r)=>{yc(e.inputs),e.compute(ql(e.inputs,r))}}),xn,vc,Mc,Ga,Rd,ta,xc,jd=E(()=>{Rt(),qt(),hr(),we(),Do(),or(),mo(),xn=(e,r)=>e.length>r&&e[r].dims.length>0?e[r]:void 0,vc=(e,r)=>{let s=e[0],i=xn(e,1),a=xn(e,2),c=xn(e,3),l=xn(e,4),h=xn(e,5),_=xn(e,6),w=xn(e,7);if(s.dims.length!==3&&s.dims.length!==5)throw new Error("Input query is expected to have 3 or 5 dimensions");let v=s.dims[0],y=s.dims[1],d=s.dims.length===3?s.dims[2]:r.numHeads*s.dims[4],S=y,B=0,j=0,Y=Math.floor(d/r.numHeads);if(_&&w&&Qe.size(_.dims)&&Qe.size(w.dims)){if(_.dims.length!==4)throw new Error('Input "past_key" is expected to have 4 dimensions');if(_.dims[0]!==v||_.dims[1]!==r.numHeads||_.dims[3]!==Y)throw new Error('Input "past_key" shape (batch_size, num_heads, past_sequence_length, head_size)');if(w.dims[0]!==v||w.dims[1]!==r.numHeads||w.dims[3]!==Y)throw new Error('Input "past_value" shape (batch_size, num_heads, past_sequence_length, head_size)');if(_.dims[2]!==w.dims[2])throw new Error('Input "past_key" and "past_value" shall have same dim 2 (past_sequence_length)');if(w.dims.length!==4)throw new Error('Input "past_value" is expected to have 4 dimensions');B=_.dims[2],j=_.dims[2]}else if(_&&Qe.size(_.dims)||w&&Qe.size(w.dims))throw new Error('Input "past_key" and "past_value" shall be both present or both absent');let te;if(i&&Qe.size(i.dims)>0){if(s.dims.length!==3)throw new Error('Input "query" is expected to have 3 dimensions when key is given');if(i.dims.length<3||i.dims.length>5)throw new Error('Input "key" is expected to have 3, 4, or 5 dimensions');if(s.dims[0]!==i.dims[0])throw new Error('Input "query" and "key" shall have same dim 0 (batch size)');if(i.dims.length===3){if(i.dims[2]!==s.dims[2])throw new Error('Input "query" and "key" shall have same dim 2 (hidden_size)');te=2,S=i.dims[1]}else if(i.dims.length===5){if(i.dims[2]!==r.numHeads||i.dims[3]!==2||i.dims[4]!==Y)throw new Error('Expect "key" shape (batch_size, kv_sequence_length, num_heads, 2, head_size) for packed kv');if(a)throw new Error('Expect "value" be none when "key" has packed kv format.');te=5,S=i.dims[1]}else{if(i.dims[1]!==r.numHeads||i.dims[3]!==Y)throw new Error('Expect "key" shape (batch_size, num_heads, kv_sequence_length, head_size) for past_key');te=0,S=i.dims[2]}}else{if(s.dims.length!==5)throw new Error('Input "query" is expected to have 5 dimensions when key is empty');if(s.dims[2]!==r.numHeads||s.dims[3]!==3)throw new Error('Expect "query" shape (batch_size, kv_sequence_length, num_heads, 3, head_size) for packed kv');te=3}if(c&&Qe.size(c.dims)>0){if(c.dims.length!==1)throw new Error('Input "bias" is expected to have 1 dimension');if(i&&i.dims.length===5&&i.dims[3]===2)throw new Error("bias is not allowed for packed kv.")}let J=B+S,ye=0;if(l&&Qe.size(l.dims)>0){ye=8;let Ke=l.dims;throw Ke.length===1?Ke[0]===v?ye=1:Ke[0]===3*v+2&&(ye=3):Ke.length===2&&Ke[0]===v&&Ke[1]===J&&(ye=5),ye===8?new Error('Input "key_padding_mask" shape shall be (batch_size) or (batch_size, total_sequence_length)'):new Error("Mask not supported")}let ve=!1,Ce=d;if(a&&Qe.size(a.dims)>0){if(a.dims.length!==3&&a.dims.length!==4)throw new Error('Input "value" is expected to have 3 or 4 dimensions');if(s.dims[0]!==a.dims[0])throw new Error('Input "query" and "value" shall have same dim 0 (batch_size)');if(a.dims.length===3){if(S!==a.dims[1])throw new Error('Input "key" and "value" shall have the same dim 1 (kv_sequence_length)');Ce=a.dims[2]}else{if(S!==a.dims[2])throw new Error('Input "key" and "value" shall have the same dim 2 (kv_sequence_length)');Ce=a.dims[1]*a.dims[3],ve=!0}}let Ze=!1;if(l&&Qe.size(l.dims)>0)throw new Error("Key padding mask is not supported");if(h&&Qe.size(h.dims)>0){if(h.dims.length!==4)throw new Error('Input "attention_bias" is expected to have 4 dimensions');if(h.dims[0]!==v||h.dims[1]!==r.numHeads||h.dims[2]!==y||h.dims[3]!==J)throw new Error('Expect "attention_bias" shape (batch_size, num_heads, sequence_length, total_sequence_length)')}return{batchSize:v,sequenceLength:y,pastSequenceLength:B,kvSequenceLength:S,totalSequenceLength:J,maxSequenceLength:j,inputHiddenSize:0,hiddenSize:d,vHiddenSize:Ce,headSize:Y,vHeadSize:Math.floor(Ce/r.numHeads),numHeads:r.numHeads,isUnidirectional:!1,pastPresentShareBuffer:!1,maskFilterValue:r.maskFilterValue,maskType:ye,scale:r.scale,broadcastResPosBias:Ze,passPastInKv:ve,qkvFormat:te}},Mc=e=>Ht({...e}),Ga=Ht({perm:[0,2,1,3]}),Rd=(e,r,s,i,a,c,l)=>{let h=[i,a,c],_=Qe.size(h),w=[{type:12,data:_},{type:12,data:l},{type:12,data:c}],v=y=>{let d=Ut("qkv_with_bias",r.dataType,h),S=it("qkv",r.dataType,h),B=it("bias",s.dataType,h),j=[{name:"output_size",type:"u32"},{name:"bias_offset",type:"u32"},{name:"hidden_size",type:"u32"}];return`
  ${y.registerUniforms(j).declareVariables(S,B,d)}
  ${y.mainStart()}
    ${y.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    let bias_offset_idx = (global_idx % uniforms.hidden_size) + uniforms.bias_offset;

    qkv_with_bias[global_idx] = qkv[global_idx] + bias[bias_offset_idx];
  }`};return e.compute({name:"MultiHeadAttentionAddBias",shaderCache:{inputDependencies:["type","type"]},getRunData:()=>({outputs:[{dims:h,dataType:r.dataType,gpuDataType:0}],dispatchGroup:{x:Math.ceil(_/64)},programUniforms:w}),getShaderSource:v},{inputs:[r,s],outputs:[-1]})[0]},ta=(e,r,s,i,a,c,l,h)=>{let _=c;if(l&&Qe.size(l.dims)>0){if(i===1)throw new Error("AddBiasReshape is not implemented. Please export your model with packed QKV or KV");return _=Rd(e,c,l,r,i,s*a,h),_=_.reshape([r,i,s,a]),s===1||i===1?_:e.compute(Un(_,Ga.perm),{inputs:[_],outputs:[-1]})[0]}else return c.dims.length===3&&(_=c.reshape([r,i,s,a])),s===1||i===1?_:e.compute(Un(_,Ga.perm),{inputs:[_],outputs:[-1]})[0]},xc=(e,r)=>{let s=vc(e.inputs,r),i=e.inputs[0],a=xn(e.inputs,1),c=xn(e.inputs,2),l=xn(e.inputs,3),h=xn(e.inputs,4),_=xn(e.inputs,5),w=xn(e.inputs,6),v=xn(e.inputs,7);if(i.dims.length===5)throw new Error("Packed QKV is not implemented");if((a==null?void 0:a.dims.length)===5)throw new Error("Packed KV is not implemented");let y=a&&c&&a.dims.length===4&&c.dims.length===4,d=ta(e,s.batchSize,s.numHeads,s.sequenceLength,s.headSize,i,l,0);if(y)return Fi(e,d,a,c,h,void 0,w,v,_,s,r);if(!a||!c)throw new Error("key and value must be provided");let S=ta(e,s.batchSize,s.numHeads,s.kvSequenceLength,s.headSize,a,l,s.hiddenSize),B=ta(e,s.batchSize,s.numHeads,s.kvSequenceLength,s.vHeadSize,c,l,2*s.hiddenSize);Fi(e,d,S,B,h,void 0,w,v,_,s,r)}}),Xl,Tc,bc,ra,Nd,Ud=E(()=>{Rt(),qt(),or(),Xl=e=>Array.from(e.getBigInt64Array(),Number),Tc=e=>{if(!e||e.length!==2)throw new Error("Tile requires 2 inputs.");if(e[0].dataType!==1&&e[0].dataType!==10&&e[0].dataType!==6&&e[0].dataType!==12)throw new Error("Tile only support float, float16, int32, and uint32 data types");if(e[1].dataType!==7)throw new Error("Tile `repeats` input should be of int64 data type");if(e[1].dims.length!==1)throw new Error("Tile `repeats` input should be 1-D");if(Xl(e[1]).length!==e[0].dims.length)throw new Error("Tile `repeats` input should have same number of elements as rank of input data tensor")},bc=(e,r)=>{let s=[];for(let i=0;i<e.length;++i)s.push(e[i]*r[i]);return s},ra=(e,r)=>{let s=e[0].dims,i=r??Xl(e[1]),a=bc(s,i),c=Qe.size(a),l=e[0].dataType,h=it("input",l,s.length),_=Ut("output",l,a.length),w=v=>`
      const inputShape = ${h.indices(...s)};
      ${v.registerUniform("output_size","u32").declareVariables(h,_)}
      ${v.mainStart()}
      ${v.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
      let output_indices = ${_.offsetToIndices("global_idx")};
      var input_indices: ${h.type.indices};
      for (var i = 0; i < ${s.length}; i++) {
        let input_dim_i = ${h.indicesGet("uniforms.input_shape","i")};
        let input_dim_value = ${_.indicesGet("output_indices","i")}  % input_dim_i;

        ${h.indicesSet("input_indices","i","input_dim_value")}
      }
      ${_.setByOffset("global_idx",h.getByIndices("input_indices"))}
    }`;return{name:"Tile",shaderCache:{hint:`${i}`,inputDependencies:["rank"]},getRunData:()=>({outputs:[{dims:a,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(c/64)},programUniforms:[{type:12,data:c},...Tt(e[0].dims,a)]}),getShaderSource:w}},Nd=e=>{Tc(e.inputs),e.compute(ra(e.inputs),{inputs:[0]})}}),Vd,us,Ka,Ha,Yl,Jl,Wd=E(()=>{Rt(),qt(),hr(),Do(),or(),jd(),Ud(),mo(),Vd=(e,r)=>{let s=e[0],i=e[1],a=e[2],c=e[3],l=e[4];if(s.dims.length!==3&&s.dims.length!==5)throw new Error("Input query is expected to have 3 or 5 dimensions");let h=!1,_=s.dims[0],w=s.dims[1],v=s.dims.length===3?h?s.dims[2]/3:s.dims[2]:r.numHeads*s.dims[4],y=w,d=0,S=0,B=Math.floor(v/r.numHeads),j=c&&c.dims.length!==0,Y=l&&l.dims.length!==0,te=!0;if(j&&Y){if(c.dims.length!==4)throw new Error('Input "past_key" is expected to have 4 dimensions');if(l.dims.length!==4)throw new Error('Input "past_value" is expected to have 4 dimensions');d=c.dims[1],S=c.dims[1]}else if(j||Y)throw new Error('Input "past_key" and "past_value" shall be both present or both absent');let J;if(i){if(s.dims.length!==3)throw new Error('Input "query" is expected to have 3 dimensions when key is given');if(i.dims.length<3||i.dims.length>5)throw new Error('Input "key" is expected to have 3, 4, or 5 dimensions');if(s.dims[0]!==i.dims[0])throw new Error('Input "query" and "key" shall have same dim 0 (batch size)');if(i.dims.length===3){if(s.dims[2]%i.dims[2]!==0)throw new Error('Dimension 2 of "query" should be a multiple of "key"');J=2,y=i.dims[1]}else if(i.dims.length===5){if(i.dims[2]!==r.numHeads||i.dims[3]!==2||i.dims[4]!==B)throw new Error('Expect "key" shape (batch_size, kv_sequence_length, num_heads, 2, head_size) for packed kv');if(a)throw new Error('Expect "value" be none when "key" has packed kv format.');J=5,y=i.dims[1]}else{if(i.dims[1]!==r.numHeads||i.dims[3]!==B)throw new Error('Expect "key" shape (batch_size, num_heads, kv_sequence_length, head_size) for past_key');J=0,y=i.dims[2]}}else{if(s.dims.length!==3&&s.dims.length!==5)throw new Error('Input "query" is expected to have 3 or 5 dimensions when key is empty');if(s.dims.length===5&&(s.dims[2]!==r.numHeads||s.dims[3]!==3))throw new Error('Expect "query" shape (batch_size, kv_sequence_length, num_heads, 3, head_size) for packed kv');J=3}let ye=0,ve=!1,Ce=v;if(a){if(a.dims.length!==3&&a.dims.length!==4)throw new Error('Input "value" is expected to have 3 or 4 dimensions');if(s.dims[0]!==a.dims[0])throw new Error('Input "query" and "value" shall have same dim 0 (batch_size)');if(a.dims.length===3){if(y!==a.dims[1])throw new Error('Input "key" and "value" shall have the same dim 1 (kv_sequence_length)');Ce=a.dims[2]}else{if(y!==a.dims[2])throw new Error('Input "past_key" and "past_value" shall have the same dim 2 (kv_sequence_length)');Ce=a.dims[1]*a.dims[3],ve=!0}}let Ze=d+y;return{batchSize:_,sequenceLength:w,pastSequenceLength:d,kvSequenceLength:y,totalSequenceLength:Ze,maxSequenceLength:S,inputHiddenSize:0,hiddenSize:v,vHiddenSize:Ce,headSize:B,vHeadSize:Math.floor(Ce/r.kvNumHeads),numHeads:r.numHeads,kvNumHeads:r.kvNumHeads,nReps:r.numHeads/r.kvNumHeads,pastPresentShareBuffer:!1,maskType:ye,scale:r.scale,broadcastResPosBias:!1,passPastInKv:ve,qkvFormat:J,isPastkvBSNH:te}},us=(e,r,s,i)=>{let a=[i.batchSize,i.totalSequenceLength,i.kvNumHeads,i.headSize],c=4,l=Qe.size(a)/c,h=i.totalSequenceLength,_=Ut("present_kv",s,a.length,c),w=it("new_kv",e.dataType,e.dims.length,c),v=r?it("past_kv",r.dataType,r.dims.length,c):void 0,y=Math.ceil(i.headSize/c),d={x:h,y:e.dims[0],z:1},S=r?["rank","rank"]:["rank"],B=[{type:12,data:l},{type:12,data:i.pastSequenceLength},{type:12,data:i.kvSequenceLength},{type:12,data:i.totalSequenceLength}],j=[w];v?(B.push(...Tt(e.dims),...Tt(r.dims),...Tt(a)),j.push(v)):B.push(...Tt(e.dims),...Tt(a));let Y=[{name:"output_size",type:"u32"},{name:"past_seqlen",type:"u32"},{name:"new_seqlen",type:"u32"},{name:"present_seqlen",type:"u32"}],te=`      let past_batch_stride = uniforms.past_seqlen * num_heads * H;
        var past_head_stride = uniforms.past_seqlen * H;
        if (is_bsnh) {
          past_head_stride = H;
        }
        let in_offset = b * past_batch_stride + s * row_stride + n * past_head_stride + h;
        present_kv[out_offset] = past_kv[in_offset];`,J=`      let new_batch_stride = uniforms.new_seqlen * num_heads * H;
        let new_row_stride = num_heads * H;
        let new_head_stride = H;
        let in_offset = b * new_batch_stride + (s - past_seqlen) * new_row_stride + n * new_head_stride + h;
        present_kv[out_offset] = new_kv[in_offset];`,ye=r?`if (s < past_seqlen) {
        ${te}
        } else if (s < past_seqlen + uniforms.new_seqlen) {
        ${J}
        }`:`if (s < past_seqlen + uniforms.new_seqlen) {
          ${J}
        }`,ve=Ce=>`

  ${Ce.registerUniforms(Y).declareVariables(...j,_)}
  ${Ce.mainStart([y,i.kvNumHeads,1])}
    ${Ce.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    var indices = ${_.offsetToIndices("global_idx")};
    let h = local_id.x;
    let n = local_id.y;
    let s = workgroup_id.x;
    let b = workgroup_id.y;
    let num_heads = ${i.kvNumHeads}u;
    let H = ${y}u;

    let present_seqlen = uniforms.present_seqlen;
    let present_batch_stride = present_seqlen * num_heads * H;
    var row_stride = H;
    let is_bsnh = ${i.isPastkvBSNH};

    if (is_bsnh) {
      row_stride = num_heads * H;
    }
    var present_head_stride = present_seqlen * H;
    if (is_bsnh) {
      present_head_stride = H;
    }

    let past_seqlen = uniforms.past_seqlen;

    let out_offset = b * present_batch_stride + s * row_stride + n * present_head_stride + h;
    ${ye}
  }`;return{name:"ConcatPastNew",shaderCache:{hint:`${i.kvNumHeads}${y}${!!r}`,inputDependencies:S},getRunData:()=>({outputs:[{dims:a,dataType:s}],dispatchGroup:d,programUniforms:B}),getShaderSource:ve}},Ka=e=>Ht({...e}),Ha=Ht({perm:[0,2,1,3]}),Yl=(e,r,s,i,a)=>{let c=r,l=i.kvNumHeads,h=i.nReps;return r.dims.length===3&&i.kvSequenceLength!==0&&(c=r.reshape([i.batchSize,i.kvSequenceLength,l,i.headSize])),s?c=e.compute(us(c,s,c.dataType,i),{inputs:[c,s],outputs:[i.isPastkvBSNH?a:-1]})[0]:c=e.compute(us(c,void 0,c.dataType,i),{inputs:[c],outputs:[i.isPastkvBSNH?a:-1]})[0],h!==1&&(c=e.compute(ra([c],[1,1,1,h]),{inputs:[c],outputs:[-1]})[0],c=c.reshape([i.batchSize,i.totalSequenceLength,l*h,i.headSize])),e.compute(Un(c,Ha.perm),{inputs:[c],outputs:[-1]})[0]},Jl=(e,r)=>{var _;let s=Vd(e.inputs,r);if(e.inputs[0].dims.length===5)throw new Error("Packed QKV is not implemented");if(((_=e.inputs[1])==null?void 0:_.dims.length)===5)throw new Error("Packed KV is not implemented");let i=ta(e,s.batchSize,s.numHeads,s.sequenceLength,s.headSize,e.inputs[0],void 0,0),a=e.inputs[3]&&e.inputs[3].dims.length!==0?e.inputs[3]:void 0,c=e.inputs[4]&&e.inputs[4].dims.length!==0?e.inputs[4]:void 0,l=Yl(e,e.inputs[1],a,s,1),h=Yl(e,e.inputs[2],c,s,2);Fi(e,i,l,h,void 0,void 0,void 0,void 0,void 0,s,r)}}),qa,vr,Ec,Pc,kp=E(()=>{Rt(),qt(),mo(),or(),qa=(e,r,s,i,a,c,l,h)=>{let _=Jt(c),w=_===1?"f32":`vec${_}f`,v=_===1?"vec2f":`mat2x${_}f`,y=a*l,d=[a,l,c/_],S=[a,l,2],B=["rank","type","type"],j=[];j.push(...Tt(d,S));let Y=te=>{let J=it("x",r.dataType,3,_),ye=it("scale",s.dataType,s.dims),ve=it("bias",i.dataType,i.dims),Ce=Ut("output",1,3,2),Ze=[J,ye,ve,Ce],Ke=64;return`
  var<workgroup> workgroup_shared : array<${v}, ${Ke}>;
  const workgroup_size = ${Ke}u;
  ${te.declareVariables(...Ze)}
  ${te.mainStart(Ke)}
    let batch = workgroup_index / uniforms.x_shape[1];
    let channel = workgroup_index % uniforms.x_shape[1];
    let hight = uniforms.x_shape[2];
    // initialize workgroup memory
    var sum = ${w}(0);
    var squared_sum = ${w}(0);
    for (var h = local_idx; h < hight; h += workgroup_size) {
      let value = ${w}(${J.get("batch","channel","h")});
      sum += value;
      squared_sum += value * value;
    }
    workgroup_shared[local_idx] = ${v}(sum, squared_sum);
    workgroupBarrier();

    for (var currSize = workgroup_size >> 1;  currSize > 0; currSize = currSize >> 1) {
      if (local_idx < currSize) {
        workgroup_shared[local_idx] = workgroup_shared[local_idx] + workgroup_shared[local_idx + currSize];
      }
      workgroupBarrier();
    }
    if (local_idx == 0) {
      let sum_final = ${Hs("workgroup_shared[0][0]",_)} / f32(hight * ${_});
      let squared_sum_final = ${Hs("workgroup_shared[0][1]",_)} / f32(hight * ${_});

      let inv_std_dev = inverseSqrt(squared_sum_final - sum_final * sum_final + f32(${h}));
      let channel_scale = inv_std_dev * f32(scale[channel]);
      let channel_shift = f32(bias[channel]) - sum_final * channel_scale;
      output[workgroup_index] = vec2f(channel_scale, channel_shift);
    }
  }`};return e.compute({name:"InstanceNormComputeChannelScaleShift",shaderCache:{hint:`${_};${h}`,inputDependencies:B},getRunData:()=>({outputs:[{dims:S,dataType:1}],dispatchGroup:{x:y},programUniforms:j}),getShaderSource:Y},{inputs:[r,s,i],outputs:[-1]})[0]},vr=(e,r,s)=>{let i=r[0].dims,a=i,c=2,l=i[0],h=i[1],_=Qe.sizeFromDimension(i,c),w=Jt(_),v=Qe.size(a)/w,y=qa(e,r[0],r[1],r[2],l,_,h,s.epsilon),d=[l,h,_/w],S=[l,h],B=["type","none"],j=Y=>{let te=it("x",r[0].dataType,d.length,w),J=it("scale_shift",1,S.length,2),ye=Ut("output",r[0].dataType,d.length,w),ve=[te,J,ye];return`
  ${Y.registerUniform("output_size","u32").declareVariables(...ve)}
  ${Y.mainStart()}
  ${Y.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
      let outputIndices = ${ye.offsetToIndices("global_idx")};
      let batch = outputIndices[0];
      let channel = outputIndices[1];
      let scale_shift = ${J.getByIndices("vec2<u32>(batch, channel)")};
      let value = ${te.getByOffset("global_idx")} * ${ye.type.value}(scale_shift.x) + ${ye.type.value}(scale_shift.y);
      ${ye.setByOffset("global_idx","value")};
  }`};e.compute({name:"InstanceNormalization",shaderCache:{hint:`${w}`,inputDependencies:B},getRunData:()=>({outputs:[{dims:a,dataType:r[0].dataType}],dispatchGroup:{x:Math.ceil(v/64)},programUniforms:[{type:12,data:v},...Tt(d,S,d)]}),getShaderSource:j},{inputs:[r[0],y]})},Ec=(e,r,s)=>{let i=r[0].dims,a=i,c=i[0],l=i[i.length-1],h=Qe.sizeFromDimension(i,1)/l,_=Jt(l),w=Qe.size(a)/_,v=[{type:12,data:h},{type:12,data:Math.floor(l/_)}],y=["type","type"],d=[0,i.length-1];for(let Y=0;Y<i.length-2;Y++)d.push(Y+1);let S=e.compute(Un(e.inputs[0],d),{inputs:[e.inputs[0]],outputs:[-1]})[0],B=qa(e,S,r[1],r[2],c,h,l,s.epsilon),j=Y=>{let te=_r(r[0].dataType),J=_===1?"vec2f":`mat${_}x2f`,ye=Ze=>{let Ke=Ze===0?"x":"y",ft=_===1?"f32":`vec${_}f`;switch(_){case 1:return`${te}(${ft}(scale.${Ke}))`;case 2:return`vec2<${te}>(${ft}(scale[0].${Ke}, scale[1].${Ke}))`;case 4:return`vec4<${te}>(${ft}(scale[0].${Ke}, scale[1].${Ke}, scale[2].${Ke}, scale[3].${Ke}))`;default:throw new Error(`Not supported compoents ${_}`)}},ve=it("input",r[0].dataType,r[0].dims,_),Ce=Ut("output",r[0].dataType,a,_);return`
  @group(0) @binding(0) var<storage, read> input : array<${ve.type.storage}>;
  @group(0) @binding(1) var<storage, read> scale_input : array<${J}>;
  @group(0) @binding(2) var<storage, read_write> output : array<${Ce.type.storage}>;
  struct Uniforms {H: u32, C : u32};
  @group(0) @binding(3) var<uniform> uniforms: Uniforms;

  ${Y.mainStart()}
    let current_image_number = global_idx / (uniforms.C * uniforms.H);
    let current_channel_number = global_idx % uniforms.C;

    let scale_offset = current_image_number * uniforms.C + current_channel_number;
    let scale = scale_input[scale_offset];
    output[global_idx] = fma(input[global_idx], ${ye(0)}, ${ye(1)});
  }`};e.compute({name:"InstanceNormalizationNHWC",shaderCache:{hint:`${_}`,inputDependencies:y},getRunData:()=>({outputs:[{dims:a,dataType:r[0].dataType}],dispatchGroup:{x:Math.ceil(w/64)},programUniforms:v}),getShaderSource:j},{inputs:[r[0],B]})},Pc=(e,r)=>{r.format==="NHWC"?Ec(e,e.inputs,r):vr(e,e.inputs,r)}}),Zl,Cc,Sc,Gd=E(()=>{Rt(),qt(),or(),Zl=e=>{if(!e||e.length<2)throw new Error("layerNorm requires at least 2 inputs.")},Cc=(e,r,s)=>{let i=r.simplified,a=e[0].dims,c=e[1],l=!i&&e[2],h=a,_=Qe.normalizeAxis(r.axis,a.length),w=Qe.sizeToDimension(a,_),v=Qe.sizeFromDimension(a,_),y=Qe.size(c.dims),d=l?Qe.size(l.dims):0;if(y!==v||l&&d!==v)throw new Error(`Size of X.shape()[axis:] == ${v}.
       Size of scale and bias (if provided) must match this.
       Got scale size of ${y} and bias size of ${d}`);let S=[];for(let Ce=0;Ce<a.length;++Ce)Ce<_?S.push(a[Ce]):S.push(1);let B=Jt(v),j=["type","type"],Y=[{type:12,data:w},{type:1,data:v},{type:12,data:Math.floor(v/B)},{type:1,data:r.epsilon}];l&&j.push("type");let te=s>1,J=s>2,ye=Ce=>{let Ze=_r(e[0].dataType),Ke=[it("x",e[0].dataType,e[0].dims,B),it("scale",c.dataType,c.dims,B)];l&&Ke.push(it("bias",l.dataType,l.dims,B)),Ke.push(Ut("output",e[0].dataType,h,B)),te&&Ke.push(Ut("mean_data_output",1,S)),J&&Ke.push(Ut("inv_std_output",1,S));let ft=[{name:"norm_count",type:"u32"},{name:"norm_size",type:"f32"},{name:"norm_size_vectorized",type:"u32"},{name:"epsilon",type:"f32"}];return`
  ${Ce.registerUniforms(ft).declareVariables(...Ke)}
  ${Ce.mainStart()}
    ${Ce.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.norm_count")}
    let offset = global_idx * uniforms.norm_size_vectorized;
    var mean_vector = ${Jr("f32",B)};
    var mean_square_vector = ${Jr("f32",B)};

    for (var h: u32 = 0u; h < uniforms.norm_size_vectorized; h++) {
      let value = ${ns(Ze,B,"x[h + offset]")};
      mean_vector += value;
      mean_square_vector += value * value;
    }
    let mean = ${Hs("mean_vector",B)} / uniforms.norm_size;
    let inv_std_dev = inverseSqrt(${Hs("mean_square_vector",B)} / uniforms.norm_size ${i?"":"- mean * mean"} + uniforms.epsilon);

    for (var j: u32 = 0; j < uniforms.norm_size_vectorized; j++) {
      let f32input = ${ns(Ze,B,"x[j + offset]")};
      let f32scale = ${ns(Ze,B,"scale[j]")};
      output[j + offset] = ${Ke[0].type.value}((f32input ${i?"":"- mean"}) * inv_std_dev * f32scale
        ${l?`+ ${ns(Ze,B,"bias[j]")}`:""}
      );
    }

    ${te?"mean_data_output[global_idx] = mean":""};
    ${J?"inv_std_output[global_idx] = inv_std_dev":""};
  }`},ve=[{dims:h,dataType:e[0].dataType}];return te&&ve.push({dims:S,dataType:1}),J&&ve.push({dims:S,dataType:1}),{name:"LayerNormalization",shaderCache:{hint:`${B};${s};${i}`,inputDependencies:j},getRunData:()=>({outputs:ve,dispatchGroup:{x:Math.ceil(w/64)},programUniforms:Y}),getShaderSource:ye}},Sc=(e,r)=>{Zl(e.inputs),e.compute(Cc(e.inputs,r,e.outputCount))}}),kc,$c,On,Kn,Ic,Kd=E(()=>{Rt(),qt(),hr(),or(),kc=(e,r)=>{if(e.length<3||e.length>4)throw new Error("MatMulNBits requires 3 or 4 inputs");let s=e[0],i=s.dims.length;if(s.dims[i-1]!==r.k)throw new Error("The last dim of input shape does not match the k value");let a=Math.floor((r.k+r.blockSize-1)/r.blockSize),c=r.blockSize/8*r.bits,l=e[1];if(!Qe.areEqual(l.dims,[r.n,a,c]))throw new Error("The second inputs must be 3D tensor with shape N X nBlocksPerCol X blobSize");let h=e[2].dims;if(Qe.size(h)!==r.n*a)throw new Error("scales input size error.");if(e.length===4){let _=e[3].dims,w=r.bits>4?r.n*a:r.n*Math.floor((a+1)/2);if(Qe.size(_)!==w)throw new Error("zeroPoints input size error.")}},$c=(e,r)=>{let s=e[0].dims,i=s.length,a=s[i-2],c=r.k,l=r.n,h=s.slice(0,i-2),_=Qe.size(h),w=e[1].dims[2]/4,v=e[0].dataType,y=Jt(r.k),d=Jt(w),S=Jt(l),B=h.concat([a,l]),j=a>1&&l/S%2===0?2:1,Y=Qe.size(B)/S/j,te=64,J=[],ye=[_,a,c/y],ve=Qe.convertShape(e[1].dims).slice();ve.splice(-1,1,w/d),J.push(...Tt(ye)),J.push(...Tt(ve)),J.push(...Tt(e[2].dims)),e.length===4&&J.push(...Tt(Qe.convertShape(e[3].dims)));let Ce=[_,a,l/S];J.push(...Tt(Ce));let Ze=Ke=>{let ft=ye.length,It=it("a",e[0].dataType,ft,y),Bt=it("b",12,ve.length,d),cr=it("scales",e[2].dataType,e[2].dims.length),fr=[It,Bt,cr],Xt=e.length===4?it("zero_points",12,e[3].dims.length):void 0;Xt&&fr.push(Xt);let Rr=Ce.length,on=Ut("output",e[0].dataType,Rr,S),yr=_r(e[0].dataType),Vr=(()=>{switch(y){case 1:return`array<${yr}, 8>`;case 2:return`mat4x2<${yr}>`;case 4:return`mat2x4<${yr}>`;default:throw new Error(`${y}-component is not supported.`)}})(),Wt=()=>{let et=`
          // reuse a data
            var input_offset = ${It.indicesToOffset(`${It.type.indices}(batch, row, word_offset)`)};
            var a_data: ${Vr};
            for (var j: u32 = 0; j < ${8/y}; j++) {
              a_data[j] = ${It.getByOffset("input_offset")};
              input_offset++;
            }
          `;for(let xt=0;xt<S*j;xt++)et+=`
            b_value = ${d===1?`b${xt}_data`:`b${xt}_data[i]`};
            b_value_lower = unpack4xU8(b_value & b_mask);
            b_value_upper = unpack4xU8((b_value >> 4) & b_mask);
            b_quantized_values = ${Vr}(${Array.from({length:4},(rr,jr)=>`${yr}(b_value_lower[${jr}]), ${yr}(b_value_upper[${jr}])`).join(", ")});
            b_dequantized_values = ${y===1?`${Vr}(${Array.from({length:8},(rr,jr)=>`(b_quantized_values[${jr}] - ${Xt?`zero_point${xt}`:"zero_point"}) * scale${xt}`).join(", ")});`:`(b_quantized_values - ${Vr}(${Array(8).fill(`${Xt?`zero_point${xt}`:"zero_point"}`).join(",")})) * scale${xt};`};
            workgroup_shared[local_id.x * ${j} + ${Math.floor(xt/S)}]${S>1?`[${xt%S}]`:""} += ${Array.from({length:8/y},(rr,jr)=>`${y===1?`a_data[${jr}] * b_dequantized_values[${jr}]`:`dot(a_data[${jr}], b_dequantized_values[${jr}])`}`).join(" + ")};
          `;return et},tr=()=>{let et=`
            var col_index = col * ${S};
            ${Xt?`
            let zero_point_bytes_per_col = (nBlocksPerCol + 1) / 2;
            var zero_point_byte_count: u32;
            var zero_point_word_index: u32;
            var zero_point_byte_offset: u32;
            let zero_point_nibble_offset: u32 = block & 0x1u;
            var zero_point_bits_offset: u32;
            var zero_point_word: u32;`:`
            // The default zero point is 8 for unsigned 4-bit quantization.
            let zero_point = ${yr}(8);`}
            `;for(let xt=0;xt<S*j;xt++)et+=`
            let scale${xt} = ${cr.getByOffset("col_index * nBlocksPerCol + block")};
            ${Xt?`
            zero_point_byte_count = col_index * zero_point_bytes_per_col + (block >> 0x1u);
            zero_point_word_index = zero_point_byte_count >> 0x2u;
            zero_point_byte_offset = zero_point_byte_count & 0x3u;
            zero_point_bits_offset = (zero_point_byte_offset << 3) + (zero_point_nibble_offset << 2);
            zero_point_word = ${Xt.getByOffset("zero_point_word_index")} >> zero_point_bits_offset;
            let zero_point${xt} = ${yr}((zero_point_word) & 0xFu);`:""}
            col_index += 1;`;return et},Ir=()=>{let et=`col_index = col * ${S};`;for(let xt=0;xt<S*j;xt++)et+=`
            let b${xt}_data = ${Bt.getByIndices(`${Bt.type.indices}(col_index, block, word)`)};
            col_index += 1;`;return et+=`
            var b_value: u32;
            let b_mask: u32 = 0x0F0F0F0Fu;
            var b_value_lower: vec4<u32>;
            var b_value_upper: vec4<u32>;
            var b_quantized_values: ${Vr};
            var b_dequantized_values: ${Vr};`,et};return`
        var<workgroup> workgroup_shared: array<${on.type.value}, ${j*te}>;
        ${Ke.declareVariables(...fr,on)}
        ${Ke.mainStart([te,1,1])}
          let output_indices = ${on.offsetToIndices(`(global_idx / ${te}) * ${j}`)};
          let col = output_indices[2];
          let row = output_indices[1];
          let batch = output_indices[0];
          let nBlocksPerCol = uniforms.b_shape[1];

          for (var block = local_id.x; block < nBlocksPerCol; block += ${te}) {
            //process one block
            var word_offset: u32 = block * ${r.blockSize/y};
            ${tr()}
            for (var word: u32 = 0; word < ${w}; word += ${d}) {
              ${Ir()}
              for (var i: u32 = 0; i < ${d}; i++) {
                ${Wt()}
                word_offset += ${8/y};
              }
            }
          }
          workgroupBarrier();

          if (local_id.x < ${j}) {
            var output_value: ${on.type.value} = ${on.type.value}(0);
            var workgroup_shared_offset: u32 = local_id.x;
            for (var b: u32 = 0u; b < ${te}u; b++) {
              output_value += workgroup_shared[workgroup_shared_offset];
              workgroup_shared_offset += ${j};
            }
            ${on.setByIndices(`${on.type.indices}(batch, row, col + local_id.x)`,"output_value")};
          }
        }`};return{name:"MatMulNBits",shaderCache:{hint:`${r.blockSize};${r.bits};${y};${d};${S};${j};${te}`,inputDependencies:Array(e.length).fill("rank")},getRunData:()=>({outputs:[{dims:B,dataType:v}],dispatchGroup:{x:Y},programUniforms:J}),getShaderSource:Ze}},On=(e,r)=>{let s=e[0].dims,i=s.length,a=s[i-2],c=r.k,l=r.n,h=s.slice(0,i-2),_=Qe.size(h),w=e[1].dims[2]/4,v=e[0].dataType,y=Jt(r.k),d=Jt(w),S=h.concat([a,l]),B=128,j=l%8===0?8:l%4===0?4:1,Y=B/j,te=Y*d*8,J=te/y,ye=te/r.blockSize,ve=Qe.size(S)/j,Ce=[],Ze=[_,a,c/y],Ke=Qe.convertShape(e[1].dims).slice();Ke.splice(-1,1,w/d),Ce.push(...Tt(Ze)),Ce.push(...Tt(Ke)),Ce.push(...Tt(e[2].dims)),e.length===4&&Ce.push(...Tt(Qe.convertShape(e[3].dims)));let ft=[_,a,l];Ce.push(...Tt(ft));let It=Bt=>{let cr=Ze.length,fr=it("a",e[0].dataType,cr,y),Xt=it("b",12,Ke.length,d),Rr=it("scales",e[2].dataType,e[2].dims.length),on=[fr,Xt,Rr],yr=e.length===4?it("zero_points",12,e[3].dims.length):void 0;yr&&on.push(yr);let Vr=ft.length,Wt=Ut("output",e[0].dataType,Vr),tr=_r(e[0].dataType),Ir=()=>{switch(y){case 1:return`
          let a_data0 = vec4<${tr}>(sub_a[word_offset], sub_a[word_offset + 1], sub_a[word_offset + 2], sub_a[word_offset + 3]);
          let a_data1 = vec4<${tr}>(sub_a[word_offset + 4], sub_a[word_offset + 5], sub_a[word_offset + 6], sub_a[word_offset + 7]);`;case 2:return`
          let a_data0 = vec4<${tr}>(sub_a[word_offset], sub_a[word_offset + 1]);
          let a_data1 = vec4<${tr}>(sub_a[word_offset + 2], sub_a[word_offset + 3]);`;case 4:return`
          let a_data0 = sub_a[word_offset];
          let a_data1 = sub_a[word_offset + 1];`;default:throw new Error(`${y}-component is not supported.`)}};return`
        var<workgroup> sub_a: array<${fr.type.value}, ${J}>;
        var<workgroup> inter_results: array<array<${Wt.type.value}, ${Y}>, ${j}>;
        ${Bt.declareVariables(...on,Wt)}
        ${Bt.mainStart([Y,j,1])}
          let output_indices = ${Wt.offsetToIndices(`workgroup_index * ${j}`)};
          let col = output_indices[2];
          let row = output_indices[1];
          let batch = output_indices[0];
          let n_blocks_per_col = uniforms.b_shape[1];
          let num_tiles =  (n_blocks_per_col - 1) / ${ye} + 1;

          // Loop over shared dimension.
          for (var tile: u32 = 0; tile < num_tiles; tile += 1) {
            let a_col_start = tile * ${J};
            // load one tile A data into shared memory.
            for (var a_offset = local_idx; a_offset < ${J}; a_offset += ${B})
            {
              let a_col = a_col_start + a_offset;
              if (a_col < uniforms.a_shape[2])
              {
                sub_a[a_offset] = ${fr.getByIndices(`${fr.type.indices}(batch, row, a_col)`)};
              } else {
                sub_a[a_offset] = ${fr.type.value}(0);
              }
            }
            workgroupBarrier();

            // each thread process one block
            let b_row = col + local_id.y;
            let block = tile * ${ye} + local_id.x;
            ${yr?`
            let zero_point_bytes_per_col = (n_blocks_per_col + 1) / 2;
            let zero_point_byte_count = b_row * zero_point_bytes_per_col + (block >> 0x1u);
            let zero_point_word_index = zero_point_byte_count >> 0x2u;
            let zero_point_byte_offset = zero_point_byte_count & 0x3u;
            let zero_point_nibble_offset: u32 = block & 0x1u;
            let zero_point_bits_offset = (zero_point_byte_offset << 3) + (zero_point_nibble_offset << 2);
            let zero_point_word = ${yr.getByOffset("zero_point_word_index")} >> zero_point_bits_offset;
            let zero_point = ${tr}((zero_point_word) & 0xFu);`:`
            // The default zero point is 8 for unsigned 4-bit quantization.
            let zero_point = ${tr}(8);`}
            let scale = ${Rr.getByOffset("b_row * n_blocks_per_col + block")};
            let b_data = ${Xt.getByIndices(`${Xt.type.indices}(b_row, block, 0)`)};
            var word_offset = local_id.x * ${r.blockSize/y};
            for (var i: u32 = 0; i < ${d}; i++) {
              ${Ir()}
              let b_value = ${d===1?"b_data":"b_data[i]"};
              let b_value_lower = unpack4xU8(b_value & 0x0F0F0F0Fu);
              let b_value_upper = unpack4xU8((b_value >> 4) & 0x0F0F0F0Fu);
              let b_quantized_values = mat2x4<${tr}>(${Array.from({length:4},(et,xt)=>`${tr}(b_value_lower[${xt}]), ${tr}(b_value_upper[${xt}])`).join(", ")});
              let b_dequantized_values = (b_quantized_values - mat2x4<${tr}>(${Array(8).fill("zero_point").join(",")})) * scale;
              inter_results[local_id.y][local_id.x] += ${Array.from({length:2},(et,xt)=>`${`dot(a_data${xt}, b_dequantized_values[${xt}])`}`).join(" + ")};
              word_offset += ${8/y};
            }
            workgroupBarrier();
          }

          if (local_idx < ${j}) {
            var output_value: ${Wt.type.value} = ${Wt.type.value}(0);
            for (var b = 0u; b < ${Y}; b++) {
              output_value += inter_results[local_idx][b];
            }
            if (col + local_idx < uniforms.output_shape[2])
            {
              ${Wt.setByIndices(`${Wt.type.indices}(batch, row, col + local_idx)`,"output_value")}
            }
          }
        }`};return{name:"BlockwiseMatMulNBits32",shaderCache:{hint:`${r.blockSize};${y};${d};${Y};${j}`,inputDependencies:Array(e.length).fill("rank")},getRunData:()=>({outputs:[{dims:S,dataType:v}],dispatchGroup:{x:ve},programUniforms:Ce}),getShaderSource:It}},Kn=(e,r)=>{kc(e.inputs,r),r.blockSize===32&&e.adapterInfo.isVendor("intel")&&e.adapterInfo.isArchitecture("gen-12lp")?e.compute(On(e.inputs,r)):e.compute($c(e.inputs,r))},Ic=e=>Ht(e)}),eu,Hd,qd,tu,Ac,ru,Fc,Oc,nu,Lc=E(()=>{Rt(),qt(),or(),eu=e=>{if(!e||e.length<1)throw new Error("Too few inputs");if(e[0].dataType!==1&&e[0].dataType!==10)throw new Error("Input type must be float or float16.");if(e.length>=2){let r=e[0].dims.length*2===e[1].dims[0];if(e.length===4&&(r=e[3].dims[0]*2===e[1].dims[0]),!r)throw new Error("The pads should be a 1D tensor of shape [2 * input_rank] or [2 * num_axes].")}},Hd=(e,r,s)=>{let i="";for(let a=r-1;a>=0;--a)i+=`
            k = i32(${e.indicesGet("indices",a)}) - ${Nt("uniforms.pads",a,s)};
            if (k < 0) {
              break;
            }
            if (k >= i32(${Nt("uniforms.x_shape",a,r)})) {
              break;
            }
            offset += k * i32(${Nt("uniforms.x_strides",a,r)});
        `;return`
          value = ${e.type.value}(uniforms.constant_value);
          for (var i = 0; i < 1; i++) {
            var offset = 0;
            var k = 0;
            ${i}
            value = x[offset];
          }
      `},qd=(e,r,s)=>{let i="";for(let a=r-1;a>=0;--a)i+=`
                k = i32(${e.indicesGet("indices",a)}) - ${Nt("uniforms.pads",a,s)};
                if (k < 0) {
                  k = -k;
                }
                {
                  let _2n_1 = 2 * (i32(${Nt("uniforms.x_shape",a,r)}) - 1);
                  k = k % _2n_1;
                  if(k >= i32(${Nt("uniforms.x_shape",a,r)})) {
                    k = _2n_1 - k;
                  }
                }
                offset += k * i32(${Nt("uniforms.x_strides",a,r)});
            `;return`
              var offset = 0;
              var k = 0;
              ${i}
              value = x[offset];
          `},tu=(e,r,s)=>{let i="";for(let a=r-1;a>=0;--a)i+=`
                k = i32(${e.indicesGet("indices",a)}) - ${Nt("uniforms.pads",a,s)};
                if (k < 0) {
                  k = 0;
                }
                if (k >= i32(${Nt("uniforms.x_shape",a,r)})) {
                  k = i32(${Nt("uniforms.x_shape",a,r)}) - 1;
                }
                offset += k * i32(${Nt("uniforms.x_strides",a,r)});
            `;return`
              var offset = 0;
              var k = 0;
              ${i}
              value = x[offset];
          `},Ac=(e,r,s)=>{let i="";for(let a=r-1;a>=0;--a)i+=`
                k = i32(${e.indicesGet("indices",a)}) - ${Nt("uniforms.pads",a,s)};
                if (k < 0)  {
                  k += i32(${Nt("uniforms.x_shape",a,r)}]);
                }
                if (k >= i32(${Nt("uniforms.x_shape",a,r)})) {
                  k -= i32(${Nt("uniforms.x_shape",a,r)});
                }
                offset += k * i32(${Nt("uniforms.x_strides",a,r)});
            `;return`
              var offset = 0;
              var k = 0;
              ${i}
              value = x[offset];
          `},ru=(e,r,s)=>{switch(s.mode){case 0:return Hd(e,r,s.pads.length);case 1:return qd(e,r,s.pads.length);case 2:return tu(e,r,s.pads.length);case 3:return Ac(e,r,s.pads.length);default:throw new Error("Invalid mode")}},Fc=(e,r)=>{let s=Qe.padShape(e[0].dims.slice(),r.pads),i=e[0].dims,a=Qe.size(s),c=[{type:12,data:a},{type:6,data:r.pads}],l=e.length>=3&&e[2].data;r.mode===0&&c.push({type:l?e[2].dataType:1,data:r.value}),c.push(...Tt(e[0].dims,s));let h=["rank"],_=w=>{let v=Ut("output",e[0].dataType,s.length),y=it("x",e[0].dataType,i.length),d=y.type.value,S=ru(v,i.length,r),B=[{name:"output_size",type:"u32"},{name:"pads",type:"i32",length:r.pads.length}];return r.mode===0&&B.push({name:"constant_value",type:l?d:"f32"}),`
            ${w.registerUniforms(B).declareVariables(y,v)}
            ${w.mainStart()}
            ${w.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

            let indices = ${v.offsetToIndices("global_idx")};

            var value = ${d}(0);
            ${S}
            output[global_idx] = value;
        }`};return{name:"Pad",shaderCache:{hint:`${r.mode}${l}`,inputDependencies:h},getRunData:()=>({outputs:[{dims:s,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(Qe.size(s)/64)},programUniforms:c}),getShaderSource:_}},Oc=(e,r)=>{if(e.length>1){let s=e[1].getBigInt64Array(),i=e.length>=3&&e[2].data?e[2].dataType===10?e[2].getUint16Array()[0]:e[2].getFloat32Array()[0]:0,a=e[0].dims.length,c=new Int32Array(2*a).fill(0);if(e.length>=4){let h=e[3].getBigInt64Array();for(let _=0;_<h.length;_++)c[Number(h[_])]=Number(s[_]),c[Number(h[_])+a]=Number(s[_+h.length])}else s.forEach((h,_)=>c[Number(_)]=Number(h));let l=[];return c.forEach(h=>l.push(h)),{mode:r.mode,value:i,pads:l}}else return r},nu=(e,r)=>{eu(e.inputs);let s=Oc(e.inputs,r);e.compute(Fc(e.inputs,s),{inputs:[0]})}}),na,Qa,sa,Dc,su,zc,Bc,oa,Os,Qd,Rc,Xa,Xd,ou,_i,An,Yd,Jd,Ya,Ln=E(()=>{St(),Rt(),qt(),or(),na=e=>{if(L.webgpu.validateInputContent&&(!e||e.length!==1))throw new Error("Pool ops requires 1 input.")},Qa=(e,r,s)=>{let i=r.format==="NHWC",a=e.dims.slice();i&&a.splice(1,0,a.pop());let c=Object.hasOwnProperty.call(r,"dilations"),l=r.kernelShape.slice(),h=r.strides.slice(),_=c?r.dilations.slice():[],w=r.pads.slice();mr.adjustPoolAttributes(s,a,l,h,_,w);let v=mr.computePoolOutputShape(s,a,h,_,l,w,r.autoPad),y=Object.assign({},r);c?Object.assign(y,{kernelShape:l,strides:h,pads:w,dilations:_,cacheKey:r.cacheKey}):Object.assign(y,{kernelShape:l,strides:h,pads:w,cacheKey:r.cacheKey});let d=v.slice();return d.push(d.splice(1,1)[0]),[y,i?d:v]},sa=(e,r)=>{let s=r.format==="NHWC",i=Qe.size(e),a=Qe.size(r.kernelShape),c=[{type:12,data:i},{type:12,data:a}],l=[{name:"outputSize",type:"u32"},{name:"kernelSize",type:"u32"}];if(r.kernelShape.length<=2){let h=r.kernelShape[r.kernelShape.length-1],_=r.strides[r.strides.length-1],w=r.pads[r.pads.length/2-1],v=r.pads[r.pads.length-1],y=!!(w+v);c.push({type:12,data:h},{type:12,data:_},{type:12,data:w},{type:12,data:v}),l.push({name:"kw",type:"u32"},{name:"sw",type:"u32"},{name:"pwStart",type:"u32"},{name:"pwEnd",type:"u32"});let d=!1;if(r.kernelShape.length===2){let S=r.kernelShape[r.kernelShape.length-2],B=r.strides[r.strides.length-2],j=r.pads[r.pads.length/2-2],Y=r.pads[r.pads.length-2];d=!!(j+Y),c.push({type:12,data:S},{type:12,data:B},{type:12,data:j},{type:12,data:Y}),l.push({name:"kh",type:"u32"},{name:"sh",type:"u32"},{name:"phStart",type:"u32"},{name:"phEnd",type:"u32"})}return[c,l,!0,y,d]}else{if(s)throw new Error("Pooling with kernelShape.length > 2 is not supported for NHWC format.");let h=Qe.computeStrides(r.kernelShape);c.push({type:12,data:h},{type:12,data:r.pads},{type:12,data:r.strides}),l.push({name:"kernelStrides",type:"u32",length:h.length},{name:"pads",type:"u32",length:r.pads.length},{name:"strides",type:"u32",length:r.strides.length});let _=r.pads.reduce((w,v)=>w+v);return[c,l,!!_,!1,!1]}},Dc=(e,r,s,i,a,c,l,h,_,w,v,y)=>{let d=a.format==="NHWC",S=r.type.value,B=Ut("output",r.type.tensor,i);if(a.kernelShape.length<=2){let j="",Y="",te="",J=s-(d?2:1);if(v?j=`
                for (var i: u32 = 0u; i < uniforms.kw; i++) {
                  xIndices[${J}] = indices[${J}] * uniforms.sw - uniforms.pwStart + i;
                  if (xIndices[${J}] < 0 || xIndices[${J}]
                      >= uniforms.x_shape[${J}]) {
                    pad++;
                    continue;
                  }
                  let x_val = x[${r.indicesToOffset("xIndices")}];
                  ${c}
                }`:j=`
                for (var i: u32 = 0u; i < uniforms.kw; i++) {
                  xIndices[${J}] = indices[${J}] * uniforms.sw - uniforms.pwStart + i;
                  let x_val = x[${r.indicesToOffset("xIndices")}];
                  ${c}
                }`,a.kernelShape.length===2){let ye=s-(d?3:2);y?Y=`
                for (var j: u32 = 0u; j < uniforms.kh; j++) {
                  xIndices[${ye}] = indices[${ye}] * uniforms.sh - uniforms.phStart + j;
                  if (xIndices[${ye}] < 0 || xIndices[${ye}] >= uniforms.x_shape[${ye}]) {
                    pad += i32(uniforms.kw);
                    continue;
                  }
              `:Y=`
                for (var j: u32 = 0u; j < uniforms.kh; j++) {
                  xIndices[${ye}] = indices[${ye}] * uniforms.sh - uniforms.phStart + j;
                `,te=`
              }
            `}return`
            ${e.registerUniforms(_).declareVariables(r,B)}

            ${e.mainStart()}
              ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}

              let indices = ${B.offsetToIndices("global_idx")};
              var xIndices = ${B.offsetToIndices("global_idx")};

              var value = ${S}(${h});
              var pad = 0;
              ${Y}
              ${j}
              ${te}
              ${l}

              output[global_idx] = value;
            }`}else{if(d)throw new Error("Pooling with kernelShape.length > 2 is not supported for NHWC format.");let j=a.kernelShape.length,Y=a.pads.length,te="";return w?te=`
                if (xIndices[j] >= uniforms.x_shape[j]) {
                  pad++;
                  isPad = true;
                  break;
                }
              }
              if (!isPad) {
                let x_val = x[${r.indicesToOffset("xIndices")}];
                ${c}
              }`:te=`
              }
              let x_val = x[${r.indicesToOffset("xIndices")}];
              ${c}
            `,`
            ${e.registerUniforms(_).declareVariables(r,B)}

            ${e.mainStart()}
              ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
              let indices = ${B.offsetToIndices("global_idx")};
              var xIndices = ${B.offsetToIndices("global_idx")};

              var offsets: array<u32, ${j}>;

              var value = ${S}(${h});
              var pad = 0;
              var isPad = false;

              for (var i: u32 = 0u; i < uniforms.kernelSize; i++) {
                var offset = i;
                for (var j = 0u; j < ${j-1}u; j++) {
                  offsets[j] = offset / ${Nt("uniforms.kernelStrides","j",j)};
                  offset -= offsets[j] * ${Nt("uniforms.kernelStrides","j",j)};
                }
                offsets[${j-1}] = offset;

                isPad = false;
                for (var j = ${s-j}u; j < ${s}u; j++) {
                  xIndices[j] = indices[j] * ${Nt("uniforms.strides",`j - ${s-j}u`,j)}
                    + offsets[j - ${s-j}u] - ${Nt("uniforms.pads","j - 2u",Y)};
                  ${te}
              }
              ${l}

              output[global_idx] = value;
            }`}},su=e=>`${e.format};${e.ceilMode};${e.autoPad};${e.kernelShape.length}`,zc=e=>`${su(e)};${e.countIncludePad}`,Bc=e=>`${su(e)};${e.storageOrder};${e.dilations}`,oa=e=>({format:e.format,autoPad:["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][e.auto_pad],ceilMode:e.ceil_mode,kernelShape:e.kernel_shape,strides:e.strides,pads:e.pads}),Os=(e,r,s,i)=>{let[a,c]=Qa(r,i,s),l=it("x",r.dataType,r.dims.length),h=l.type.value,_="value += x_val;",w="";a.countIncludePad?w+=`value /= ${h}(uniforms.kernelSize);`:w+=`value /= ${h}(i32(uniforms.kernelSize) - pad);`;let[v,y,d,S,B]=sa(c,a);v.push(...Tt(r.dims,c));let j=["rank"];return{name:e,shaderCache:{hint:`${i.cacheKey};${d};${S};${B}`,inputDependencies:j},getRunData:()=>({outputs:[{dims:c,dataType:r.dataType}],dispatchGroup:{x:Math.ceil(Qe.size(c)/64)},programUniforms:v}),getShaderSource:Y=>Dc(Y,l,r.dims.length,c.length,a,_,w,0,y,d,S,B)}},Qd=e=>{let r=e.count_include_pad!==0,s=oa(e);if(s.ceilMode!==0)throw new Error("using ceil() in shape computation is not yet supported for AveragePool");let i={countIncludePad:r,...s,cacheKey:""};return{...i,cacheKey:zc(i)}},Rc=(e,r)=>{na(e.inputs),e.compute(Os("AveragePool",e.inputs[0],!1,r))},Xa={autoPad:"",ceilMode:0,countIncludePad:!1,kernelShape:[],strides:[],pads:[],storageOrder:0,dilations:[]},Xd=e=>{let r=e.format;return{format:r,...Xa,cacheKey:r}},ou=(e,r)=>{na(e.inputs),e.compute(Os("GlobalAveragePool",e.inputs[0],!0,r))},_i=(e,r,s,i)=>{let[a,c]=Qa(r,i,s),l=`
      value = max(x_val, value);
    `,h="",_=it("x",r.dataType,r.dims.length),w=["rank"],[v,y,d,S,B]=sa(c,a);return v.push(...Tt(r.dims,c)),{name:e,shaderCache:{hint:`${i.cacheKey};${d};${S};${B}`,inputDependencies:w},getRunData:()=>({outputs:[{dims:c,dataType:r.dataType}],dispatchGroup:{x:Math.ceil(Qe.size(c)/64)},programUniforms:v}),getShaderSource:j=>Dc(j,_,r.dims.length,c.length,a,l,h,r.dataType===10?-65504:-1e5,y,d,S,B)}},An=(e,r)=>{na(e.inputs),e.compute(_i("MaxPool",e.inputs[0],!1,r))},Yd=e=>{let r=e.storage_order,s=e.dilations,i=oa(e);if(r!==0)throw new Error("column major storage order is not yet supported for MaxPool");if(i.ceilMode!==0)throw new Error("using ceil() in shape computation is not yet supported for MaxPool");let a={storageOrder:r,dilations:s,...i,cacheKey:""};return{...a,cacheKey:Bc(a)}},Jd=e=>{let r=e.format;return{format:r,...Xa,cacheKey:r}},Ya=(e,r)=>{na(e.inputs),e.compute(_i("GlobalMaxPool",e.inputs[0],!0,r))}}),Zd,Dt,gi,iu,ep=E(()=>{Rt(),qt(),hr(),or(),Zd=(e,r)=>{if(e.length<2||e.length>3)throw new Error("DequantizeLinear requires 2 or 3 inputs.");if(e.length===3&&e[1].dims===e[2].dims)throw new Error("x-scale and x-zero-point must have the same shape.");if(e.length===3&&e[0].dataType!==e[2].dataType)throw new Error("x and x-zero-point must have the same data type.");if(e[0].dataType===6&&e.length>2)throw new Error("In the case of dequantizing int32 there is no zero point.");if(e[1].dims.length!==0&&e[1].dims.length!==1&&e[1].dims.length!==e[0].dims.length)throw new Error("scale input must be a scalar, a 1D tensor, or have the same rank as the input tensor.");if(e.length>2){if(e[0].dataType!==e[2].dataType)throw new Error("x and x-zero-point must have the same data type.");if(e[1].dims.length!==e[2].dims.length)throw new Error("scale and zero-point inputs must have the same rank.");if(!e[1].dims.map((s,i)=>s===e[2].dims[i]).reduce((s,i)=>s&&i,!0))throw new Error("scale and zero-point inputs must have the same shape.")}if(r.blockSize>0){if(e[1].dims.length===0||e[1].dims.length===1&&e[1].dims[0]===1)throw new Error("blockSize must be set only for block quantization.");if(!e[1].dims.map((a,c)=>c===r.axis||a===e[0].dims[c]).reduce((a,c)=>a&&c,!0))throw new Error("For block qunatization, scale input shape to match the input shape except for the axis");if(e[1].dims.length!==e[0].dims.length)throw new Error("For block qunatization the scale input rank must be the same as the x rank.");let s=e[0].dims[r.axis],i=e[1].dims[r.axis];if(r.blockSize<Math.ceil(s/i)||r.blockSize>Math.ceil(s/(i-1)-1))throw new Error("blockSize must be with in the range [ceil(dI / Si), ceil(dI / (Si - 1) - 1)].")}},Dt=(e,r)=>{let s=Qe.normalizeAxis(r.axis,e[0].dims.length),i=e[0].dataType,a=i===3,c=e[0].dims,l=e[1].dataType,h=Qe.size(c),_=i===3||i===2,w=_?[Math.ceil(Qe.size(e[0].dims)/4)]:e[0].dims,v=e[1].dims,y=e.length>2?e[2]:void 0,d=y?_?[Math.ceil(Qe.size(y.dims)/4)]:y.dims:void 0,S=v.length===0||v.length===1&&v[0]===1,B=S===!1&&v.length===1,j=Jt(h),Y=S&&(!_||j===4),te=Y?j:1,J=Y&&!_?j:1,ye=it("input",_?12:i,w.length,J),ve=it("scale",l,v.length),Ce=y?it("zero_point",_?12:i,d.length):void 0,Ze=Ut("output",l,c.length,te),Ke=[ye,ve];Ce&&Ke.push(Ce);let ft=[w,v];y&&ft.push(d);let It=[{type:12,data:h/te},{type:12,data:s},{type:12,data:r.blockSize},...Tt(...ft,c)],Bt=cr=>{let fr=[{name:"output_size",type:"u32"},{name:"axis",type:"u32"},{name:"block_size",type:"u32"}];return`
      ${cr.registerUniforms(fr).declareVariables(...Ke,Ze)}
      ${cr.mainStart()}
          ${cr.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
          let output_indices = ${Ze.offsetToIndices("global_idx")};

          // Set input x
          ${_?`
            let input = ${ye.getByOffset("global_idx / 4")};
            let x_vec = ${a?"unpack4xI8(input)":"unpack4xU8(input)"};
            let x_value = ${te===1?"x_vec[global_idx % 4]":"x_vec"};`:`let x_value = ${ye.getByOffset("global_idx")};`};

          // Set scale input
          ${S?`let scale_value= ${ve.getByOffset("0")}`:B?`
            let scale_index = ${Ze.indicesGet("output_indices","uniforms.axis")};
            let scale_value= ${ve.getByOffset("scale_index")};`:`
            var scale_indices: ${ve.type.indices} = output_indices;
            let index = ${ve.indicesGet("scale_indices","uniforms.axis")} / uniforms.block_size;
            ${ve.indicesSet("scale_indices","uniforms.axis","index")};
            let scale_value= ${ve.getByIndices("scale_indices")};`};

          // Set zero-point input
          ${Ce?S?_?`
                let zero_point_input = ${Ce.getByOffset("0")};
                let zero_point_vec =  ${a?"unpack4xI8(zero_point_input)":"unpack4xU8(zero_point_input)"};
                let zero_point_value= zero_point_vec[0]`:`let zero_point_value = ${Ce.getByOffset("0")}`:B?_?`
                let zero_point_index = ${Ze.indicesGet("output_indices","uniforms.axis")};
                let zero_point_input = ${Ce.getByOffset("zero_point_index / 4")};
                let zero_point_vec =  ${a?"unpack4xI8(zero_point_input)":"unpack4xU8(zero_point_input)"};
                let zero_point_value = zero_point_vec[zero_point_index % 4]`:`
                let zero_point_index = ${Ze.indicesGet("output_indices","uniforms.axis")};
                let zero_point_value = ${Ce.getByOffset("zero_point_index")};`:_?`
                let zero_point_offset = ${ve.indicesToOffset("scale_indices")};
                let zero_point_input = ${Ce.getByOffset("zero_point_offset / 4")};
                let zero_point_vec = ${a?"unpack4xI8(zero_point_input)":"unpack4xU8(zero_point_input)"};
                let zero_point_value = zero_point_vec[zero_point_offset % 4];`:`let zero_point_value = ${Ce.getByIndices("scale_indices")};`:`let zero_point_value = ${_?a?"i32":"u32":ye.type.value}(0);`};
      // Compute and write output
      ${Ze.setByOffset("global_idx",`${Ze.type.value}(x_value - zero_point_value) * scale_value`)};
      }`};return{name:"DequantizeLinear",shaderCache:{hint:r.cacheKey,inputDependencies:Ce?["rank","rank","rank"]:["rank","rank"]},getShaderSource:Bt,getRunData:()=>({outputs:[{dims:c,dataType:l}],dispatchGroup:{x:Math.ceil(h/te/64),y:1,z:1},programUniforms:It})}},gi=(e,r)=>{Zd(e.inputs,r),e.compute(Dt(e.inputs,r))},iu=e=>Ht({axis:e.axis,blockSize:e.blockSize})}),tp,ia,Ja,jc=E(()=>{St(),Rt(),or(),tp=(e,r,s)=>{let i=e===r,a=e<r&&s<0,c=e>r&&s>0;if(i||a||c)throw new Error("Range these inputs' contents are invalid.")},ia=(e,r,s,i)=>{let a=Math.abs(Math.ceil((r-e)/s)),c=[a],l=a,h=[{type:12,data:l},{type:i,data:e},{type:i,data:s},...Tt(c)],_=w=>{let v=Ut("output",i,c.length),y=v.type.value,d=[{name:"outputSize",type:"u32"},{name:"start",type:y},{name:"delta",type:y}];return`
        ${w.registerUniforms(d).declareVariables(v)}
        ${w.mainStart()}
        ${w.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
        output[global_idx] = uniforms.start + ${y}(global_idx) * uniforms.delta;
      }`};return{name:"Range",shaderCache:{hint:`${i}`},getShaderSource:_,getRunData:()=>({outputs:[{dims:c,dataType:i}],dispatchGroup:{x:Math.ceil(l/64)},programUniforms:h})}},Ja=e=>{let r=0,s=0,i=0;e.inputs[0].dataType===6?(r=e.inputs[0].getInt32Array()[0],s=e.inputs[1].getInt32Array()[0],i=e.inputs[2].getInt32Array()[0]):e.inputs[0].dataType===1&&(r=e.inputs[0].getFloat32Array()[0],s=e.inputs[1].getFloat32Array()[0],i=e.inputs[2].getFloat32Array()[0]),L.webgpu.validateInputContent&&tp(r,s,i),e.compute(ia(r,s,i,e.inputs[0].dataType),{inputs:[]})}}),Nc,Uc,Vc,au,lu,Tn,vs,Eo,Wc,Gc,Ms,uu,Ls,_p,lr,Kc,wn,bn,Dn,Po=E(()=>{Rt(),qt(),hr(),or(),Nc=(e,r)=>{if(e.every(s=>s>0||(()=>{throw new Error("Resize requires scales input values to be positive")})),e.length>0){if(r.mode==="linear"){if(!(e.length===2||e.length===3||e.length===4&&e[0]===1&&e[1]===1||e.length===4&&e[0]===1&&e[3]===1||e.length===5&&e[0]===1&&e[1]===1))throw new Error(`For linear mode, Resize requires scales to be 2D, 3D, 4D with either two outermost or one innermost and
            one outermost scale values equal to 1, or 5D with two outermost scale values equal to 1`)}else if(r.mode==="cubic"&&!(e.length===2||e.length===4&&e[0]===1&&e[1]===1||e.length===4&&e[0]===1&&e[3]===1))throw new Error("Resize requires scales input size to be 2 or 4 for cubic mode")}},Uc=(e,r,s)=>{r.every(a=>a>=0&&a<s||(()=>{throw new Error("Resize requires axes input values to be positive and less than rank")}));let i=new Array(s).fill(1);return r.forEach((a,c)=>i[a]=e[c]),i},Vc=(e,r,s,i,a,c)=>{let[l,h,_]=s>10?[1,2,3]:[-1,e.length>1?1:-1,-1],w=e[0].dims.length;if(l>0&&e.length>l&&e[l].dims.length>0)e[l].getFloat32Array().forEach(v=>c.push(v));else if(r.coordinateTransformMode==="tf_crop_and_resize")throw new Error("Resize requires RoI input to be specified when coordinateTransformMode is tfCropAndResize");if(h>0&&e.length>h&&e[h].dims.length===1&&e[h].dims[0]>0){if(e[h].getFloat32Array().forEach(v=>i.push(v)),i.length!==0&&i.length!==w&&s>=18&&i.length!==r.axes.length)throw new Error("Resize requires scales input size to be same as input rank or axes size for opset 18 and up");Nc(i,r),r.axes.length>0&&Uc(i,r.axes,w).forEach((v,y)=>i[y]=v)}if(_>0&&e.length>_&&e[_].dims.length===1&&e[_].dims[0]>0&&(e[_].getBigInt64Array().forEach(v=>a.push(Number(v))),a.length!==0&&a.length!==w&&s>=18&&a.length!==r.axes.length))throw new Error("Resize requires sizes input size to be same as input rank or axes size for opset 18 and up");if(r.axes.length>0){if(i.length!==0&&i.length!==r.axes.length)throw new Error('Resize requires "scales" input size to be of axes rank when axes attributes is specified');if(a.length!==0&&a.length!==r.axes.length)throw new Error('Resize requires "sizes" input size to be of rank axes rank when axes attributes is specified')}if(typeof i<"u"&&typeof a<"u"&&i.length>0&&a.length>w)throw new Error("Resize requires only of scales or sizes to be specified")},au=(e,r)=>`fn getOriginalCoordinateFromResizedCoordinate(xResized: u32, xScale: f32, lengthResized: u32,
     lengthOriginal: u32, roiStart: f32, roiEnd: f32) -> ${r} { `+(()=>{switch(e){case"asymmetric":return`return ${r}(xResized) / ${r}(xScale);`;case"pytorch_half_pixel":return`if (lengthResized > 1) {
                    return (${r}(xResized) + 0.5) / ${r}(xScale) - 0.5;
                  } else {
                    return 0.0;
                  }`;case"tf_half_pixel_for_nn":return`return (${r}(xResized) + 0.5) / ${r}(xScale);`;case"align_corners":return`if (lengthResized == 1) {
                    return 0.0;
                  } else {
                    // The whole part and the fractional part are calculated separately due to inaccuracy of floating
                    // point division. As an example, f32(21) / f32(7) may evaluate to 2.99... instead of 3, causing an
                    // offset-by-one error later in floor().
                    let whole = ${r}(xResized * (lengthOriginal - 1) / (lengthResized - 1));
                    let fract =
                        ${r}(xResized * (lengthOriginal - 1) % (lengthResized - 1)) / ${r}(lengthResized - 1);
                    return whole + fract;
                  }`;case"tf_crop_and_resize":return`if (lengthResized > 1) {
                    return ${r}(roiStart) * ${r}(lengthOriginal - 1) +
                        (${r}(xResized) * ${r}(roiEnd - roiStart) * ${r}(lengthOriginal - 1)) /
                        ${r}(lengthResized - 1);
                  } else {
                    return 0.5 * ${r}(roiStart + roiEnd) * ${r}(lengthOriginal - 1);
                  }`;case"half_pixel_symmetric":return`const outputWidth = ${r}xScale * ${r}(lengthResized);
                  const adjustment = ${r}(lengthResized) / outputWidth;
                  const center = ${r}(lengthOriginal) / 2;
                  const offset = center * (1 - adjustment);
                  return offset + ((${r}(xResized) + 0.5) / ${r}(xScale)) - 0.5;`;case"half_pixel":return`return ((${r}(xResized) + 0.5) / ${r}(xScale)) - 0.5;`;default:throw new Error(`Coordinate transform mode ${e} is not supported`)}})()+"}",lu=(e,r,s)=>`fn getNearestPixelFromOriginal(xOriginal: ${s}, isDownSample: bool) -> ${s} {`+(()=>{switch(e){case"round_prefer_ceil":return"if (fract(xOriginal) == 0.5) {             return ceil(xOriginal);           } else {             return round(xOriginal);           }";case"floor":return"return floor(xOriginal);";case"ceil":return"return ceil(xOriginal);";case"round_prefer_floor":return"if (fract(xOriginal) == 0.5) {                     return floor(xOriginal);                   } else {                     return round(xOriginal);                   }";case"simple":default:if(r<11)return"if (isDownSample)                     {                       return ceil(xOriginal);                     } else {                       return xOriginal;                     }";throw new Error(`Nearest mode ${e} is not supported`)}})()+"}",Tn=(e,r,s)=>{let i=new Array(s).fill(0).concat(new Array(s).fill(1)),a=e.length===0?i:e.slice();return r.length>0?(r.forEach((c,l)=>{i[c]=a[l],i[l+s]=a[r.length+l]}),i):a},vs=(e,r,s,i)=>{let a=[];if(s.length>0)if(i.length>0){if(e.forEach(c=>a.push(c)),Math.max(...i)>e.length)throw new Error("axes is out of bound");i.forEach((c,l)=>a[c]=s[l])}else s.forEach(c=>a.push(c));else{if(r.length===0)throw new Error("Resize requires either scales or sizes.");a=e.map((c,l)=>Math.round(c*r[l]))}return a},Eo=(e,r,s)=>{let i=(()=>{switch(s.keepAspectRatioPolicy){case"not_larger":return s.axes.length>0?Math.min(...s.axes.map(c=>r[c]),Number.MAX_VALUE):Math.min(...r,Number.MAX_VALUE);case"not_smaller":return s.axes.length>0?Math.max(...s.axes.map(c=>r[c]),Number.MIN_VALUE):Math.max(...r,Number.MIN_VALUE);default:throw new Error(`Keep aspect ratio policy ${s.keepAspectRatioPolicy} is not supported`)}})();r.fill(1,0,r.length);let a=e.slice();return s.axes.length>0?(s.axes.forEach(c=>r[c]=i),s.axes.forEach(c=>a[c]=Math.round(e[c]*r[c]))):(r.fill(i,0,r.length),a.forEach((c,l)=>a[l]=Math.round(c*r[l]))),a},Wc=(e,r,s,i,a)=>`
    fn calculateOriginalIndicesFromOutputIndices(output_indices: ${e.type.indices}) -> array<${e.type.value}, ${s.length}> {
      var original_indices: array<${e.type.value}, ${s.length}>;
      for (var i:u32 = 0; i < ${s.length}; i++) {
        var output_index = ${e.indicesGet("output_indices","i")};
        var scale = ${Nt("uniforms.scales","i",i)};
        var roi_low = ${Nt("uniforms.roi","i",a)};
        var roi_hi = ${Nt("uniforms.roi",`i + ${r.length}`,a)};
        if (scale == 1.0) {
          original_indices[i] = ${e.type.value}(output_index);
        } else {
          var input_shape_i = ${Nt("uniforms.input_shape","i",r.length)};
          var output_shape_i = ${Nt("uniforms.output_shape","i",s.length)};
          original_indices[i] = getOriginalCoordinateFromResizedCoordinate(output_index, scale, output_shape_i,
                                                                           input_shape_i, roi_low, roi_hi);
        }
      }
      return original_indices;
    }`,Gc=(e,r,s,i,a,c,l)=>`
    fn calculateInputIndicesFromOutputIndices(output_indices: ${r.type.indices}) -> ${e.type.indices} {
      var input_indices: ${e.type.indices};
      for (var i:u32 = 0; i < ${i.length}; i++) {
        var output_index = ${r.indicesGet("output_indices","i")};
        var input_index: u32;
        var scale = ${Nt("uniforms.scales","i",a)};
        if (scale == 1.0) {
          input_index = output_index;
        } else {
          var roi_low = ${Nt("uniforms.roi","i",c)};
          var roi_hi = ${Nt("uniforms.roi",`i + ${s.length}`,c)};
          var input_shape_i = ${Nt("uniforms.input_shape","i",s.length)};
          var output_shape_i = ${Nt("uniforms.output_shape","i",i.length)};
          var original_idx = getOriginalCoordinateFromResizedCoordinate(output_index, scale, output_shape_i,
                                                                        input_shape_i, roi_low, roi_hi);
          if (!${l} || (original_idx >= 0 && original_idx < ${r.type.value}(input_shape_i))) {
            if (original_idx < 0) {
              input_index = 0;
            } else if (original_idx > ${r.type.value}(input_shape_i - 1)) {
              input_index = input_shape_i - 1;
            } else {
              input_index = u32(getNearestPixelFromOriginal(original_idx, scale < 1));
            }
          } else {
            input_index = u32(original_idx);
          }
        }
        ${e.indicesSet("input_indices","i"," input_index")}
      }
      return input_indices;
    }`,Ms=(e,r)=>`
    fn checkInputIndices(input_indices: ${e.type.indices}) -> bool {
      for (var i:u32 = 0; i < ${r.length}; i++) {
        var input_index = ${e.indicesGet("input_indices","i")};
        if (input_index < 0 || input_index >= ${Nt("uniforms.input_shape","i",r.length)}) {
          return false;
        }
      }
      return true;
    }`,uu=(e,r,s,i)=>e.rank>i?`
    ${e.indicesSet("input_indices",r,"channel")};
    ${e.indicesSet("input_indices",s,"batch")};
`:"",Ls=(e,r,s,i,a)=>{let[c,l,h,_]=s.length===2?[-1,0,1,-1]:[0,2,3,1],w=e.type.value;return`
    fn getInputValue(batch: u32, channel: u32, row: u32, col: u32) -> ${w} {
      var input_indices: ${e.type.indices};
      ${e.indicesSet("input_indices",l,`max(0, min(row, ${s[l]} - 1))`)};
      ${e.indicesSet("input_indices",h,`max(0, min(col, ${s[h]} - 1))`)};
      ${uu(e,_,c,2)}
      return ${e.getByIndices("input_indices")};
    }

    fn bilinearInterpolation(output_indices: ${r.type.indices}) -> ${w} {
      var originalIndices = calculateOriginalIndicesFromOutputIndices(output_indices);
      var row:${w} = originalIndices[${l}];
      var col:${w} = originalIndices[${h}];
      ${i?`if (row < 0 || row > (${s[l]} - 1) || col < 0 || col > (${s[h]} - 1)) {
        return ${a};
      }`:""};
      row = max(0, min(row, ${s[l]} - 1));
      col = max(0, min(col, ${s[h]} - 1));
      var row1: u32 = u32(row);
      var col1: u32 = u32(col);
      var row2: u32 = u32(row + 1);
      var col2: u32 = u32(col + 1);
      var channel: u32 = ${s.length>2?`u32(originalIndices[${_}])`:"0"};
      var batch: u32 =  ${s.length>2?`u32(originalIndices[${c}])`:"0"};
      var x11: ${w} = getInputValue(batch, channel, row1, col1);
      var x12: ${w} = getInputValue(batch, channel, row1, col2);
      var x21: ${w} = getInputValue(batch, channel, row2, col1);
      var x22: ${w} = getInputValue(batch, channel, row2, col2);
      var dx1: ${w} = abs(row - ${w}(row1));
      var dx2: ${w} = abs(${w}(row2) - row);
      var dy1: ${w} = abs(col - ${w}(col1));
      var dy2: ${w} = abs(${w}(col2) - col);
      if (row1 == row2) {
        dx1 = 0.5;
        dx2 = 0.5;
      }
      if (col1 == col2) {
        dy1 = 0.5;
        dy2 = 0.5;
      }
      return (x11 * dx2 * dy2 + x12 * dx2 * dy1 + x21 * dx1 * dy2 + x22 * dx1 * dy1);
    }`},_p=(e,r,s,i,a,c,l,h,_,w)=>{let v=s.length===2,[y,d]=v?[0,1]:[2,3],S=e.type.value,B=j=>{let Y=j===y?"row":"col";return`
      fn ${Y}CubicInterpolation(input_indices: ${e.type.indices}, output_indices: ${r.type.indices}) -> ${S} {
        var output_index = ${r.indicesGet("output_indices",j)};
        var originalIdx: ${S} = getOriginalCoordinateFromResizedCoordinate(output_index, ${a[j]},
        ${i[j]}, ${s[j]}, ${c[j]}, ${c[j]} + ${s.length});
        var fractOriginalIdx: ${S} = originalIdx - floor(originalIdx);
        var coefs = getCubicInterpolationCoefs(fractOriginalIdx);

        if (${h} && (originalIdx < 0 || originalIdx > (${s[j]} - 1))) {
          return ${_};
        }
        var data: array<${S}, 4> = array<${S}, 4>(0.0, 0.0, 0.0, 0.0);
        for (var i: i32 = -1; i < 3; i++) {
          var ${Y}: ${S} = originalIdx + ${S}(i);
          if (${Y} < 0 || ${Y} >= ${s[j]}) {
            ${w?`coefs[i + 1] = 0.0;
                        continue;`:h?`return ${_};`:`${Y} = max(0, min(${Y}, ${s[j]} - 1));`};
          }
        var input_indices_copy: ${e.type.indices} = input_indices;
          ${e.indicesSet("input_indices_copy",j,`u32(${Y})`)};
          data[i + 1] = ${j===y?e.getByIndices("input_indices_copy"):"rowCubicInterpolation(input_indices_copy, output_indices)"};
        }
        return cubicInterpolation1D(data, coefs);
      }`};return`
    ${B(y)};
    ${B(d)};
  fn getCubicInterpolationCoefs(s: ${S}) -> array<${S}, 4> {
    var absS = abs(s);
    var coeffs: array<${S}, 4> = array<${S}, 4>(0.0, 0.0, 0.0, 0.0);
    var oneMinusAbsS: ${S} = 1.0 - absS;
    var twoMinusAbsS: ${S} = 2.0 - absS;
    var onePlusAbsS: ${S} = 1.0 + absS;
    coeffs[0] = ((${l} * onePlusAbsS - 5 * ${l}) * onePlusAbsS + 8 * ${l}) * onePlusAbsS - 4 * ${l};
    coeffs[1] = ((${l} + 2) * absS - (${l} + 3)) * absS * absS + 1;
    coeffs[2] = ((${l} + 2) * oneMinusAbsS - (${l} + 3)) * oneMinusAbsS * oneMinusAbsS + 1;
    coeffs[3] = ((${l} * twoMinusAbsS - 5 * ${l}) * twoMinusAbsS + 8 * ${l}) * twoMinusAbsS - 4 * ${l};
    return coeffs;
  }

  fn cubicInterpolation1D(x: array<${S}, 4>, coefs: array<${S}, 4>) -> ${S} {
    var coefsSum: ${S} = coefs[0] + coefs[1] + coefs[2] + coefs[3];
    return (x[0] * coefs[0] + x[1] * coefs[1]+ x[2] * coefs[2]+ x[3] * coefs[3]) / coefsSum;
  }

  fn bicubicInterpolation(output_indices: ${r.type.indices}) -> ${S} {
    var input_indices: ${e.type.indices} = output_indices;
    return colCubicInterpolation(input_indices, output_indices);
  }
    `},lr=(e,r,s,i,a)=>{let[c,l,h,_,w]=s.length===3?[-1,0,1,2,-1]:[0,2,3,4,1],v=e.type.value;return`
    fn getInputValue(batch: u32, channel: u32, depth:u32, height: u32, width: u32) -> ${v} {
      var input_indices: ${e.type.indices};
      ${e.indicesSet("input_indices",l,`max(0, min(depth, ${s[l]} - 1))`)};
      ${e.indicesSet("input_indices",h,`max(0, min(height, ${s[h]} - 1))`)};
      ${e.indicesSet("input_indices",_,`max(0, min(width, ${s[_]} - 1))`)};
      ${uu(e,w,c,3)}
      return ${e.getByIndices("input_indices")};
    }

    fn trilinearInterpolation(output_indices: ${r.type.indices}) -> ${v} {
      var originalIndices = calculateOriginalIndicesFromOutputIndices(output_indices);
      var depth:${v} = originalIndices[${l}];
      var height:${v} = originalIndices[${h}];
      var width:${v} = originalIndices[${_}];
      ${i?`if (depth < 0 || depth > (${s[l]} - 1) || height < 0 || height > (${s[h]} - 1) || width < 0 || (width > ${s[_]} - 1)) {
      return ${a};
        }`:""};

    depth = max(0, min(depth, ${s[l]} - 1));
      height = max(0, min(height, ${s[h]} - 1));
      width = max(0, min(width, ${s[_]} - 1));
      var depth1: u32 = u32(depth);
      var height1: u32 = u32(height);
      var width1: u32 = u32(width);
      var depth2: u32 = u32(depth + 1);
      var height2: u32 = u32(height + 1);
      var width2: u32 = u32(width + 1);
      var channel: u32 = ${s.length>3?`u32(originalIndices[${w}])`:"0"};
      var batch: u32 =  ${s.length>3?`u32(originalIndices[${c}])`:"0"};

      var x111: ${v} = getInputValue(batch, channel, depth1, height1, width1);
      var x112: ${v} = getInputValue(batch, channel, depth1, height1, width2);
      var x121: ${v} = getInputValue(batch, channel, depth1, height2, width1);
      var x122: ${v} = getInputValue(batch, channel, depth1, height2, width2);
      var x211: ${v} = getInputValue(batch, channel, depth2, height1, width1);
      var x212: ${v} = getInputValue(batch, channel, depth2, height1, width2);
      var x221: ${v} = getInputValue(batch, channel, depth2, height2, width1);
      var x222: ${v} = getInputValue(batch, channel, depth2, height2, width2);
      var dx1: ${v} = abs(depth - ${v}(depth1));
      var dx2: ${v} = abs(${v}(depth2) - depth);
      var dy1: ${v} = abs(height - ${v}(height1));
      var dy2: ${v} = abs(${v}(height2) - height);
      var dz1: ${v} = abs(width - ${v}(width1));
      var dz2: ${v} = abs(${v}(width2) - width);
      if (depth1 == depth2) {
        dx1 = 0.5;
        dx2 = 0.5;
      }
      if (height1 == height2) {
        dy1 = 0.5;
        dy2 = 0.5;
      }
      if (width1 == width2) {
        dz1 = 0.5;
        dz2 = 0.5;
      }
      return (x111 * dx2 * dy2 * dz2 + x112 * dx2 * dy2 * dz1 + x121 * dx2 * dy1 *dz2 + x122 * dx2 * dy1 * dz1 +
              x211 * dx1 * dy2 * dz2 + x212 * dx1 * dy2 * dz1 + x221 * dx1 * dy1 *dz2 + x222 * dx1 * dy1 * dz1);
    }`},Kc=(e,r,s,i,a,c)=>{let l=e.dims,h=Tn(c,r.axes,l.length),_=vs(l,i,a,r.axes),w=i.slice();i.length===0&&(w=l.map((J,ye)=>J===0?1:_[ye]/J),r.keepAspectRatioPolicy!=="stretch"&&(_=Eo(l,w,r)));let v=Ut("output",e.dataType,_.length),y=it("input",e.dataType,l.length),d=Qe.size(_),S=l.length===_.length&&l.every((J,ye)=>J===_[ye]),B=r.coordinateTransformMode==="tf_crop_and_resize",j=r.extrapolationValue,Y=y.type.value,te=J=>`
      ${S?"":`
      ${au(r.coordinateTransformMode,Y)};
      ${(()=>{switch(r.mode){case"nearest":return`
              ${Ms(y,l)};
              ${lu(r.nearestMode,s,Y)};
              ${Gc(y,v,l,_,w.length,h.length,B)};
              `;case"linear":return`
              ${Wc(v,l,_,w.length,h.length)};
              ${(()=>{if(l.length===2||l.length===4)return`${Ls(y,v,l,B,j)}`;if(l.length===3||l.length===5)return`${lr(y,v,l,B,j)}`;throw Error("Linear mode only supports input dims 2, 3, 4 and 5 are supported in linear mode.")})()};
            `;case"cubic":return`
            ${(()=>{if(l.length===2||l.length===4)return`${_p(y,v,l,_,w,h,r.cubicCoeffA,B,r.extrapolationValue,r.excludeOutside)}`;throw Error("Cubic mode only supports input dims 2 and 4 are supported in linear mode.")})()};
            `;default:throw Error("Invalid resize mode")}})()};
      `}
      ${J.registerUniform("output_size","u32").registerUniform("scales","f32",w.length).registerUniform("roi","f32",h.length).declareVariables(y,v)}
      ${J.mainStart()}
        ${J.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
        ${S?"output[global_idx] = input[global_idx];":`
        let output_indices = ${v.offsetToIndices("global_idx")};
        var input_indices: ${y.type.indices};
        ${(()=>{switch(r.mode){case"nearest":return`input_indices = calculateInputIndicesFromOutputIndices(output_indices);
                if (checkInputIndices(input_indices)) {
                  output[global_idx] = ${y.getByIndices("input_indices")};
                } else {
                  output[global_idx] = ${r.extrapolationValue};
                }`;case"linear":return`output[global_idx] = ${l.length===2||l.length===4?"bilinearInterpolation":"trilinearInterpolation"}(output_indices);`;case"cubic":return"output[global_idx] = bicubicInterpolation(output_indices);";default:throw Error(`Unsupported resize mode: ${r.mode}`)}})()};
`}
      }`;return{name:"Resize",shaderCache:{hint:`${r.cacheKey}|${s}|${w.length>0?w:""}|${a.length>0?a:""}|${h.length>0?h:""}|${S}|${l}`,inputDependencies:["rank"]},getShaderSource:te,getRunData:()=>({outputs:[{dims:_,dataType:e.dataType}],dispatchGroup:{x:Math.ceil(d/64)},programUniforms:[{type:12,data:d},{type:1,data:w},{type:1,data:h},...Tt(l,_)]})}},wn=e=>{let r=e.customDataBuffer;return new Uint32Array(r,r.byteOffset,1)[0]},bn=(e,r)=>{let s=[],i=[],a=[],c=wn(e);if(r.antialias!==0)throw Error("Only default value (0) for Antialias attribute is supported");Vc(e.inputs,r,c,s,i,a),e.compute(Kc(e.inputs[0],r,c,s,i,a),{inputs:[0]})},Dn=e=>{let r=e.antialias,s=e.axes,i=e.coordinateTransformMode,a=e.cubicCoeffA,c=e.excludeOutside!==0,l=e.extrapolationValue,h=e.keepAspectRatioPolicy,_=e.mode,w=e.nearestMode===""?"simple":e.nearestMode;return Ht({antialias:r,axes:s,coordinateTransformMode:i,cubicCoeffA:a,excludeOutside:c,extrapolationValue:l,keepAspectRatioPolicy:h,mode:_,nearestMode:w})}}),Hc,cs,Tr,T=E(()=>{Rt(),qt(),hr(),or(),Hc=(e,r)=>{let[s,i,a,c]=e,{numHeads:l,rotaryEmbeddingDim:h}=r;if(s.dims.length!==3&&s.dims.length!==4)throw new Error(`Input 'x' is expected to have 3 or 4 dimensions, got ${s.dims.length}`);if(!Qe.areEqual(i.dims,[])&&!Qe.areEqual(i.dims,[1])&&i.dims.length!==2)throw new Error(`Input 'position_ids' is expected to have 0, 1, or 2 dimensions, got ${i.dims.length}`);if(a.dims.length!==2)throw new Error(`Input 'cos_cache' is expected to have 2 dimensions, got ${a.dims.length}`);if(c.dims.length!==2)throw new Error(`Input 'sin_cache' is expected to have 2 dimensions, got ${c.dims.length}`);if(!Qe.areEqual(a.dims,c.dims))throw new Error("Inputs 'cos_cache' and 'sin_cache' are expected to have the same shape");if(h>0&&l===0)throw new Error("num_heads must be provided if rotary_embedding_dim is specified");let _=s.dims[0],w=s.dims[s.dims.length-2],v=a.dims[0],y=Qe.sizeFromDimension(s.dims,1)/w,d=h===0?a.dims[1]*2:y/l;if(h>d)throw new Error("rotary_embedding_dim must be less than or equal to head_size");if(i.dims.length===2){if(_!==i.dims[0])throw new Error(`Input 'position_ids' dimension 0 should be of size batch_size, got ${i.dims[0]}`);if(w!==i.dims[1])throw new Error(`Input 'position_ids' dimension 1 should be of size sequence_length, got ${i.dims[1]}`)}if(d/2!==a.dims[1]&&h/2!==a.dims[1])throw new Error(`Input 'cos_cache' dimension 1 should be same as head_size / 2 or rotary_embedding_dim / 2, got ${a.dims[1]}`);if(w>v)throw new Error("Updating cos_cache and sin_cache in RotaryEmbedding is not currently supported")},cs=(e,r)=>{let{interleaved:s,numHeads:i,rotaryEmbeddingDim:a,scale:c}=r,l=e[0].dims[0],h=Qe.sizeFromDimension(e[0].dims,1),_=e[0].dims[e[0].dims.length-2],w=h/_,v=e[2].dims[1],y=a===0?v*2:w/i,d=new Array(l,_,w/y,y-v),S=Qe.computeStrides(d),B=[{type:1,data:c},{type:12,data:d},{type:12,data:S},...e[0].dims.length===3?new Array({type:12,data:[h,w,y,1]}):[],...e[0].dims.length===4?new Array({type:12,data:[h,y,_*y,1]}):[],...Tt(e[0].dims,e[1].dims,e[2].dims,e[3].dims,e[0].dims)],j=Y=>{let te=it("input",e[0].dataType,e[0].dims.length),J=it("position_ids",e[1].dataType,e[1].dims.length),ye=it("cos_cache",e[2].dataType,e[2].dims.length),ve=it("sin_cache",e[3].dataType,e[3].dims.length),Ce=Ut("output",e[0].dataType,e[0].dims.length);return Y.registerUniforms([{name:"scale",type:"f32"},{name:"global_shape",type:"u32",length:d.length},{name:"global_strides",type:"u32",length:S.length},{name:"input_output_strides",type:"u32",length:S.length}]),`
        ${Y.declareVariables(te,J,ye,ve,Ce)}

        ${Y.mainStart(gn)}
          let half_rotary_emb_dim = uniforms.${ye.name}_shape[1];
          let bsnh = global_idx / uniforms.global_strides % uniforms.global_shape;
          let size = uniforms.global_shape[0] * uniforms.global_strides[0];
          ${Y.guardAgainstOutOfBoundsWorkgroupSizes("size")}

          if (bsnh[3] < half_rotary_emb_dim) {
            let position_ids_idx =
                ${J.broadcastedIndicesToOffset("bsnh.xy",Ut("",J.type.tensor,2))};
            let position_id =
                u32(${J.getByOffset("position_ids_idx")}) + select(0, bsnh[1], position_ids_idx == 0);
            let i = dot(bsnh, uniforms.input_output_strides) + select(0, bsnh[3], ${s});
            let j = i + select(half_rotary_emb_dim, 1, ${s});
            let re = ${te.getByOffset("i")} * ${ye.get("position_id","bsnh[3]")} -
                ${te.getByOffset("j")} * ${ve.get("position_id","bsnh[3]")};
            ${Ce.setByOffset("i","re")}
            let im = ${te.getByOffset("i")} * ${ve.get("position_id","bsnh[3]")} +
                ${te.getByOffset("j")} * ${ye.get("position_id","bsnh[3]")};
            ${Ce.setByOffset("j","im")}
          } else {
            let k = dot(bsnh, uniforms.input_output_strides) + half_rotary_emb_dim;
            ${Ce.setByOffset("k",te.getByOffset("k"))}
          }
        }`};return{name:"RotaryEmbedding",shaderCache:{hint:Ht({interleaved:s}).cacheKey,inputDependencies:["rank","rank","rank","rank"]},getShaderSource:j,getRunData:()=>({outputs:[{dims:e[0].dims,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(Qe.size(d)/gn)},programUniforms:B})}},Tr=(e,r)=>{Hc(e.inputs,r),e.compute(cs(e.inputs,r))}}),O,G,$e,Ue=E(()=>{Rt(),qt(),or(),O=e=>{if(!e||e.length<3)throw new Error("layerNorm requires at least 3 inputs.");let r=e[0],s=e[1],i=e[2];if(r.dataType!==s.dataType||r.dataType!==i.dataType)throw new Error("All inputs must have the same data type");if(r.dims.length!==3&&r.dims.length!==2)throw new Error("Input must be 2D or 3D");if(s.dims.length!==3&&s.dims.length!==2)throw new Error("Skip must be 2D or 3D");let a=r.dims[r.dims.length-1],c=r.dims[r.dims.length-2];if(s.dims[s.dims.length-1]!==a)throw new Error("Skip must have the same hidden size as input");if(s.dims[s.dims.length-2]!==c)throw new Error("Skip must have the same sequence length as input");if(i.dims.length!==1)throw new Error("Gamma must be 1D");if(i.dims[i.dims.length-1]!==a)throw new Error("Gamma must have the same hidden size as input");if(e.length>3){let l=e[3];if(l.dims.length!==1)throw new Error("Beta must be 1D");if(l.dims[l.dims.length-1]!==a)throw new Error("Beta must have the same hidden size as input")}if(e.length>4){let l=e[4];if(l.dims.length!==1)throw new Error("Bias must be 1D");if(l.dims[l.dims.length-1]!==a)throw new Error("Bias must have the same hidden size as input")}},G=(e,r,s,i)=>{let a=r.simplified,c=e[0].dims,l=Qe.size(c),h=c,_=l,w=c.slice(-1)[0],v=i?c.slice(0,-1).concat(1):[],y=!a&&e.length>3,d=e.length>4,S=i&&s>1,B=i&&s>2,j=s>3,Y=64,te=Jt(w),J=[{type:12,data:_},{type:12,data:te},{type:12,data:w},{type:1,data:r.epsilon}],ye=Ce=>{let Ze=[{name:"output_size",type:"u32"},{name:"components",type:"u32"},{name:"hidden_size",type:"u32"},{name:"epsilon",type:"f32"}],Ke=[it("x",e[0].dataType,e[0].dims,te),it("skip",e[1].dataType,e[1].dims,te),it("gamma",e[2].dataType,e[2].dims,te)];y&&Ke.push(it("beta",e[3].dataType,e[3].dims,te)),d&&Ke.push(it("bias",e[4].dataType,e[4].dims,te)),Ke.push(Ut("output",e[0].dataType,h,te)),S&&Ke.push(Ut("mean_output",1,v)),B&&Ke.push(Ut("inv_std_output",1,v)),j&&Ke.push(Ut("input_skip_bias_sum",e[0].dataType,h,te));let ft=_r(e[0].dataType),It=_r(1,te);return`

      ${Ce.registerUniforms(Ze).declareVariables(...Ke)}
      var<workgroup> sum_shared : array<${It}, ${Y}>;
      var<workgroup> sum_squared_shared : array<${It}, ${Y}>;

      ${Ce.mainStart([Y,1,1])}
        let ix = local_id.x;
        let iy = global_id.x / ${Y};

        let hidden_size_vectorized: u32 = uniforms.hidden_size / uniforms.components;
        var stride = hidden_size_vectorized / ${Y};
        let offset = ix * stride + iy * hidden_size_vectorized;
        let offset1d = stride * ix;
        if (ix == ${Y-1}) {
          stride = hidden_size_vectorized - stride * ix;
        }
        for (var i: u32 = 0; i < stride; i++) {
          let skip_value = skip[offset + i];
          let bias_value = ${d?"bias[offset1d + i]":ft+"(0.0)"};
          let input_value = x[offset + i];
          let value = input_value + skip_value + bias_value;
          ${j?"input_skip_bias_sum[offset + i] = value;":""}
          output[offset + i] = value;
          let f32_value = ${ns(ft,te,"value")};
          sum_shared[ix] += f32_value;
          sum_squared_shared[ix] += f32_value * f32_value;
        }
        workgroupBarrier();

        var reduce_size : u32 = ${Y};
        for (var curr_size = reduce_size >> 1;  curr_size > 0; curr_size = reduce_size >> 1) {
          reduce_size = curr_size + (reduce_size & 1);
          if (ix < curr_size) {
            sum_shared[ix] += sum_shared[ix + reduce_size];
            sum_squared_shared[ix] += sum_squared_shared[ix + reduce_size];
          }
          workgroupBarrier();
        }

        let sum = sum_shared[0];
        let square_sum = sum_squared_shared[0];
        let mean = ${Hs("sum",te)} / f32(uniforms.hidden_size);
        let inv_std_dev = inverseSqrt(${Hs("square_sum",te)} / f32(uniforms.hidden_size) ${a?"":"- mean * mean"} + uniforms.epsilon);
        ${S?"mean_output[global_idx] = mean;":""}
        ${B?"inv_std_output[global_idx] = inv_std_dev;":""}

        for (var i: u32 = 0; i < stride; i++) {
          output[offset + i] = (output[offset + i] ${a?"":`- ${ft}(mean)`}) *
            ${ft}(inv_std_dev) * gamma[offset1d + i]
            ${y?"+ beta[offset1d + i]":""};
        }
      }`},ve=[{dims:h,dataType:e[0].dataType}];return s>1&&ve.push({dims:v,dataType:1}),s>2&&ve.push({dims:v,dataType:1}),s>3&&ve.push({dims:c,dataType:e[0].dataType}),{name:"SkipLayerNormalization",shaderCache:{hint:`${te};${S};${B};${j}`,inputDependencies:e.map((Ce,Ze)=>"type")},getShaderSource:ye,getRunData:()=>({outputs:ve,dispatchGroup:{x:Math.ceil(_/w)},programUniforms:J})}},$e=(e,r)=>{O(e.inputs);let s=[0];e.outputCount>1&&s.push(-3),e.outputCount>2&&s.push(-3),e.outputCount>3&&s.push(3),e.compute(G(e.inputs,r,e.outputCount,!1),{outputs:s})}}),ze,rt,ut,Mt,At,Kt,Ot,Qt,Vt=E(()=>{Rt(),qt(),hr(),or(),ze=(e,r)=>{if(!e||e.length<1)throw new Error("too few inputs");if(r.axes.length!==0){if(r.axes.length!==r.starts.length||r.axes.length!==r.ends.length)throw new Error("axes, starts and ends must have the same length")}else if(r.starts.length!==r.ends.length)throw new Error("starts and ends must have the same length");e.slice(1).forEach((s,i)=>{if(e[i+1].dataType!==6&&e[i+1].dataType!==7)throw new Error(`Input ${i} must be an array of int32 or int64`)})},rt=(e,r)=>{let s=[];if(e.length>r)if(e[r].dataType===7)e[r].getBigInt64Array().forEach(i=>s.push(Number(i)));else if(e[r].dataType===6)e[r].getInt32Array().forEach(i=>s.push(Number(i)));else throw new Error(`Input ${r} must be an array of int32 or int64`);return s},ut=(e,r)=>{if(e.length>1){let s=rt(e,1),i=rt(e,2),a=rt(e,3);return a.length===0&&(a=[...Array(e[0].dims.length).keys()]),Ht({starts:s,ends:i,axes:a})}else return r},Mt=(e,r,s,i,a)=>{let c=e;return e<0&&(c+=s[i[r]]),a[r]<0?Math.max(0,Math.min(c,s[i[r]]-1)):Math.max(0,Math.min(c,s[i[r]]))},At=(e,r,s)=>`fn calculateInputIndices(output_indices: ${r.type.indices}) -> ${e.type.indices} {
          var input_indices: ${e.type.indices};
          var carry = 0u;
          for (var i = ${s.length}; i >= 0; i--) {
            let input_shape_i = ${Nt("uniforms.input_shape","i",s.length)};
            let steps_i = ${Nt("uniforms.steps","i",s.length)};
            let signs_i = ${Nt("uniforms.signs","i",s.length)};
            let starts_i = ${Nt("uniforms.starts","i",s.length)};
            var output_index = ${r.indicesGet("output_indices","i")};
            var input_index = output_index * steps_i + starts_i + carry;
            carry = input_index / input_shape_i;
            input_index = input_index % input_shape_i;
            if (signs_i < 0) {
              input_index = input_shape_i - input_index - 1u + starts_i;
            }
            ${e.indicesSet("input_indices","i","input_index")};
          }
          return input_indices;
      }`,Kt=(e,r)=>{let s=e[0].dims,i=Qe.size(s),a=r.axes.length>0?Qe.normalizeAxes(r.axes,s.length):[...Array(s.length).keys()],c=rt(e,4);c.forEach(te=>te!==0||(()=>{throw new Error("step cannot be 0")})),c.length===0&&(c=Array(a.length).fill(1));let l=r.starts.map((te,J)=>Mt(te,J,s,a,c)),h=r.ends.map((te,J)=>Mt(te,J,s,a,c));if(a.length!==l.length||a.length!==h.length)throw new Error("start, ends and axes should have the same number of elements");if(a.length!==s.length)for(let te=0;te<s.length;++te)a.includes(te)||(l.splice(te,0,0),h.splice(te,0,s[te]),c.splice(te,0,1));let _=c.map(te=>Math.sign(te));c.forEach((te,J,ye)=>{if(te<0){let ve=(h[J]-l[J])/te,Ce=l[J],Ze=Ce+ve*c[J];l[J]=Ze,h[J]=Ce,ye[J]=-te}});let w=s.slice(0);a.forEach((te,J)=>{w[te]=Math.ceil((h[te]-l[te])/c[te])});let v={dims:w,dataType:e[0].dataType},y=Ut("output",e[0].dataType,w.length),d=it("input",e[0].dataType,e[0].dims.length),S=Qe.size(w),B=[{name:"outputSize",type:"u32"},{name:"starts",type:"u32",length:l.length},{name:"signs",type:"i32",length:_.length},{name:"steps",type:"u32",length:c.length}],j=[{type:12,data:S},{type:12,data:l},{type:6,data:_},{type:12,data:c},...Tt(e[0].dims,w)],Y=te=>`
      ${te.registerUniforms(B).declareVariables(d,y)}
        ${At(d,y,s)}
        ${te.mainStart()}
          ${te.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
          let output_indices = ${y.offsetToIndices("global_idx")};
          let input_indices = calculateInputIndices(output_indices);
          ${y.setByOffset("global_idx",d.getByIndices("input_indices"))}
      }`;return{name:"Slice",shaderCache:{hint:`${_.length}_${l.length}_${c.length}`,inputDependencies:["rank"]},getShaderSource:Y,getRunData:()=>({outputs:[v],dispatchGroup:{x:Math.ceil(i/64)},programUniforms:j})}},Ot=(e,r)=>{ze(e.inputs,r);let s=ut(e.inputs,r);e.compute(Kt(e.inputs,s),{inputs:[0]})},Qt=e=>{let r=e.starts,s=e.ends,i=e.axes;return Ht({starts:r,ends:s,axes:i})}}),nr,dr,sr,pr,sn=E(()=>{Rt(),qt(),hr(),mo(),or(),nr=e=>{if(!e||e.length!==1)throw new Error("Softmax op requires 1 input.")},dr=(e,r)=>{let s=e.inputs[0],i=s.dims,a=Qe.size(i),c=64,l=i.length,h=Qe.normalizeAxis(r.axis,l),_=h<i.length-1,w,v=[];_?(v=Array.from({length:l},(Ke,ft)=>ft),v[h]=l-1,v[l-1]=h,w=e.compute(Un(s,v),{inputs:[s],outputs:[-1]})[0]):w=s;let y=w.dims,d=y[l-1],S=a/d,B=Jt(d),j=d/B,Y=(Ke,ft)=>ft===4?`max(max(${Ke}.x, ${Ke}.y), max(${Ke}.z, ${Ke}.w))`:ft===2?`max(${Ke}.x, ${Ke}.y)`:ft===3?`max(max(${Ke}.x, ${Ke}.y), ${Ke}.z)`:Ke,te=it("x",w.dataType,w.dims,B),J=Ut("result",w.dataType,w.dims,B),ye=te.type.value,ve=_r(w.dataType)==="f32"?`var threadMax = ${ye}(-3.402823e+38f);`:`var threadMax = ${ye}(-65504.0h);`,Ce=Ke=>`
      var<workgroup> rowMaxShared : ${ye};
      var<workgroup> rowSumShared : ${ye};
      var<workgroup> threadShared : array<${ye}, ${c}>;

      fn getValue(row: i32, col: i32, row_stride: i32) -> ${ye} {
        let index = row * row_stride + col;
        return x[index];
      }

      fn setValue(row: i32, col: i32, row_stride: i32, value: ${ye}) {
        let index = row * row_stride + col;
        result[index] = value;
      }
      ${Ke.registerUniform("packedCols","i32").declareVariables(te,J)}
      ${Ke.mainStart()}
        let gindex = i32(global_idx);
        let lindex = i32(local_idx);
        const wg = ${c};
        let row = gindex / wg;
        let cols = uniforms.packedCols;
        let row_stride : i32 = uniforms.packedCols;

        // find the rows max
        ${ve}
        for (var col = lindex; col < cols; col += wg) {
          let value = getValue(row, col, row_stride);
          threadMax = max(threadMax, value);
        }
        if (lindex < cols) {
          threadShared[lindex] = threadMax;
        }
        workgroupBarrier();

        var reduceSize = min(cols, wg);
        for (var currSize = reduceSize >> 1;  currSize > 0; currSize = reduceSize >> 1) {
          reduceSize = currSize + (reduceSize & 1);
          if (lindex < currSize) {
            threadShared[lindex] = max(threadShared[lindex], threadShared[lindex + reduceSize]);
          }
          workgroupBarrier();
        }
        if (lindex == 0) {
          rowMaxShared = ${ye}(${Y("threadShared[0]",B)});
        }
        workgroupBarrier();

        // find the rows sum
        var threadSum = ${ye}(0.0);
        for (var col = lindex; col < cols; col += wg) {
          let subExp = exp(getValue(row, col, row_stride) - rowMaxShared);
          threadSum += subExp;
        }
        threadShared[lindex] = threadSum;
        workgroupBarrier();

        for (var currSize = wg >> 1;  currSize > 0; currSize = currSize >> 1) {
          if (lindex < currSize) {
            threadShared[lindex] = threadShared[lindex] + threadShared[lindex + currSize];
          }
          workgroupBarrier();
        }
        if (lindex == 0) {
          rowSumShared = ${ye}(${Hs("threadShared[0]",B)});
        }
        workgroupBarrier();

        // calculate final value for each element in the row
        for (var col = lindex; col < cols; col += wg) {
          let value = exp(getValue(row, col, row_stride) - rowMaxShared) / rowSumShared;
          setValue(row, col, row_stride, value);
        }
      }`,Ze=e.compute({name:"Softmax",shaderCache:{hint:`${B}`,inputDependencies:["type"]},getRunData:()=>({outputs:[{dims:y,dataType:w.dataType}],dispatchGroup:{x:S},programUniforms:[{type:6,data:j}]}),getShaderSource:Ce},{inputs:[w],outputs:[_?-1:0]})[0];_&&e.compute(Un(Ze,v),{inputs:[Ze]})},sr=(e,r)=>{nr(e.inputs),dr(e,r)},pr=e=>Ht({axis:e.axis})}),br,Br,Or,qr,_n,un,tn,xs=E(()=>{Rt(),qt(),hr(),or(),br=e=>{if(!e||e.length<1)throw new Error("too few inputs")},Br=(e,r)=>{let s=[],i=r.numOutputs;return e[1].dims[0]>0&&(e[1].getBigInt64Array().forEach(a=>s.push(Number(a))),i=s.length),Ht({numOutputs:i,axis:r.axis,splitSizes:s})},Or=e=>`
fn calculateOutputIndex(index: u32) -> u32 {
    for (var i: u32 = 0u; i < ${e}u; i += 1u ) {
    if (index < ${Nt("uniforms.size_in_split_axis","i",e)}) {
        return i;
    }
    }
    return ${e}u;
}`,qr=e=>{let r=e.length,s=[];for(let i=0;i<r;++i){let a=e[i].setByIndices("indices","input[global_idx]");r===1?s.push(a):i===0?s.push(`if (output_number == ${i}u) { ${a} }`):i===r-1?s.push(`else { ${a} }`):s.push(`else if (output_number == ${i}) { ${a} }`)}return`
      fn writeBufferData(output_number: u32, indices: ${e[0].type.indices}, global_idx: u32) {
        ${s.join(`
`)}
      }`},_n=(e,r)=>{let s=e[0].dims,i=Qe.size(s),a=e[0].dataType,c=Qe.normalizeAxis(r.axis,s.length),l=new Array(r.numOutputs),h=it("input",a,s.length),_=new Array(r.numOutputs),w=[],v=[],y=0,d=[{type:12,data:i}];for(let B=0;B<r.numOutputs;B++){y+=r.splitSizes[B],_[B]=y;let j=s.slice();j[c]=r.splitSizes[B],v.push(j),l[B]=Ut(`output${B}`,a,j.length),w.push({dims:v[B],dataType:e[0].dataType})}d.push({type:12,data:_},...Tt(s,...v));let S=B=>`
  ${B.registerUniform("input_size","u32").registerUniform("size_in_split_axis","u32",_.length).declareVariables(h,...l)}
  ${Or(_.length)}
  ${qr(l)}

  ${B.mainStart()}
    ${B.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.input_size")}

    var indices = ${h.offsetToIndices("global_idx")};
    var index = ${h.indicesGet("indices",c)};
    let output_number = calculateOutputIndex(index);
    if (output_number != 0) {
      index -= ${Nt("uniforms.size_in_split_axis","output_number - 1u",_.length)};
      ${h.indicesSet("indices",c,"index")};
    }
    writeBufferData(output_number, indices, global_idx);
  }`;return{name:"Split",shaderCache:{hint:r.cacheKey,inputDependencies:["rank"]},getShaderSource:S,getRunData:()=>({outputs:w,dispatchGroup:{x:Math.ceil(i/64)},programUniforms:d})}},un=(e,r)=>{br(e.inputs);let s=e.inputs.length===1?r:Br(e.inputs,r);e.compute(_n(e.inputs,s),{inputs:[0]})},tn=e=>{let r=e.axis,s=e.splitSizes,i=e.numOutputs<0?s.length:e.numOutputs;if(i!==s.length)throw new Error("numOutputs and splitSizes lengh must be equal");return Ht({axis:r,numOutputs:i,splitSizes:s})}}),ds,Qr,Ds,cu=E(()=>{Rt(),qt(),or(),ds=(e,r,s,i,a)=>{let c=Ut("output_data",a,s.length,4),l=it("a_data",r[1].dataType,r[1].dims.length,4),h=it("b_data",r[2].dataType,r[2].dims.length,4),_=it("c_data",r[0].dataType,r[0].dims.length,4),w,v=(y,d,S)=>`select(${d}, ${y}, ${S})`;if(!i)w=c.setByOffset("global_idx",v(l.getByOffset("global_idx"),h.getByOffset("global_idx"),_.getByOffset("global_idx")));else{let y=(d,S,B="")=>{let j=`a_data[index_a${S}][component_a${S}]`,Y=`b_data[index_b${S}][component_b${S}]`,te=`bool(c_data[index_c${S}] & (0xffu << (component_c${S} * 8)))`;return`
            let output_indices${S} = ${c.offsetToIndices(`global_idx * 4u + ${S}u`)};
            let offset_a${S} = ${l.broadcastedIndicesToOffset(`output_indices${S}`,c)};
            let offset_b${S} = ${h.broadcastedIndicesToOffset(`output_indices${S}`,c)};
            let offset_c${S} = ${_.broadcastedIndicesToOffset(`output_indices${S}`,c)};
            let index_a${S} = offset_a${S} / 4u;
            let index_b${S} = offset_b${S} / 4u;
            let index_c${S} = offset_c${S} / 4u;
            let component_a${S} = offset_a${S} % 4u;
            let component_b${S} = offset_b${S} % 4u;
            let component_c${S} = offset_c${S} % 4u;
            ${d}[${S}] = ${B}(${v(j,Y,te)});
          `};a===9?w=`
            var data = vec4<u32>(0);
            ${y("data",0,"u32")}
            ${y("data",1,"u32")}
            ${y("data",2,"u32")}
            ${y("data",3,"u32")}
            output_data[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:w=`
            ${y("output_data[global_idx]",0)}
            ${y("output_data[global_idx]",1)}
            ${y("output_data[global_idx]",2)}
            ${y("output_data[global_idx]",3)}
          `}return`
        ${e.registerUniform("vec_size","u32").declareVariables(_,l,h,c)}
        ${e.mainStart()}
        ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}
        ${w}
      }`},Qr=e=>{let r=e[1].dims,s=e[2].dims,i=e[0].dims,a=e[1].dataType,c=!(Qe.areEqual(r,s)&&Qe.areEqual(s,i)),l=r,h=Qe.size(r);if(c){let w=Nr.calcShape(Nr.calcShape(r,s,!1),i,!1);if(!w)throw new Error("Can't perform where op on the given tensors");l=w,h=Qe.size(l)}let _=Math.ceil(h/4);return{name:"Where",shaderCache:{inputDependencies:["rank","rank","rank"]},getShaderSource:w=>ds(w,e,l,c,a),getRunData:()=>({outputs:[{dims:l,dataType:a}],dispatchGroup:{x:Math.ceil(h/64/4)},programUniforms:[{type:12,data:_},...Tt(i,r,s,l)]})}},Ds=e=>{e.compute(Qr(e.inputs))}}),aa,qc=E(()=>{bd(),Do(),xl(),zu(),Zo(),Zr(),Yn(),sc(),Nl(),za(),cc(),ja(),fc(),Ua(),hp(),zd(),mp(),Bd(),Wd(),kp(),Gd(),Dd(),Kd(),jd(),Lc(),Ln(),ep(),jc(),$u(),Po(),T(),Ue(),Vt(),sn(),xs(),Ud(),mo(),ka(),cu(),aa=new Map([["Abs",[Bu]],["Acos",[Ea]],["Acosh",[Bo]],["Add",[Fl]],["ArgMax",[Ml,ba]],["ArgMin",[vl,ba]],["Asin",[Tl]],["Asinh",[Ru]],["Atan",[Li]],["Atanh",[ju]],["Attention",[_s]],["AveragePool",[Rc,Qd]],["BatchNormalization",[Du]],["BiasAdd",[zo]],["BiasSplitGelu",[Al]],["Cast",[bl,Nu]],["Ceil",[Wu]],["Clip",[Vu]],["Concat",[yo,ni]],["Conv",[Uo,No]],["ConvTranspose",[Da,di]],["Cos",[_o]],["Cosh",[Pa]],["CumSum",[Ji,ro]],["DepthToSpace",[pi,uc]],["DequantizeLinear",[gi,iu]],["Div",[Fd]],["Einsum",[mn,Ra]],["Elu",[$d,Yo]],["Equal",[Zu]],["Erf",[Di]],["Exp",[Gu]],["Expand",[Vl]],["FastGelu",[ls]],["Floor",[Ku]],["FusedConv",[Uo,No]],["Gather",[Va,Kl]],["GatherElements",[ea,Wa]],["GatherBlockQuantized",[Hl,_c]],["Gelu",[Hu]],["Gemm",[wc,Ql]],["GlobalAveragePool",[ou,Xd]],["GlobalMaxPool",[Ya,Jd]],["Greater",[Wi]],["GreaterOrEqual",[ri]],["GroupQueryAttention",[Jl,Ka]],["HardSigmoid",[ji,Ri]],["InstanceNormalization",[Pc]],["LayerNormalization",[Sc]],["LeakyRelu",[Gr,Yo]],["Less",[Ol]],["LessOrEqual",[Qs]],["Log",[$l]],["MatMul",[Bl]],["MatMulNBits",[Kn,Ic]],["MaxPool",[An,Yd]],["Mul",[Ro]],["MultiHeadAttention",[xc,Mc]],["Neg",[zi]],["Not",[Pl]],["Pad",[nu]],["Pow",[Vi]],["QuickGelu",[Ad,Yo]],["Range",[Ja]],["Reciprocal",[Bi]],["ReduceMin",[wl]],["ReduceMean",[Xo]],["ReduceMax",[Su]],["ReduceSum",[Ai]],["ReduceProd",[Ii]],["ReduceL1",[xd]],["ReduceL2",[Cu]],["ReduceLogSum",[xa]],["ReduceLogSumExp",[Td]],["ReduceSumSquare",[ku]],["Relu",[qu]],["Resize",[bn,Dn]],["RotaryEmbedding",[Tr]],["Sigmoid",[Cl]],["Sin",[Jo]],["Sinh",[Qu]],["Slice",[Ot,Qt]],["SkipLayerNormalization",[$e]],["Split",[un,tn]],["Sqrt",[Xu]],["Softmax",[sr,pr]],["Sub",[ti]],["Tan",[Id]],["Tanh",[Ni]],["ThresholdedRelu",[kl,Yo]],["Tile",[Nd]],["Transpose",[ks,ad]],["Where",[Ds]]])}),zs,Xr=E(()=>{St(),Oe(),or(),zs=class{constructor(e){this.backend=e,this.repo=new Map,this.attributesBound=!1}getArtifact(e){return this.repo.get(e)}setArtifact(e,r){this.repo.set(e,r)}run(e,r,s,i,a){st(e.programInfo.name);let c=this.backend.device,l=this.backend.getComputePassEncoder();this.backend.writeTimestamp(this.backend.pendingDispatchNumber*2);let h=[];for(let w of r)h.push({binding:h.length,resource:{buffer:w.buffer}});for(let w of s)h.push({binding:h.length,resource:{buffer:w.buffer}});a&&h.push({binding:h.length,resource:a});let _=c.createBindGroup({layout:e.computePipeline.getBindGroupLayout(0),entries:h,label:e.programInfo.name});if(this.backend.sessionStatus==="capturing"){let w={kernelId:this.backend.currentKernelId,computePipeline:e.computePipeline,bindGroup:_,dispatchGroup:i};this.backend.capturedCommandList.get(this.backend.currentSessionId).push(w)}l.setPipeline(e.computePipeline),l.setBindGroup(0,_),l.dispatchWorkgroups(...i),this.backend.writeTimestamp(this.backend.pendingDispatchNumber*2+1),this.backend.pendingDispatchNumber++,(this.backend.pendingDispatchNumber>=this.backend.maxDispatchNumber||this.backend.queryType==="at-passes")&&this.backend.endComputePass(),this.backend.pendingDispatchNumber>=this.backend.maxDispatchNumber&&this.backend.flush(),Xe(e.programInfo.name)}dispose(){}build(e,r){st(e.name);let s=this.backend.device,i=[];s.features.has("shader-f16")&&i.push("enable f16;");let a=ll(r,this.backend.device.limits),c=e.getShaderSource(a),l=`${i.join(`
`)}
${a.additionalImplementations}
${c}`,h=s.createShaderModule({code:l,label:e.name});kr("verbose",()=>`[WebGPU] ${e.name} shader code: ${l}`);let _=s.createComputePipeline({compute:{module:h,entryPoint:"main"},layout:"auto",label:e.name});return Xe(e.name),{programInfo:e,computePipeline:_,uniformVariablesInfo:a.variablesInfo}}normalizeDispatchGroupSize(e){let r=typeof e=="number"?e:e.x,s=typeof e=="number"?1:e.y||1,i=typeof e=="number"?1:e.z||1,a=this.backend.device.limits.maxComputeWorkgroupsPerDimension;if(r<=a&&s<=a&&i<=a)return[r,s,i];let c=r*s*i,l=Math.ceil(Math.sqrt(c));if(l>a){if(l=Math.ceil(Math.cbrt(c)),l>a)throw new Error("Total dispatch size exceeds WebGPU maximum.");return[l,l,l]}else return[l,l,1]}}}),cn,Zn,Co,Ts,du=E(()=>{St(),Rt(),Oe(),ne(),ar(),qc(),Xr(),cn=(e,r)=>{if(r.length!==e.length)throw new Error(`inputDependencies length ${r.length} is not equal to inputTensors length ${e.length}.`);let s=[];for(let i=0;i<e.length;++i){let a=e[i].dataType;switch(r[i]){case"none":{s.push("");break}case"type":{s.push(`${a}`);break}case"rank":{let c=e[i].dims.length;s.push(`${a};${c}`);break}case"dims":{let c=e[i].dims.join(",");s.push(`${a};${c}`);break}default:throw new Error(`unsupported input dependency: ${r[i]}`)}}return s.join("|")},Zn=(e,r,s)=>{var a,c;let i=e.name;return(a=e.shaderCache)!=null&&a.hint&&(i+="["+e.shaderCache.hint+"]"),i+=":"+s+`:${cn(r,((c=e.shaderCache)==null?void 0:c.inputDependencies)??new Array(r.length).fill("dims"))}`,i},Co=class{constructor(e){e&&(this.architecture=e.architecture,this.vendor=e.vendor)}isArchitecture(e){return this.architecture===e}isVendor(e){return this.vendor===e}},Ts=class{constructor(){this.currentSessionId=null,this.currentKernelId=null,this.commandEncoder=null,this.computePassEncoder=null,this.maxDispatchNumber=16,this.pendingDispatchNumber=0,this.pendingKernels=[],this.pendingQueries=new Map,this.sessionStatus="default",this.capturedCommandList=new Map,this.capturedPendingKernels=new Map,this.sessionExternalDataMapping=new Map}get currentKernelCustomData(){if(this.currentKernelId===null)throw new Error("currentKernelCustomData(): currentKernelId is null. (should not happen)");let e=this.kernelCustomData.get(this.currentKernelId);return e||(e={},this.kernelCustomData.set(this.currentKernelId,e)),e}async initialize(e,r){this.env=e;let s=[],i={requiredLimits:{maxComputeWorkgroupStorageSize:r.limits.maxComputeWorkgroupStorageSize,maxComputeWorkgroupsPerDimension:r.limits.maxComputeWorkgroupsPerDimension,maxStorageBufferBindingSize:r.limits.maxStorageBufferBindingSize,maxBufferSize:r.limits.maxBufferSize,maxComputeInvocationsPerWorkgroup:r.limits.maxComputeInvocationsPerWorkgroup,maxComputeWorkgroupSizeX:r.limits.maxComputeWorkgroupSizeX,maxComputeWorkgroupSizeY:r.limits.maxComputeWorkgroupSizeY,maxComputeWorkgroupSizeZ:r.limits.maxComputeWorkgroupSizeZ},requiredFeatures:s};r.features.has("chromium-experimental-timestamp-query-inside-passes")?s.push("chromium-experimental-timestamp-query-inside-passes"):r.features.has("timestamp-query")&&s.push("timestamp-query"),r.features.has("shader-f16")&&s.push("shader-f16"),this.device=await r.requestDevice(i),this.adapterInfo=new Co(r.info||await r.requestAdapterInfo()),this.gpuDataManager=xr(this),this.programManager=new zs(this),this.kernels=new Map,this.kernelPersistentData=new Map,this.kernelCustomData=new Map,Ks(e.logLevel,!!e.debug),this.device.onuncapturederror=a=>{a.error instanceof GPUValidationError&&console.error(`An uncaught WebGPU validation error was raised: ${a.error.message}`)},Object.defineProperty(this.env.webgpu,"device",{value:this.device,writable:!1,enumerable:!0,configurable:!1}),Object.defineProperty(this.env.webgpu,"adapter",{value:r,writable:!1,enumerable:!0,configurable:!1}),this.setQueryType()}dispose(){typeof this.querySet<"u"&&this.querySet.destroy(),this.gpuDataManager.dispose()}getCommandEncoder(){return this.commandEncoder||(this.commandEncoder=this.device.createCommandEncoder()),this.commandEncoder}getComputePassEncoder(){if(!this.computePassEncoder){let e=this.getCommandEncoder(),r={};this.queryType==="at-passes"&&(r.timestampWrites={querySet:this.querySet,beginningOfPassWriteIndex:this.pendingDispatchNumber*2,endOfPassWriteIndex:this.pendingDispatchNumber*2+1}),this.computePassEncoder=e.beginComputePass(r)}return this.computePassEncoder}endComputePass(){this.computePassEncoder&&(this.computePassEncoder.end(),this.computePassEncoder=null)}flush(){if(!this.commandEncoder)return;st(),this.endComputePass();let e;this.queryType!=="none"&&(this.commandEncoder.resolveQuerySet(this.querySet,0,this.pendingDispatchNumber*2,this.queryResolveBuffer,0),e=this.device.createBuffer({size:this.pendingDispatchNumber*2*8,usage:GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST}),this.pendingQueries.set(e,this.pendingKernels),this.pendingKernels=[],this.commandEncoder.copyBufferToBuffer(this.queryResolveBuffer,0,e,0,this.pendingDispatchNumber*2*8)),this.device.queue.submit([this.commandEncoder.finish()]),this.gpuDataManager.refreshPendingBuffers(),this.commandEncoder=null,this.pendingDispatchNumber=0,this.queryType!=="none"&&e.mapAsync(GPUMapMode.READ).then(()=>{var i;let r=new BigUint64Array(e.getMappedRange()),s=this.pendingQueries.get(e);for(let a=0;a<r.length/2;a++){let c=s[a],l=c.kernelId,h=this.kernels.get(l),_=h.kernelType,w=h.kernelName,v=c.programName,y=c.inputTensorViews,d=c.outputTensorViews,S=r[a*2],B=r[a*2+1];typeof this.queryTimeBase>"u"&&(this.queryTimeBase=S);let j=Number(S-this.queryTimeBase),Y=Number(B-this.queryTimeBase);if(!Number.isSafeInteger(j)||!Number.isSafeInteger(Y))throw new RangeError("incorrect timestamp range");if((i=this.env.webgpu.profiling)!=null&&i.ondata)this.env.webgpu.profiling.ondata({version:1,inputsMetadata:y.map(te=>({dims:te.dims,dataType:ms(te.dataType)})),outputsMetadata:d.map(te=>({dims:te.dims,dataType:ms(te.dataType)})),kernelId:l,kernelType:_,kernelName:w,programName:v,startTime:j,endTime:Y});else{let te="";y.forEach((ye,ve)=>{te+=`input[${ve}]: [${ye.dims}] | ${ms(ye.dataType)}, `});let J="";d.forEach((ye,ve)=>{J+=`output[${ve}]: [${ye.dims}] | ${ms(ye.dataType)}, `}),console.log(`[profiling] kernel "${l}|${_}|${w}|${v}" ${te}${J}execution time: ${Y-j} ns`)}lt("GPU",`${v}::${S}::${B}`)}e.unmap(),this.pendingQueries.delete(e)}),Xe()}run(e,r,s,i,a,c){st(e.name);let l=[];for(let J=0;J<r.length;++J){let ye=r[J].data;if(ye===0)continue;let ve=this.gpuDataManager.get(ye);if(!ve)throw new Error(`no GPU data for input: ${ye}`);l.push(ve)}let{outputs:h,dispatchGroup:_,programUniforms:w}=e.getRunData(r),v=s.length===0?h.map((J,ye)=>ye):s;if(v.length!==h.length)throw new Error(`Output size ${v.length} must be equal to ${h.length}.`);let y=[],d=[];for(let J=0;J<h.length;++J){if(!Number.isInteger(v[J])||v[J]<-3||v[J]>=c)throw new Error(`Invalid output index: ${v[J]}`);if(v[J]===-3)continue;let ye=v[J]===-1,ve=v[J]===-2,Ce=ye||ve?a(h[J].dataType,h[J].dims):i(v[J],h[J].dataType,h[J].dims);if(y.push(Ce),Ce.data===0)continue;let Ze=this.gpuDataManager.get(Ce.data);if(!Ze)throw new Error(`no GPU data for output: ${Ce.data}`);if(ye&&this.temporaryData.push(Ze),ve){let Ke=this.kernelPersistentData.get(this.currentKernelId);Ke||(Ke=[],this.kernelPersistentData.set(this.currentKernelId,Ke)),Ke.push(Ze)}d.push(Ze)}if(l.length!==r.length||d.length!==y.length){if(d.length===0)return Xe(e.name),y;throw new Error(`Program ${e.name} has zero-sized tensor(s) in inputs or outputs. This is not supported now.`)}let S;if(w){let J=0,ye=[];w.forEach(Ke=>{let ft=typeof Ke.data=="number"?[Ke.data]:Ke.data;if(ft.length===0)return;let It=Ke.type===10?2:4,Bt,cr;Ke.type===10?(cr=ft.length>4?16:ft.length>2?8:ft.length*It,Bt=ft.length>4?16:It*ft.length):(cr=ft.length<=2?ft.length*It:16,Bt=16),J=Math.ceil(J/cr)*cr,ye.push(J);let fr=Ke.type===10?8:4;J+=ft.length>4?Math.ceil(ft.length/fr)*Bt:ft.length*It});let ve=16;J=Math.ceil(J/ve)*ve;let Ce=new ArrayBuffer(J);w.forEach((Ke,ft)=>{let It=ye[ft],Bt=typeof Ke.data=="number"?[Ke.data]:Ke.data;if(Ke.type===6)new Int32Array(Ce,It,Bt.length).set(Bt);else if(Ke.type===12)new Uint32Array(Ce,It,Bt.length).set(Bt);else if(Ke.type===10)new Uint16Array(Ce,It,Bt.length).set(Bt);else if(Ke.type===1)new Float32Array(Ce,It,Bt.length).set(Bt);else throw new Error(`Unsupported uniform type: ${ms(Ke.type)}`)});let Ze=this.gpuDataManager.create(J,GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM);this.device.queue.writeBuffer(Ze.buffer,0,Ce,0,J),this.gpuDataManager.release(Ze.id),S={offset:0,size:J,buffer:Ze.buffer}}let B=this.programManager.normalizeDispatchGroupSize(_),j=B[1]===1&&B[2]===1,Y=Zn(e,r,j),te=this.programManager.getArtifact(Y);if(te||(te=this.programManager.build(e,B),this.programManager.setArtifact(Y,te),kr("info",()=>`[artifact] key: ${Y}, programName: ${e.name}`)),w&&te.uniformVariablesInfo){if(w.length!==te.uniformVariablesInfo.length)throw new Error(`Uniform variables count mismatch: expect ${te.uniformVariablesInfo.length}, got ${w.length} in program "${te.programInfo.name}".`);for(let J=0;J<w.length;J++){let ye=w[J],ve=ye.type,Ce=typeof ye.data=="number"?1:ye.data.length,[Ze,Ke]=te.uniformVariablesInfo[J];if(ve!==Ze||Ce!==Ke)throw new Error(`Uniform variable ${J} mismatch: expect type ${Ze} with size ${Ke}, got type ${ve} with size ${Ce} in program "${te.programInfo.name}".`)}}if(kr("info",()=>`[ProgramManager] run "${e.name}" (key=${Y}) with ${B[0]}x${B[1]}x${B[2]}`),this.queryType!=="none"||this.sessionStatus==="capturing"){let J={kernelId:this.currentKernelId,programName:te.programInfo.name,inputTensorViews:r,outputTensorViews:y};this.pendingKernels.push(J),this.sessionStatus==="capturing"&&this.capturedPendingKernels.get(this.currentSessionId).push(J)}return this.programManager.run(te,l,d,B,S),Xe(e.name),y}upload(e,r){this.gpuDataManager.upload(e,r)}memcpy(e,r){this.gpuDataManager.memcpy(e,r)}async download(e,r){await this.gpuDataManager.download(e,r)}alloc(e){return this.gpuDataManager.create(e).id}free(e){return this.gpuDataManager.release(e)}createKernel(e,r,s,i){let a=aa.get(e);if(!a)throw new Error(`kernel not implemented: ${e}`);let c={kernelType:e,kernelName:i,kernelEntry:a[0],attributes:[a[1],s]};this.kernels.set(r,c)}releaseKernel(e){let r=this.kernelPersistentData.get(e);if(r){for(let s of r)this.gpuDataManager.release(s.id);this.kernelPersistentData.delete(e)}this.kernelCustomData.delete(e),this.kernels.delete(e)}computeKernel(e,r,s){let i=this.kernels.get(e);if(!i)throw new Error(`kernel not created: ${e}`);let a=i.kernelType,c=i.kernelName,l=i.kernelEntry,h=i.attributes;if(this.currentKernelId!==null)throw new Error(`kernel "[${a}] ${c}" is not allowed to be called recursively`);this.currentKernelId=e,h[0]&&(h[1]=h[0](h[1]),h[0]=void 0),kr("info",()=>`[WebGPU] Start to run kernel "[${a}] ${c}"...`);let _=this.env.debug;this.temporaryData=[];try{return _&&this.device.pushErrorScope("validation"),l(r,h[1]),0}catch(w){return s.push(Promise.resolve(`[WebGPU] Kernel "[${a}] ${c}" failed. ${w}`)),1}finally{_&&s.push(this.device.popErrorScope().then(w=>w?`GPU validation error for kernel "[${a}] ${c}": ${w.message}`:null));for(let w of this.temporaryData)this.gpuDataManager.release(w.id);this.temporaryData=[],this.currentKernelId=null}}registerBuffer(e,r,s,i){let a=this.sessionExternalDataMapping.get(e);a||(a=new Map,this.sessionExternalDataMapping.set(e,a));let c=a.get(r),l=this.gpuDataManager.registerExternalBuffer(s,i,c);return a.set(r,[l,s]),l}unregisterBuffers(e){let r=this.sessionExternalDataMapping.get(e);r&&(r.forEach(s=>this.gpuDataManager.unregisterExternalBuffer(s[0])),this.sessionExternalDataMapping.delete(e))}getBuffer(e){let r=this.gpuDataManager.get(e);if(!r)throw new Error(`no GPU data for buffer: ${e}`);return r.buffer}createDownloader(e,r,s){return async()=>{let i=await kt(this,e,r);return I(i.buffer,s)}}writeTimestamp(e){this.queryType==="inside-passes"&&this.computePassEncoder.writeTimestamp(this.querySet,e)}setQueryType(){var e;this.queryType="none",(((e=this.env.webgpu.profiling)==null?void 0:e.mode)==="default"||(typeof this.env.trace>"u"?this.env.wasm.trace:this.env.trace))&&(this.device.features.has("chromium-experimental-timestamp-query-inside-passes")?this.queryType="inside-passes":this.device.features.has("timestamp-query")&&(this.queryType="at-passes"),this.queryType!=="none"&&typeof this.querySet>"u"&&(this.querySet=this.device.createQuerySet({type:"timestamp",count:this.maxDispatchNumber*2}),this.queryResolveBuffer=this.device.createBuffer({size:this.maxDispatchNumber*2*8,usage:GPUBufferUsage.COPY_SRC|GPUBufferUsage.QUERY_RESOLVE})))}captureBegin(){kr("info","captureBegin"),this.capturedCommandList.get(this.currentSessionId)||this.capturedCommandList.set(this.currentSessionId,[]),this.capturedPendingKernels.get(this.currentSessionId)||this.capturedPendingKernels.set(this.currentSessionId,[]),this.flush(),this.sessionStatus="capturing"}captureEnd(){kr("info","captureEnd"),this.flush(),this.sessionStatus="default"}replay(){kr("info","replay"),this.sessionStatus="replaying";let e=this.capturedCommandList.get(this.currentSessionId),r=this.capturedPendingKernels.get(this.currentSessionId),s=e.length;this.pendingKernels=[];for(let i=0;i<s;i++){let a=this.getComputePassEncoder(),c=e[i];this.writeTimestamp(this.pendingDispatchNumber*2),a.setPipeline(c.computePipeline),a.setBindGroup(0,c.bindGroup),a.dispatchWorkgroups(...c.dispatchGroup),this.writeTimestamp(this.pendingDispatchNumber*2+1),this.pendingDispatchNumber++,this.queryType!=="none"&&this.pendingKernels.push(r[i]),(this.pendingDispatchNumber>=this.maxDispatchNumber||this.queryType==="at-passes")&&this.endComputePass(),this.pendingDispatchNumber>=this.maxDispatchNumber&&this.flush()}this.flush(),this.sessionStatus="default"}onReleaseSession(e){this.unregisterBuffers(e),this.capturedCommandList.has(e)&&this.capturedCommandList.delete(e),this.capturedPendingKernels.has(e)&&this.capturedPendingKernels.delete(e),this.gpuDataManager.onReleaseSession(e)}onRunStart(e){this.currentSessionId=e,this.setQueryType()}}}),pu,la,yi,gp,Qc,fu=E(()=>{Oe(),pu=1,la=()=>pu++,yi=class{constructor(e,r){this.mlContext=e,this.tensorEntry=r,this.tensorCache=r?[r]:[]}get tensor(){var e;return(e=this.tensorEntry)==null?void 0:e[0]}get context(){if(!this.mlContext)throw new Error("MLContext has not been set.");return this.mlContext}set context(e){if(this.mlContext&&this.mlContext!==e)throw new Error("MLTensor in use in a different MLContext.");this.mlContext=e}destroy(){for(let[e]of this.tensorCache)e.destroy();this.tensorCache=[],this.tensorEntry=void 0}trySelectTensor(e,r){for(let[s,i,a]of this.tensorCache)if(r===s){if(this.context!==e)throw new Error("MLTensor cannot be registered with a different MLContext.");return this.tensorEntry=[s,i,a],!0}return!1}async ensureTensor(e,r,s){var c;if(this.tensorEntry){let[l,h,_]=this.tensorEntry;if(h===e&&_.every((w,v)=>w===r[v]))return l}for(let[l,h,_]of this.tensorCache)if(h===e&&_.every((w,v)=>w===r[v])){if(s&&this.tensorEntry){kr("verbose",()=>`[WebNN] Slowdown may occur, having to copy existing tensor {dataType: ${e}, shape: ${r}}`);let w=await this.context.readTensor(this.tensorEntry[0]);this.context.writeTensor(l,w)}return this.tensorEntry=[l,h,_],l}kr("verbose",()=>`[WebNN] MLContext.createTensor {dataType: ${e}, shape: ${r}}`);let i=MLTensorUsage.READ|MLTensorUsage.WRITE,a=await this.context.createTensor({dataType:e,shape:r,dimensions:r,usage:i});return this.tensorEntry=[a,e,r],this.tensorCache.push(this.tensorEntry),this.activeUpload&&((c=this.mlContext)==null||c.writeTensor(a,this.activeUpload),this.activeUpload=void 0),a}upload(e){var r;if(!this.tensorEntry){this.activeUpload=new Uint8Array(e);return}(r=this.mlContext)==null||r.writeTensor(this.tensorEntry[0],e)}async download(e){if(this.activeUpload)if(e){e instanceof ArrayBuffer?new Uint8Array(e).set(this.activeUpload):new Uint8Array(e.buffer,e.byteOffset,e.byteLength).set(this.activeUpload);return}else return this.activeUpload.buffer;if(!this.tensorEntry)throw new Error("Tensor has not been created.");return e?this.context.readTensor(this.tensorEntry[0],e):this.context.readTensor(this.tensorEntry[0])}},gp=class{constructor(e){this.backend=e,this.tensorsById=new Map,this.tensorIdsByContext=new Map}reserveTensorId(){let e=la();return this.tensorsById.set(e,new yi),e}releaseTensorId(e){let r=this.tensorsById.get(e);if(r){r.destroy(),this.tensorsById.delete(e);for(let[s,i]of this.tensorIdsByContext)if(i.has(e)){i.delete(e),i.size===0&&this.tensorIdsByContext.delete(s);break}}}async ensureTensor(e,r,s,i){var c;kr("verbose",()=>`[WebNN] TensorManager.ensureTensor {tensorId: ${e}, dataType: ${r}, shape: ${s}, copyOld: ${i}}`);let a=this.tensorsById.get(e);if(!a)throw new Error("Tensor not found.");return a.context=this.backend.currentContext,this.tensorIdsByContext.has(this.backend.currentContext)||this.tensorIdsByContext.set(this.backend.currentContext,new Set),(c=this.tensorIdsByContext.get(this.backend.currentContext))==null||c.add(e),a.ensureTensor(r,s,i)}upload(e,r){this.tensorsById.get(e).upload(r)}async download(e,r){return kr("verbose",()=>`[WebNN] TensorManager.download {tensorId: ${e}, dstBuffer: ${r==null?void 0:r.byteLength}}`),this.tensorsById.get(e).download(r)}releaseTensorsForContext(e){let r=this.tensorIdsByContext.get(e);if(r){for(let s of r)this.tensorsById.get(s).destroy(),this.tensorsById.delete(s);this.tensorIdsByContext.delete(e)}}registerTensor(e,r,s,i){for(let[l,h]of this.tensorsById)if(h.trySelectTensor(e,r))return l;let a=la();this.tensorsById.set(a,new yi(e,[r,s,i]));let c=this.tensorIdsByContext.get(e);return c||(c=new Set,this.tensorIdsByContext.set(e,c)),c.add(a),a}},Qc=(...e)=>new gp(...e)}),Za,Ho,rp=E(()=>{Rt(),rs(),ne(),fu(),Oe(),Za=new Map([[1,"float32"],[10,"float16"],[6,"int32"],[12,"uint32"],[7,"int64"],[13,"uint64"],[3,"int8"],[2,"uint8"],[9,"uint8"]]),Ho=class{constructor(e){this.tensorManager=Qc(this),this.mlContextBySessionId=new Map,this.sessionIdsByMLContext=new Map,Ks(e.logLevel,!!e.debug)}get currentSessionId(){if(this.activeSessionId===void 0)throw new Error("No active session");return this.activeSessionId}onRunStart(e){this.activeSessionId=e}get currentContext(){let e=this.getMLContext(this.currentSessionId);if(!e)throw new Error(`No MLContext found for session ${this.currentSessionId}`);return e}registerMLContext(e,r){this.mlContextBySessionId.set(e,r);let s=this.sessionIdsByMLContext.get(r);s||(s=new Set,this.sessionIdsByMLContext.set(r,s)),s.add(e)}onReleaseSession(e){let r=this.mlContextBySessionId.get(e);if(!r)return;this.mlContextBySessionId.delete(e);let s=this.sessionIdsByMLContext.get(r);s.delete(e),s.size===0&&(this.sessionIdsByMLContext.delete(r),this.tensorManager.releaseTensorsForContext(r))}getMLContext(e){return this.mlContextBySessionId.get(e)}reserveTensorId(){return this.tensorManager.reserveTensorId()}releaseTensorId(e){kr("verbose",()=>`[WebNN] releaseTensorId {tensorId: ${e}}`),this.tensorManager.releaseTensorId(e)}async ensureTensor(e,r,s,i){let a=Za.get(r);if(!a)throw new Error(`Unsupported ONNX data type: ${r}`);return this.tensorManager.ensureTensor(e,a,s,i)}uploadTensor(e,r){if(!Dr().shouldTransferToMLTensor)throw new Error("Trying to upload to a MLTensor while shouldTransferToMLTensor is false");kr("verbose",()=>`[WebNN] uploadTensor {tensorId: ${e}, data: ${r.byteLength}}`),this.tensorManager.upload(e,r)}async downloadTensor(e,r){return this.tensorManager.download(e,r)}createMLTensorDownloader(e,r){return async()=>{let s=await this.tensorManager.download(e);return I(s,r)}}registerMLTensor(e,r,s){let i=Za.get(r);if(!i)throw new Error(`Unsupported ONNX data type: ${r}`);let a=this.tensorManager.registerTensor(this.currentContext,e,i,s);return kr("verbose",()=>`[WebNN] registerMLTensor {tensor: ${e}, dataType: ${i}, dimensions: ${s}} -> {tensorId: ${a}}`),a}flush(){}}}),So={};C(So,{init:()=>yp});var hu,dn,yp,wi=E(()=>{Rt(),du(),Oe(),qt(),rp(),hu=class xm{constructor(r,s,i,a){this.module=r,this.dataType=s,this.data=i,this.dims=a}getFloat32Array(){if(this.dataType!==1)throw new Error("Invalid data type");let r=Qe.size(this.dims);return r===0?new Float32Array:new Float32Array(this.module.HEAP8.buffer,this.data,r)}getBigInt64Array(){if(this.dataType!==7)throw new Error("Invalid data type");let r=Qe.size(this.dims);return r===0?new BigInt64Array:new BigInt64Array(this.module.HEAP8.buffer,this.data,r)}getInt32Array(){if(this.dataType!==6)throw new Error("Invalid data type");let r=Qe.size(this.dims);return r===0?new Int32Array:new Int32Array(this.module.HEAP8.buffer,this.data,r)}getUint16Array(){if(this.dataType!==10&&this.dataType!==4)throw new Error("Invalid data type");let r=Qe.size(this.dims);return r===0?new Uint16Array:new Uint16Array(this.module.HEAP8.buffer,this.data,r)}reshape(r){if(Qe.size(r)!==Qe.size(this.dims))throw new Error("Invalid new shape");return new xm(this.module,this.dataType,this.data,r)}},dn=class{constructor(e,r,s){this.module=e,this.backend=r,this.customDataOffset=0,this.customDataSize=0,this.adapterInfo=r.adapterInfo;let i=e.HEAPU32,a=s>>>2;this.opKernelContext=i[a++];let c=i[a++];this.outputCount=i[a++],this.customDataOffset=i[a++],this.customDataSize=i[a++];let l=[];for(let h=0;h<c;h++){let _=i[a++],w=i[a++],v=i[a++],y=[];for(let d=0;d<v;d++)y.push(i[a++]);l.push(new hu(e,_,w,y))}this.inputs=l}get kernelCustomData(){return this.backend.currentKernelCustomData}get customDataBuffer(){return this.module.HEAPU8.subarray(this.customDataOffset,this.customDataOffset+this.customDataSize)}getMaxComputeWorkgroupSizes(){return[this.backend.device.limits.maxComputeWorkgroupSizeX,this.backend.device.limits.maxComputeWorkgroupSizeY,this.backend.device.limits.maxComputeWorkgroupSizeZ]}getMaxComputeWorkgroupStoragesize(){return this.backend.device.limits.maxComputeWorkgroupStorageSize}compute(e,r){var l;let s=((l=r==null?void 0:r.inputs)==null?void 0:l.map(h=>typeof h=="number"?this.inputs[h]:h))??this.inputs,i=(r==null?void 0:r.outputs)??[],a=(h,_,w)=>new hu(this.module,_,this.output(h,w),w),c=(h,_)=>{let w=Rn(h,_);if(!w)throw new Error(`Unsupported data type: ${h}`);let v=w>0?this.backend.gpuDataManager.create(w).id:0;return new hu(this.module,h,v,_)};return this.backend.run(e,s,i,a,c,this.outputCount)}output(e,r){let s=this.module.stackSave();try{let i=this.module.stackAlloc((1+r.length)*4),a=i>>2;this.module.HEAPU32[a++]=r.length;for(let c=0;c<r.length;c++)this.module.HEAPU32[a++]=r[c];return this.module._JsepOutput(this.opKernelContext,e,i)}catch(i){throw new Error(`Failed to generate kernel's output[${e}] with dims [${r}]. If you are running with pre-allocated output, please make sure the output type/dims are correct. Error: ${i}`)}finally{this.module.stackRestore(s)}}},yp=async(e,r,s,i)=>{let a=r.jsepInit;if(!a)throw new Error("Failed to initialize JSEP. The WebAssembly module is not built with JSEP support.");if(e==="webgpu"){let c=new Ts;await c.initialize(s,i),a("webgpu",[c,l=>c.alloc(l),l=>c.free(l),(l,h,_,w=!1)=>{if(w)kr("verbose",()=>`[WebGPU] jsepCopyGpuToGpu: src=${l}, dst=${h}, size=${_}`),c.memcpy(l,h);else{kr("verbose",()=>`[WebGPU] jsepCopyCpuToGpu: dataOffset=${l}, gpuDataId=${h}, size=${_}`);let v=r.HEAPU8.subarray(l>>>0,(l>>>0)+_);c.upload(h,v)}},async(l,h,_)=>{kr("verbose",()=>`[WebGPU] jsepCopyGpuToCpu: gpuDataId=${l}, dataOffset=${h}, size=${_}`),await c.download(l,()=>r.HEAPU8.subarray(h>>>0,(h>>>0)+_))},(l,h,_)=>c.createKernel(l,h,_,r.UTF8ToString(r._JsepGetNodeName(h))),l=>c.releaseKernel(l),(l,h,_,w)=>{kr("verbose",()=>`[WebGPU] jsepRun: sessionHandle=${_}, kernel=${l}, contextDataOffset=${h}`);let v=new dn(r,c,h);return c.computeKernel(l,v,w)},()=>c.captureBegin(),()=>c.captureEnd(),()=>c.replay()])}else{let c=new Ho(s);a("webnn",[c,()=>c.reserveTensorId(),l=>c.releaseTensorId(l),async(l,h,_,w)=>c.ensureTensor(l,h,_,w),(l,h)=>{c.uploadTensor(l,h)},async(l,h)=>c.downloadTensor(l,h)])}}}),Bs,$p,wp,ua,Rp,bs,np,Ip,vi,Xc,ca,Yc,vp=E(()=>{ha(),il(),Rt(),rs(),lo(),_a(),Bs=(e,r)=>{Dr()._OrtInit(e,r)!==0&&Sr("Can't initialize onnxruntime.")},$p=async e=>{Bs(e.wasm.numThreads,Ao(e.logLevel))},wp=async(e,r)=>{{let s=(wi(),A(So)).init;if(r==="webgpu"){if(typeof navigator>"u"||!navigator.gpu)throw new Error("WebGPU is not supported in current environment");let i=e.webgpu.adapter;if(i){if(typeof i.limits!="object"||typeof i.features!="object"||typeof i.requestDevice!="function")throw new Error("Invalid GPU adapter set in `env.webgpu.adapter`. It must be a GPUAdapter object.")}else{let a=e.webgpu.powerPreference;if(a!==void 0&&a!=="low-power"&&a!=="high-performance")throw new Error(`Invalid powerPreference setting: "${a}"`);let c=e.webgpu.forceFallbackAdapter;if(c!==void 0&&typeof c!="boolean")throw new Error(`Invalid forceFallbackAdapter setting: "${c}"`);if(i=await navigator.gpu.requestAdapter({powerPreference:a,forceFallbackAdapter:c}),!i)throw new Error('Failed to get GPU adapter. You may need to enable flag "--enable-unsafe-webgpu" if you are using Chrome.')}await s("webgpu",Dr(),e,i)}if(r==="webnn"){if(typeof navigator>"u"||!navigator.ml)throw new Error("WebNN is not supported in current environment");await s("webnn",Dr(),e)}}},ua=new Map,Rp=e=>{let r=Dr(),s=r.stackSave();try{let i=r.stackAlloc(8);return r._OrtGetInputOutputCount(e,i,i+4)!==0&&Sr("Can't get session input/output count."),[r.HEAP32[i/4],r.HEAP32[i/4+1]]}finally{r.stackRestore(s)}},bs=e=>{let r=Dr(),s=r._malloc(e.byteLength);if(s===0)throw new Error(`Can't create a session. failed to allocate a buffer of size ${e.byteLength}.`);return r.HEAPU8.set(e,s),[s,e.byteLength]},np=async(e,r)=>{var y,d;let s,i,a=Dr();Array.isArray(e)?[s,i]=e:e.buffer===a.HEAPU8.buffer?[s,i]=[e.byteOffset,e.byteLength]:[s,i]=bs(e);let c=0,l=0,h=0,_=[],w=[],v=[];try{if([l,_]=Yr(r),(r==null?void 0:r.externalData)&&a.mountExternalData){let ve=[];for(let Ce of r.externalData){let Ze=typeof Ce=="string"?Ce:Ce.path;ve.push(ki(typeof Ce=="string"?Ce:Ce.data).then(Ke=>{a.mountExternalData(Ze,Ke)}))}await Promise.all(ve)}for(let ve of(r==null?void 0:r.executionProviders)??[])if((typeof ve=="string"?ve:ve.name)==="webnn"){if(a.shouldTransferToMLTensor=!1,a.currentContext)throw new Error("WebNN execution provider is already set.");if(typeof ve!="string"){let Ce=ve,Ze=Ce==null?void 0:Ce.context,Ke=Ce==null?void 0:Ce.gpuDevice,ft=Ce==null?void 0:Ce.deviceType,It=Ce==null?void 0:Ce.numThreads,Bt=Ce==null?void 0:Ce.powerPreference;Ze?a.currentContext=Ze:Ke?a.currentContext=await navigator.ml.createContext(Ke):a.currentContext=await navigator.ml.createContext({deviceType:ft,numThreads:It,powerPreference:Bt})}else a.currentContext=await navigator.ml.createContext();break}c=await a._OrtCreateSession(s,i,l),c===0&&Sr("Can't create a session."),a.currentContext&&(a.jsepRegisterMLContext(c,a.currentContext),a.currentContext=void 0,a.shouldTransferToMLTensor=!0);let[S,B]=Rp(c),j=!!(r!=null&&r.enableGraphCapture),Y=[],te=[],J=[];for(let ve=0;ve<S;ve++){let Ce=a._OrtGetInputName(c,ve);Ce===0&&Sr("Can't get an input name."),w.push(Ce),Y.push(a.UTF8ToString(Ce))}for(let ve=0;ve<B;ve++){let Ce=a._OrtGetOutputName(c,ve);Ce===0&&Sr("Can't get an output name."),v.push(Ce);let Ze=a.UTF8ToString(Ce);te.push(Ze);{if(j&&(r==null?void 0:r.preferredOutputLocation)===void 0){J.push("gpu-buffer");continue}let Ke=typeof(r==null?void 0:r.preferredOutputLocation)=="string"?r.preferredOutputLocation:((y=r==null?void 0:r.preferredOutputLocation)==null?void 0:y[Ze])??"cpu";if(Ke!=="cpu"&&Ke!=="cpu-pinned"&&Ke!=="gpu-buffer"&&Ke!=="ml-tensor")throw new Error(`Not supported preferred output location: ${Ke}.`);if(j&&Ke!=="gpu-buffer")throw new Error(`Not supported preferred output location: ${Ke}. Only 'gpu-buffer' location is supported when enableGraphCapture is true.`);J.push(Ke)}}let ye=null;return J.some(ve=>ve==="gpu-buffer"||ve==="ml-tensor")&&(h=a._OrtCreateBinding(c),h===0&&Sr("Can't create IO binding."),ye={handle:h,outputPreferredLocations:J,outputPreferredLocationsEncoded:J.map(ve=>po(ve))}),ua.set(c,[c,w,v,ye,j,!1]),[c,Y,te]}catch(S){throw w.forEach(B=>a._OrtFree(B)),v.forEach(B=>a._OrtFree(B)),h!==0&&a._OrtReleaseBinding(h),c!==0&&a._OrtReleaseSession(c),S}finally{a._free(s),l!==0&&a._OrtReleaseSessionOptions(l),_.forEach(S=>a._free(S)),(d=a.unmountExternalData)==null||d.call(a)}},Ip=e=>{var _;let r=Dr(),s=ua.get(e);if(!s)throw new Error(`cannot release session. invalid session id: ${e}`);let[i,a,c,l,h]=s;l&&(h&&r._OrtClearBoundOutputs(l.handle),r._OrtReleaseBinding(l.handle)),(_=r.jsepOnReleaseSession)==null||_.call(r,e),a.forEach(w=>r._OrtFree(w)),c.forEach(w=>r._OrtFree(w)),r._OrtReleaseSession(i),ua.delete(e)},vi=(e,r,s,i,a,c=!1)=>{if(!e){r.push(0);return}let l=Dr(),h=e[0],_=e[1],w=e[3],v,y;if(h==="string"&&(w==="gpu-buffer"||w==="ml-tensor"))throw new Error("String tensor is not supported on GPU.");if(c&&w!=="gpu-buffer")throw new Error(`External buffer must be provided for input/output index ${a} when enableGraphCapture is true.`);if(w==="gpu-buffer"){let B=e[2].gpuBuffer;y=Rn(Gs(h),_);let j=l.jsepRegisterBuffer;if(!j)throw new Error('Tensor location "gpu-buffer" is not supported without using WebGPU.');v=j(i,a,B,y)}else if(w==="ml-tensor"){let B=e[2].mlTensor;y=Rn(Gs(h),_);let j=l.jsepRegisterMLTensor;if(!j)throw new Error('Tensor location "ml-tensor" is not supported without using WebNN.');v=j(B,Gs(h),_)}else{let B=e[2];if(Array.isArray(B)){y=4*B.length,v=l._malloc(y),s.push(v);let j=v/4;for(let Y=0;Y<B.length;Y++){if(typeof B[Y]!="string")throw new TypeError(`tensor data at index ${Y} is not a string`);l.HEAPU32[j++]=zr(B[Y],s)}}else y=B.byteLength,v=l._malloc(y),s.push(v),l.HEAPU8.set(new Uint8Array(B.buffer,B.byteOffset,y),v)}let d=l.stackSave(),S=l.stackAlloc(4*_.length);try{let B=S/4;_.forEach(Y=>l.HEAP32[B++]=Y);let j=l._OrtCreateTensor(Gs(h),v,y,S,_.length,po(w));j===0&&Sr(`Can't create tensor for input/output. session=${i}, index=${a}.`),r.push(j)}finally{l.stackRestore(d)}},Xc=async(e,r,s,i,a,c)=>{var Bt,cr;let l=Dr(),h=ua.get(e);if(!h)throw new Error(`cannot run inference. invalid session id: ${e}`);let _=h[0],w=h[1],v=h[2],y=h[3],d=h[4],S=h[5],B=r.length,j=i.length,Y=0,te=[],J=[],ye=[],ve=[],Ce=l.stackSave(),Ze=l.stackAlloc(B*4),Ke=l.stackAlloc(B*4),ft=l.stackAlloc(j*4),It=l.stackAlloc(j*4);try{(Bt=l.jsepOnRunStart)==null||Bt.call(l,_),[Y,te]=Ei(c);for(let Wt=0;Wt<B;Wt++)vi(s[Wt],J,ve,e,r[Wt],d);for(let Wt=0;Wt<j;Wt++)vi(a[Wt],ye,ve,e,B+i[Wt],d);let fr=Ze/4,Xt=Ke/4,Rr=ft/4,on=It/4;for(let Wt=0;Wt<B;Wt++)l.HEAPU32[fr++]=J[Wt],l.HEAPU32[Xt++]=w[r[Wt]];for(let Wt=0;Wt<j;Wt++)l.HEAPU32[Rr++]=ye[Wt],l.HEAPU32[on++]=v[i[Wt]];if(y&&!S){let{handle:Wt,outputPreferredLocations:tr,outputPreferredLocationsEncoded:Ir}=y;if(w.length!==B)throw new Error(`input count from feeds (${B}) is expected to be always equal to model's input count (${w.length}).`);for(let et=0;et<B;et++){let xt=r[et];await l._OrtBindInput(Wt,w[xt],J[et])!==0&&Sr(`Can't bind input[${et}] for session=${e}.`)}for(let et=0;et<j;et++){let xt=i[et];(cr=a[et])!=null&&cr[3]?l._OrtBindOutput(Wt,v[xt],ye[et],0)!==0&&Sr(`Can't bind pre-allocated output[${et}] for session=${e}.`):l._OrtBindOutput(Wt,v[xt],0,Ir[xt])!==0&&Sr(`Can't bind output[${et}] to ${tr[et]} for session=${e}.`)}ua.set(e,[_,w,v,y,d,!0])}let yr;y?yr=await l._OrtRunWithBinding(_,y.handle,j,ft,Y):yr=await l._OrtRun(_,Ke,Ze,B,It,j,ft,Y),yr!==0&&Sr("failed to call OrtRun().");let Vr=[];for(let Wt=0;Wt<j;Wt++){let tr=l.HEAPU32[ft/4+Wt];if(tr===ye[Wt]){Vr.push(a[Wt]);continue}let Ir=l.stackSave(),et=l.stackAlloc(4*4),xt=!1,rr,jr=0;try{l._OrtGetTensorData(tr,et,et+4,et+8,et+12)!==0&&Sr(`Can't access output tensor data on index ${Wt}.`);let Fn=et/4,zn=l.HEAPU32[Fn++];jr=l.HEAPU32[Fn++];let td=l.HEAPU32[Fn++],Vp=l.HEAPU32[Fn++],no=[];for(let Hn=0;Hn<Vp;Hn++)no.push(l.HEAPU32[td/4+Hn]);l._OrtFree(td);let es=no.reduce((Hn,Es)=>Hn*Es,1);rr=ms(zn);let up=y==null?void 0:y.outputPreferredLocations[i[Wt]];if(rr==="string"){if(up==="gpu-buffer"||up==="ml-tensor")throw new Error("String tensor is not supported on GPU.");let Hn=[],Es=jr/4;for(let xi=0;xi<es;xi++){let rd=l.HEAPU32[Es++],Wp=xi===es-1?void 0:l.HEAPU32[Es]-rd;Hn.push(l.UTF8ToString(rd,Wp))}Vr.push([rr,no,Hn,"cpu"])}else if(up==="gpu-buffer"&&es>0){let Hn=l.jsepGetBuffer;if(!Hn)throw new Error('preferredLocation "gpu-buffer" is not supported without using WebGPU.');let Es=Hn(jr),xi=Rn(zn,es);if(xi===void 0||!co(rr))throw new Error(`Unsupported data type: ${rr}`);xt=!0,Vr.push([rr,no,{gpuBuffer:Es,download:l.jsepCreateDownloader(Es,xi,rr),dispose:()=>{l._OrtReleaseTensor(tr)}},"gpu-buffer"])}else if(up==="ml-tensor"&&es>0){let Hn=l.jsepEnsureTensor;if(!Hn)throw new Error('preferredLocation "ml-tensor" is not supported without using WebNN.');if(Rn(zn,es)===void 0||!jn(rr))throw new Error(`Unsupported data type: ${rr}`);let Es=await Hn(jr,zn,no,!1);xt=!0,Vr.push([rr,no,{mlTensor:Es,download:l.jsepCreateMLTensorDownloader(jr,rr),dispose:()=>{l.jsepReleaseTensorId(jr),l._OrtReleaseTensor(tr)}},"ml-tensor"])}else{let Hn=Si(rr),Es=new Hn(es);new Uint8Array(Es.buffer,Es.byteOffset,Es.byteLength).set(l.HEAPU8.subarray(jr,jr+Es.byteLength)),Vr.push([rr,no,Es,"cpu"])}}finally{l.stackRestore(Ir),rr==="string"&&jr&&l._free(jr),xt||l._OrtReleaseTensor(tr)}}return y&&!d&&(l._OrtClearBoundOutputs(y.handle),ua.set(e,[_,w,v,y,d,!1])),Vr}finally{l.stackRestore(Ce),J.forEach(fr=>l._OrtReleaseTensor(fr)),ye.forEach(fr=>l._OrtReleaseTensor(fr)),ve.forEach(fr=>l._free(fr)),Y!==0&&l._OrtReleaseRunOptions(Y),te.forEach(fr=>l._free(fr))}},ca=e=>{let r=Dr(),s=ua.get(e);if(!s)throw new Error("invalid session id");let i=s[0],a=r._OrtEndProfiling(i);a===0&&Sr("Can't get an profile file name."),r._OrtFree(a)},Yc=e=>{let r=[];for(let s of e){let i=s[2];!Array.isArray(i)&&"buffer"in i&&r.push(i.buffer)}return r}}),Mi,Rs,el,sp,Jc,op,Zc,mu,tl,da,jp,Ap,Mp,ip,xp,ap,Fp,Np,lp=E(()=>{St(),vp(),rs(),Cs(),Mi=()=>!!L.wasm.proxy&&typeof document<"u",el=!1,sp=!1,Jc=!1,mu=new Map,tl=(e,r)=>{let s=mu.get(e);s?s.push(r):mu.set(e,[r])},da=()=>{if(el||!sp||Jc||!Rs)throw new Error("worker not ready")},jp=e=>{switch(e.data.type){case"init-wasm":el=!1,e.data.err?(Jc=!0,Zc[1](e.data.err)):(sp=!0,Zc[0]()),op&&(URL.revokeObjectURL(op),op=void 0);break;case"init-ep":case"copy-from":case"create":case"release":case"run":case"end-profiling":{let r=mu.get(e.data.type);e.data.err?r.shift()[1](e.data.err):r.shift()[0](e.data.out);break}}},Ap=async()=>{if(!sp){if(el)throw new Error("multiple calls to 'initWasm()' detected.");if(Jc)throw new Error("previous call to 'initWasm()' failed.");if(el=!0,Mi())return new Promise((e,r)=>{Rs==null||Rs.terminate(),oo().then(([s,i])=>{try{Rs=i,Rs.onerror=c=>r(c),Rs.onmessage=jp,Zc=[e,r];let a={type:"init-wasm",in:L};Rs.postMessage(a),op=s}catch(a){r(a)}},r)});try{await ao(L.wasm),await $p(L),sp=!0}catch(e){throw Jc=!0,e}finally{el=!1}}},Mp=async e=>{if(Mi())return da(),new Promise((r,s)=>{tl("init-ep",[r,s]);let i={type:"init-ep",in:{epName:e,env:L}};Rs.postMessage(i)});await wp(L,e)},ip=async e=>Mi()?(da(),new Promise((r,s)=>{tl("copy-from",[r,s]);let i={type:"copy-from",in:{buffer:e}};Rs.postMessage(i,[e.buffer])})):bs(e),xp=async(e,r)=>{if(Mi()){if(r!=null&&r.preferredOutputLocation)throw new Error('session option "preferredOutputLocation" is not supported for proxy.');return da(),new Promise((s,i)=>{tl("create",[s,i]);let a={type:"create",in:{model:e,options:{...r}}},c=[];e instanceof Uint8Array&&c.push(e.buffer),Rs.postMessage(a,c)})}else return np(e,r)},ap=async e=>{if(Mi())return da(),new Promise((r,s)=>{tl("release",[r,s]);let i={type:"release",in:e};Rs.postMessage(i)});Ip(e)},Fp=async(e,r,s,i,a,c)=>{if(Mi()){if(s.some(l=>l[3]!=="cpu"))throw new Error("input tensor on GPU is not supported for proxy.");if(a.some(l=>l))throw new Error("pre-allocated output tensor is not supported for proxy.");return da(),new Promise((l,h)=>{tl("run",[l,h]);let _=s,w={type:"run",in:{sessionId:e,inputIndices:r,inputs:_,outputIndices:i,options:c}};Rs.postMessage(w,Yc(_))})}else return Xc(e,r,s,i,a,c)},Np=async e=>{if(Mi())return da(),new Promise((r,s)=>{tl("end-profiling",[r,s]);let i={type:"end-profiling",in:e};Rs.postMessage(i)});ca(e)}}),Op,ed,Up,Tp=E(()=>{St(),lp(),Rt(),Ft(),_a(),Op=(e,r)=>{switch(e.location){case"cpu":return[e.type,e.dims,e.data,"cpu"];case"gpu-buffer":return[e.type,e.dims,{gpuBuffer:e.gpuBuffer},"gpu-buffer"];case"ml-tensor":return[e.type,e.dims,{mlTensor:e.mlTensor},"ml-tensor"];default:throw new Error(`invalid data location: ${e.location} for ${r()}`)}},ed=e=>{switch(e[3]){case"cpu":return new be(e[0],e[2],e[1]);case"gpu-buffer":{let r=e[0];if(!co(r))throw new Error(`not supported data type: ${r} for deserializing GPU tensor`);let{gpuBuffer:s,download:i,dispose:a}=e[2];return be.fromGpuBuffer(s,{dataType:r,dims:e[1],download:i,dispose:a})}case"ml-tensor":{let r=e[0];if(!jn(r))throw new Error(`not supported data type: ${r} for deserializing MLTensor tensor`);let{mlTensor:s,download:i,dispose:a}=e[2];return be.fromMLTensor(s,{dataType:r,dims:e[1],download:i,dispose:a})}default:throw new Error(`invalid data location: ${e[3]}`)}},Up=class{async fetchModelAndCopyToWasmMemory(e){return ip(await ki(e))}async loadModel(e,r){st();let s;typeof e=="string"?s=await this.fetchModelAndCopyToWasmMemory(e):s=e,[this.sessionId,this.inputNames,this.outputNames]=await xp(s,r),Xe()}async dispose(){return ap(this.sessionId)}async run(e,r,s){st();let i=[],a=[];Object.entries(e).forEach(y=>{let d=y[0],S=y[1],B=this.inputNames.indexOf(d);if(B===-1)throw new Error(`invalid input '${d}'`);i.push(S),a.push(B)});let c=[],l=[];Object.entries(r).forEach(y=>{let d=y[0],S=y[1],B=this.outputNames.indexOf(d);if(B===-1)throw new Error(`invalid output '${d}'`);c.push(S),l.push(B)});let h=i.map((y,d)=>Op(y,()=>`input "${this.inputNames[a[d]]}"`)),_=c.map((y,d)=>y?Op(y,()=>`output "${this.outputNames[l[d]]}"`):null),w=await Fp(this.sessionId,a,h,l,_,s),v={};for(let y=0;y<w.length;y++)v[this.outputNames[l[y]]]=c[y]??ed(w[y]);return Xe(),v}startProfiling(){}endProfiling(){Np(this.sessionId)}}}),t={};C(t,{OnnxruntimeWebAssemblyBackend:()=>o,initializeFlags:()=>n,wasmBackend:()=>u});var n,o,u,m=E(()=>{St(),lp(),Tp(),Cs(),n=()=>{if((typeof L.wasm.initTimeout!="number"||L.wasm.initTimeout<0)&&(L.wasm.initTimeout=0),L.wasm.simd===!1&&console.warn('Deprecated property "env.wasm.simd" is set to false. non-SIMD build is no longer provided, and this setting will be ignored.'),typeof L.wasm.proxy!="boolean"&&(L.wasm.proxy=!1),typeof L.wasm.trace!="boolean"&&(L.wasm.trace=!1),typeof L.wasm.numThreads!="number"||!Number.isInteger(L.wasm.numThreads)||L.wasm.numThreads<=0)if(typeof self<"u"&&!self.crossOriginIsolated)L.wasm.numThreads=1;else{let e=typeof navigator>"u"?oe("node:os").cpus().length:navigator.hardwareConcurrency;L.wasm.numThreads=Math.min(4,Math.ceil((e||1)/2))}},o=class{async init(e){n(),await Ap(),await Mp(e)}async createInferenceSessionHandler(e,r){let s=new Up;return await s.loadModel(e,r),Promise.resolve(s)}},u=new o});St(),St(),St();var M="1.20.1",K=$t;{let e=(m(),A(t)).wasmBackend;fe("webgpu",e,5),fe("webnn",e,5),fe("cpu",e,10),fe("wasm",e,10)}Object.defineProperty(L.versions,"web",{value:M,enumerable:!0});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */},"./src/backends/onnx.js":(ke,V,f)=>{var P;f.r(V),f.d(V,{Tensor:()=>oe.Tensor,createInferenceSession:()=>le,deviceToExecutionProviders:()=>fe,isONNXProxy:()=>pe,isONNXTensor:()=>q});var R=f("./src/env.js"),Q=f("?2ce3"),se=f("./node_modules/onnxruntime-web/dist/ort.webgpu.bundle.min.mjs"),oe=f("./node_modules/onnxruntime-common/dist/esm/index.js");const E=Object.freeze({auto:null,gpu:null,cpu:"cpu",wasm:"wasm",webgpu:"webgpu",cuda:"cuda",dml:"dml",webnn:{name:"webnn",deviceType:"cpu"},"webnn-npu":{name:"webnn",deviceType:"npu"},"webnn-gpu":{name:"webnn",deviceType:"gpu"},"webnn-cpu":{name:"webnn",deviceType:"cpu"}}),C=[];let k,A;const $=Symbol.for("onnxruntime");if($ in globalThis)A=globalThis[$];else if(R.apis.IS_NODE_ENV){switch(A=Q??(P||(P=f.t(Q,2))),process.platform){case"win32":C.push("dml");break;case"linux":process.arch==="x64"&&C.push("cuda");break}C.push("cpu"),k=["cpu"]}else A=se,R.apis.IS_WEBNN_AVAILABLE&&C.push("webnn-npu","webnn-gpu","webnn-cpu","webnn"),R.apis.IS_WEBGPU_AVAILABLE&&C.push("webgpu"),C.push("wasm"),k=["wasm"];const ae=A.InferenceSession;function fe(X=null){if(!X)return k;switch(X){case"auto":return C;case"gpu":return C.filter(W=>["webgpu","cuda","dml","webnn-gpu"].includes(W))}if(C.includes(X))return[E[X]??X];throw new Error(`Unsupported device: "${X}". Should be one of: ${C.join(", ")}.`)}let ge=null;async function le(X,W,b){ge&&await ge;const z=ae.create(X,W);ge??(ge=z);const L=await z;return L.config=b,L}function q(X){return X instanceof A.Tensor}const ie=A==null?void 0:A.env;ie!=null&&ie.wasm&&(ie.wasm.wasmPaths=`https://cdn.jsdelivr.net/npm/@huggingface/transformers@${R.env.version}/dist/`,ie.wasm.proxy=!1,(typeof crossOriginIsolated>"u"||!crossOriginIsolated)&&(ie.wasm.numThreads=1)),ie!=null&&ie.webgpu&&(ie.webgpu.powerPreference="high-performance");function pe(){var X;return(X=ie==null?void 0:ie.wasm)==null?void 0:X.proxy}R.env.backends.onnx=ie},"./src/base/feature_extraction_utils.js":(ke,V,f)=>{f.r(V),f.d(V,{FeatureExtractor:()=>se,validate_audio_inputs:()=>oe});var P=f("./src/utils/constants.js"),R=f("./src/utils/generic.js"),Q=f("./src/utils/hub.js");class se extends R.Callable{constructor(C){super(),this.config=C}static async from_pretrained(C,k){const A=await(0,Q.getModelJSON)(C,P.FEATURE_EXTRACTOR_NAME,!0,k);return new this(A)}}function oe(E,C){var k;if(!(E instanceof Float32Array||E instanceof Float64Array))throw new Error(`${C} expects input to be a Float32Array or a Float64Array, but got ${((k=E==null?void 0:E.constructor)==null?void 0:k.name)??typeof E} instead. If using the feature extractor directly, remember to use \`read_audio(url, sampling_rate)\` to obtain the raw audio data of the file/url.`)}},"./src/base/image_processors_utils.js":(ke,V,f)=>{f.r(V),f.d(V,{ImageProcessor:()=>X,post_process_instance_segmentation:()=>pe,post_process_object_detection:()=>$,post_process_panoptic_segmentation:()=>ie,post_process_semantic_segmentation:()=>ae});var P=f("./src/utils/generic.js"),R=f("./src/utils/tensor.js"),Q=f("./src/utils/maths.js");f("./src/utils/image.js");var se=f("./src/utils/core.js"),oe=f("./src/utils/hub.js"),E=f("./src/utils/constants.js");function C(W,b,z=0,L=null){const de=W/b;let ce=(0,Q.bankers_round)(de)*b;return L!==null&&ce>L&&(ce=Math.floor(de)*b),ce<z&&(ce=Math.ceil(de)*b),ce}function k([W,b],z){return[Math.max(Math.floor(W/z),1)*z,Math.max(Math.floor(b/z),1)*z]}function A([W,b,z,L]){return[W-z/2,b-L/2,W+z/2,b+L/2]}function $(W,b=.5,z=null,L=!1){const de=W.logits,ce=W.pred_boxes,[Pe,Ee,Se]=de.dims;if(z!==null&&z.length!==Pe)throw Error("Make sure that you pass in as many target sizes as the batch dimension of the logits");let Be=[];for(let Le=0;Le<Pe;++Le){let He=z!==null?z[Le]:null,Me={boxes:[],classes:[],scores:[]},N=de[Le],me=ce[Le];for(let ue=0;ue<Ee;++ue){let ee=N[ue],Te=[],je;if(L){je=ee.sigmoid().data;for(let qe=0;qe<je.length;++qe)je[qe]>b&&Te.push(qe)}else{let qe=(0,Q.max)(ee.data)[1];if(qe===Se-1||(je=(0,Q.softmax)(ee.data),je[qe]<b))continue;Te.push(qe)}for(const qe of Te){let tt=me[ue].data;tt=A(tt),He!==null&&(tt=tt.map((he,Ve)=>he*He[(Ve+1)%2])),Me.boxes.push(tt),Me.classes.push(qe),Me.scores.push(je[qe])}}Be.push(Me)}return Be}function ae(W,b=null){const z=W.logits,L=z.dims[0];if(b!==null&&b.length!==L)throw Error("Make sure that you pass in as many target sizes as the batch dimension of the logits");const de=[];for(let ce=0;ce<L;++ce){const Pe=b!==null?b[ce]:null;let Ee=z[ce];Pe!==null&&(Ee=(0,R.interpolate)(Ee,Pe,"bilinear",!1));const[Se,Be]=Pe??Ee.dims.slice(-2),Le=new R.Tensor("int32",new Int32Array(Se*Be),[Se,Be]),He=Ee[0].data,Me=Le.data;for(let ue=1;ue<Ee.dims[0];++ue){const ee=Ee[ue].data;for(let Te=0;Te<ee.length;++Te)ee[Te]>He[Te]&&(He[Te]=ee[Te],Me[Te]=ue)}const N=new Array(Ee.dims[0]);for(let ue=0;ue<Me.length;++ue){const ee=Me[ue];N[ee]=ee}const me=N.filter(ue=>ue!==void 0);de.push({segmentation:Le,labels:me})}return de}function fe(W,b,z,L){const de=[],ce=[],Pe=[];for(let Ee=0;Ee<W.dims[0];++Ee){const Se=W[Ee],Be=b[Ee],Le=(0,Q.max)(Se.data)[1];if(Le===L)continue;const Me=(0,Q.softmax)(Se.data)[Le];Me>z&&(de.push(Be),ce.push(Me),Pe.push(Le))}return[de,ce,Pe]}function ge(W,b,z,L=.5,de=.8){const ce=[];let Pe=0,Ee=0;const Se=b[z].data;for(let Le=0;Le<W.length;++Le)W[Le]===z&&(ce.push(Le),++Pe),Se[Le]>=L&&++Ee;let Be=Pe>0&&Ee>0;return Be&&(Be=Pe/Ee>de),[Be,ce]}function le(W,b,z,L,de,ce=null,Pe=null){const[Ee,Se]=Pe??W[0].dims,Be=new R.Tensor("int32",new Int32Array(Ee*Se),[Ee,Se]),Le=[];if(Pe!==null)for(let ue=0;ue<W.length;++ue)W[ue]=(0,R.interpolate)(W[ue],Pe,"bilinear",!1);const He=new Int32Array(W[0].data.length),Me=new Float32Array(W[0].data.length);for(let ue=0;ue<W.length;++ue){let ee=b[ue];const Te=W[ue].data;for(let je=0;je<Te.length;++je)Te[je]*=ee,Te[je]>Me[je]&&(He[je]=ue,Me[je]=Te[je])}let N=0;const me=Be.data;for(let ue=0;ue<z.length;++ue){const ee=z[ue],[Te,je]=ge(He,W,ue,L,de);if(Te){++N;for(const qe of je)me[qe]=N;Le.push({id:N,label_id:ee,score:b[ue]})}}return[Be,Le]}function q(W,b,z=28,L=56*56,de=14*14*4*1280){if(W<z||b<z)throw new Error(`height:${W} or width:${b} must be larger than factor:${z}`);if(Math.max(W,b)/Math.min(W,b)>200)throw new Error(`absolute aspect ratio must be smaller than 200, got ${Math.max(W,b)/Math.min(W,b)}`);let ce=Math.round(W/z)*z,Pe=Math.round(b/z)*z;if(ce*Pe>de){const Ee=Math.sqrt(W*b/de);ce=Math.floor(W/Ee/z)*z,Pe=Math.floor(b/Ee/z)*z}else if(ce*Pe<L){const Ee=Math.sqrt(L/(W*b));ce=Math.ceil(W*Ee/z)*z,Pe=Math.ceil(b*Ee/z)*z}return[ce,Pe]}function ie(W,b=.5,z=.5,L=.8,de=null,ce=null){de===null&&(console.warn("`label_ids_to_fuse` unset. No instance will be fused."),de=new Set);const Pe=W.class_queries_logits??W.logits,Se=(W.masks_queries_logits??W.pred_masks).sigmoid();let[Be,Le,He]=Pe.dims;if(He-=1,ce!==null&&ce.length!==Be)throw Error("Make sure that you pass in as many target sizes as the batch dimension of the logits");let Me=[];for(let N=0;N<Be;++N){let me=ce!==null?ce[N]:null,ue=Pe[N],ee=Se[N],[Te,je,qe]=fe(ue,ee,b,He);if(qe.length===0){let[Ve,Je]=me??ee.dims.slice(-2),We=new R.Tensor("int32",new Int32Array(Ve*Je).fill(-1),[Ve,Je]);Me.push({segmentation:We,segments_info:[]});continue}let[tt,he]=le(Te,je,qe,z,L,de,me);Me.push({segmentation:tt,segments_info:he})}return Me}function pe(W,b=.5,z=null){throw new Error("`post_process_instance_segmentation` is not yet implemented.")}class X extends P.Callable{constructor(b){super(),this.image_mean=b.image_mean??b.mean,this.image_std=b.image_std??b.std,this.resample=b.resample??2,this.do_rescale=b.do_rescale??!0,this.rescale_factor=b.rescale_factor??1/255,this.do_normalize=b.do_normalize,this.do_thumbnail=b.do_thumbnail,this.size=b.size??b.image_size,this.do_resize=b.do_resize??this.size!==void 0,this.size_divisibility=b.size_divisibility??b.size_divisor,this.do_center_crop=b.do_center_crop,this.crop_size=b.crop_size,this.do_convert_rgb=b.do_convert_rgb??!0,this.do_crop_margin=b.do_crop_margin,this.pad_size=b.pad_size,this.do_pad=b.do_pad,this.do_pad&&!this.pad_size&&this.size&&this.size.width!==void 0&&this.size.height!==void 0&&(this.pad_size=this.size),this.do_flip_channel_order=b.do_flip_channel_order??!1,this.config=b}async thumbnail(b,z,L=2){const de=b.height,ce=b.width,Pe=z.height,Ee=z.width;let Se=Math.min(de,Pe),Be=Math.min(ce,Ee);return Se===de&&Be===ce?b:(de>ce?Be=Math.floor(ce*Se/de):ce>de&&(Se=Math.floor(de*Be/ce)),await b.resize(Be,Se,{resample:L}))}async crop_margin(b,z=200){const L=b.clone().grayscale(),de=(0,Q.min)(L.data)[0],Pe=(0,Q.max)(L.data)[0]-de;if(Pe===0)return b;const Ee=z/255;let Se=L.width,Be=L.height,Le=0,He=0;const Me=L.data;for(let N=0;N<L.height;++N){const me=N*L.width;for(let ue=0;ue<L.width;++ue)(Me[me+ue]-de)/Pe<Ee&&(Se=Math.min(Se,ue),Be=Math.min(Be,N),Le=Math.max(Le,ue),He=Math.max(He,N))}return b=await b.crop([Se,Be,Le,He]),b}pad_image(b,z,L,{mode:de="constant",center:ce=!1,constant_values:Pe=0}={}){const[Ee,Se,Be]=z;let Le,He;if(typeof L=="number"?(Le=L,He=L):(Le=L.width,He=L.height),Le!==Se||He!==Ee){const Me=new Float32Array(Le*He*Be);if(Array.isArray(Pe))for(let ue=0;ue<Me.length;++ue)Me[ue]=Pe[ue%Be];else Pe!==0&&Me.fill(Pe);const[N,me]=ce?[Math.floor((Le-Se)/2),Math.floor((He-Ee)/2)]:[0,0];for(let ue=0;ue<Ee;++ue){const ee=(ue+me)*Le,Te=ue*Se;for(let je=0;je<Se;++je){const qe=(ee+je+N)*Be,tt=(Te+je)*Be;for(let he=0;he<Be;++he)Me[qe+he]=b[tt+he]}}if(de==="symmetric"){if(ce)throw new Error("`center` padding is not supported when `mode` is set to `symmetric`.");const ue=Ee-1,ee=Se-1;for(let Te=0;Te<He;++Te){const je=Te*Le,qe=(0,se.calculateReflectOffset)(Te,ue)*Se;for(let tt=0;tt<Le;++tt){if(Te<Ee&&tt<Se)continue;const he=(je+tt)*Be,Ve=(qe+(0,se.calculateReflectOffset)(tt,ee))*Be;for(let Je=0;Je<Be;++Je)Me[he+Je]=b[Ve+Je]}}}b=Me,z=[He,Le,Be]}return[b,z]}rescale(b){for(let z=0;z<b.length;++z)b[z]=this.rescale_factor*b[z]}get_resize_output_image_size(b,z){const[L,de]=b.size;let ce,Pe;if(this.do_thumbnail){const{height:Ee,width:Se}=z;ce=Math.min(Ee,Se)}else Number.isInteger(z)?(ce=z,Pe=this.config.max_size??ce):z!==void 0&&(ce=z.shortest_edge,Pe=z.longest_edge);if(ce!==void 0||Pe!==void 0){const Ee=ce===void 0?1:Math.max(ce/L,ce/de),Se=L*Ee,Be=de*Ee,Le=Pe===void 0?1:Math.min(Pe/Se,Pe/Be);let He=Math.floor(Number((Se*Le).toFixed(2))),Me=Math.floor(Number((Be*Le).toFixed(2)));return this.size_divisibility!==void 0&&([He,Me]=k([He,Me],this.size_divisibility)),[He,Me]}else if(z!==void 0&&z.width!==void 0&&z.height!==void 0){let Ee=z.width,Se=z.height;if(this.config.keep_aspect_ratio&&this.config.ensure_multiple_of){let Be=Se/de,Le=Ee/L;Math.abs(1-Le)<Math.abs(1-Be)?Be=Le:Le=Be,Se=C(Be*de,this.config.ensure_multiple_of),Ee=C(Le*L,this.config.ensure_multiple_of)}return[Ee,Se]}else{if(this.size_divisibility!==void 0)return k([L,de],this.size_divisibility);if(z.min_pixels!==void 0&&z.max_pixels!==void 0){const{min_pixels:Ee,max_pixels:Se}=z,Be=this.config.patch_size*this.config.merge_size;return q(de,L,Be,Ee,Se)}else throw new Error(`Could not resize image due to unsupported \`this.size\` option in config: ${JSON.stringify(z)}`)}}async resize(b){const[z,L]=this.get_resize_output_image_size(b,this.size);return await b.resize(z,L,{resample:this.resample})}async preprocess(b,{do_normalize:z=null,do_pad:L=null,do_convert_rgb:de=null,do_convert_grayscale:ce=null,do_flip_channel_order:Pe=null}={}){this.do_crop_margin&&(b=await this.crop_margin(b));const[Ee,Se]=b.size;if(de??this.do_convert_rgb?b=b.rgb():ce&&(b=b.grayscale()),this.do_resize&&(b=await this.resize(b)),this.do_thumbnail&&(b=await this.thumbnail(b,this.size,this.resample)),this.do_center_crop){let N,me;Number.isInteger(this.crop_size)?(N=this.crop_size,me=this.crop_size):(N=this.crop_size.width,me=this.crop_size.height),b=await b.center_crop(N,me)}const Be=[b.height,b.width];let Le=Float32Array.from(b.data),He=[b.height,b.width,b.channels];if(this.do_rescale&&this.rescale(Le),z??this.do_normalize){let N=this.image_mean;Array.isArray(this.image_mean)||(N=new Array(b.channels).fill(N));let me=this.image_std;if(Array.isArray(this.image_std)||(me=new Array(b.channels).fill(N)),N.length!==b.channels||me.length!==b.channels)throw new Error(`When set to arrays, the length of \`image_mean\` (${N.length}) and \`image_std\` (${me.length}) must match the number of channels in the image (${b.channels}).`);for(let ue=0;ue<Le.length;ue+=b.channels)for(let ee=0;ee<b.channels;++ee)Le[ue+ee]=(Le[ue+ee]-N[ee])/me[ee]}if(L??this.do_pad){if(this.pad_size)[Le,He]=this.pad_image(Le,[b.height,b.width,b.channels],this.pad_size);else if(this.size_divisibility){const[N,me]=k([He[1],He[0]],this.size_divisibility);[Le,He]=this.pad_image(Le,He,{width:N,height:me})}}if(Pe??this.do_flip_channel_order){if(He[2]!==3)throw new Error("Flipping channel order is only supported for RGB images.");for(let N=0;N<Le.length;N+=3){const me=Le[N];Le[N]=Le[N+2],Le[N+2]=me}}const Me=new R.Tensor("float32",Le,He).permute(2,0,1);return{original_size:[Se,Ee],reshaped_input_size:Be,pixel_values:Me}}async _call(b,...z){Array.isArray(b)||(b=[b]);const L=await Promise.all(b.map(ce=>this.preprocess(ce)));return{pixel_values:(0,R.stack)(L.map(ce=>ce.pixel_values),0),original_sizes:L.map(ce=>ce.original_size),reshaped_input_sizes:L.map(ce=>ce.reshaped_input_size)}}static async from_pretrained(b,z){const L=await(0,oe.getModelJSON)(b,E.IMAGE_PROCESSOR_NAME,!0,z);return new this(L)}}},"./src/base/processing_utils.js":(ke,V,f)=>{f.r(V),f.d(V,{Processor:()=>se});var P=f("./src/utils/constants.js"),R=f("./src/utils/generic.js"),Q=f("./src/utils/hub.js");class se extends R.Callable{constructor(E,C){super(),this.config=E,this.components=C}get image_processor(){return this.components.image_processor}get tokenizer(){return this.components.tokenizer}get feature_extractor(){return this.components.feature_extractor}apply_chat_template(E,C={}){if(!this.tokenizer)throw new Error("Unable to apply chat template without a tokenizer.");return this.tokenizer.apply_chat_template(E,{tokenize:!1,...C})}batch_decode(...E){if(!this.tokenizer)throw new Error("Unable to decode without a tokenizer.");return this.tokenizer.batch_decode(...E)}async _call(E,...C){for(const k of[this.image_processor,this.feature_extractor,this.tokenizer])if(k)return k(E,...C);throw new Error("No image processor, feature extractor, or tokenizer found.")}static async from_pretrained(E,C){const[k,A]=await Promise.all([this.uses_processor_config?(0,Q.getModelJSON)(E,P.PROCESSOR_NAME,!0,C):{},Promise.all(this.classes.filter($=>$ in this).map(async $=>{const ae=await this[$].from_pretrained(E,C);return[$.replace(/_class$/,""),ae]})).then(Object.fromEntries)]);return new this(k,A)}}Fe(se,"classes",["image_processor_class","tokenizer_class","feature_extractor_class"]),Fe(se,"uses_processor_config",!1)},"./src/configs.js":(ke,V,f)=>{f.r(V),f.d(V,{AutoConfig:()=>C,PretrainedConfig:()=>E,getKeyValueShapes:()=>oe});var P=f("./src/utils/core.js"),R=f("./src/utils/hub.js");async function Q(k,A){return await(0,R.getModelJSON)(k,"config.json",!0,A)}function se(k){const A={};let $={};switch(k.model_type){case"llava":case"paligemma":case"florence2":case"llava_onevision":$=se(k.text_config);break;case"moondream1":$=se(k.phi_config);break;case"musicgen":$=se(k.decoder);break;case"multi_modality":$=se(k.language_config);break;case"gpt2":case"gptj":case"jais":case"codegen":case"gpt_bigcode":A.num_heads="n_head",A.num_layers="n_layer",A.hidden_size="n_embd";break;case"gpt_neox":case"stablelm":case"opt":case"phi":case"phi3":case"falcon":A.num_heads="num_attention_heads",A.num_layers="num_hidden_layers",A.hidden_size="hidden_size";break;case"llama":case"olmo":case"mobilellm":case"granite":case"cohere":case"mistral":case"starcoder2":case"qwen2":case"qwen2_vl":A.num_heads="num_key_value_heads",A.num_layers="num_hidden_layers",A.hidden_size="hidden_size",A.num_attention_heads="num_attention_heads";break;case"gemma":case"gemma2":A.num_heads="num_key_value_heads",A.num_layers="num_hidden_layers",A.dim_kv="head_dim";break;case"openelm":A.num_heads="num_kv_heads",A.num_layers="num_transformer_layers",A.dim_kv="head_dim";break;case"gpt_neo":case"donut-swin":A.num_heads="num_heads",A.num_layers="num_layers",A.hidden_size="hidden_size";break;case"bloom":A.num_heads="n_head",A.num_layers="n_layer",A.hidden_size="hidden_size";break;case"mpt":A.num_heads="n_heads",A.num_layers="n_layers",A.hidden_size="d_model";break;case"t5":case"mt5":case"longt5":A.num_decoder_layers="num_decoder_layers",A.num_decoder_heads="num_heads",A.decoder_dim_kv="d_kv",A.num_encoder_layers="num_layers",A.num_encoder_heads="num_heads",A.encoder_dim_kv="d_kv";break;case"bart":case"mbart":case"marian":case"whisper":case"m2m_100":case"blenderbot":case"blenderbot-small":case"florence2_language":A.num_decoder_layers="decoder_layers",A.num_decoder_heads="decoder_attention_heads",A.decoder_hidden_size="d_model",A.num_encoder_layers="encoder_layers",A.num_encoder_heads="encoder_attention_heads",A.encoder_hidden_size="d_model";break;case"speecht5":A.num_decoder_layers="decoder_layers",A.num_decoder_heads="decoder_attention_heads",A.decoder_hidden_size="hidden_size",A.num_encoder_layers="encoder_layers",A.num_encoder_heads="encoder_attention_heads",A.encoder_hidden_size="hidden_size";break;case"trocr":A.num_encoder_layers=A.num_decoder_layers="decoder_layers",A.num_encoder_heads=A.num_decoder_heads="decoder_attention_heads",A.encoder_hidden_size=A.decoder_hidden_size="d_model";break;case"musicgen_decoder":A.num_encoder_layers=A.num_decoder_layers="num_hidden_layers",A.num_encoder_heads=A.num_decoder_heads="num_attention_heads",A.encoder_hidden_size=A.decoder_hidden_size="hidden_size";break;case"vision-encoder-decoder":const fe=se(k.decoder),ge="num_decoder_layers"in fe,le=(0,P.pick)(k,["model_type","is_encoder_decoder"]);return ge?(le.num_decoder_layers=fe.num_decoder_layers,le.num_decoder_heads=fe.num_decoder_heads,le.decoder_hidden_size=fe.decoder_hidden_size,le.num_encoder_layers=fe.num_encoder_layers,le.num_encoder_heads=fe.num_encoder_heads,le.encoder_hidden_size=fe.encoder_hidden_size):(le.num_layers=fe.num_layers,le.num_heads=fe.num_heads,le.hidden_size=fe.hidden_size),le}const ae={...$,...(0,P.pick)(k,["model_type","multi_query","is_encoder_decoder"])};for(const fe in A)ae[fe]=k[A[fe]];return ae}function oe(k,{prefix:A="past_key_values",batch_size:$=1}={}){const ae={},fe=k.normalized_config;if(fe.is_encoder_decoder&&"num_encoder_heads"in fe&&"num_decoder_heads"in fe){const ge=fe.encoder_dim_kv??fe.encoder_hidden_size/fe.num_encoder_heads,le=fe.decoder_dim_kv??fe.decoder_hidden_size/fe.num_decoder_heads,q=[$,fe.num_encoder_heads,0,ge],ie=[$,fe.num_decoder_heads,0,le];for(let pe=0;pe<fe.num_decoder_layers;++pe)ae[`${A}.${pe}.encoder.key`]=q,ae[`${A}.${pe}.encoder.value`]=q,ae[`${A}.${pe}.decoder.key`]=ie,ae[`${A}.${pe}.decoder.value`]=ie}else{const ge=fe.num_heads,le=fe.num_layers,q=fe.dim_kv??fe.hidden_size/(fe.num_attention_heads??ge);if(fe.model_type==="falcon"){const ie=[$*ge,0,q];for(let pe=0;pe<le;++pe)ae[`${A}.${pe}.key`]=ie,ae[`${A}.${pe}.value`]=ie}else if(fe.multi_query){const ie=[$*ge,0,2*q];for(let pe=0;pe<le;++pe)ae[`${A}.${pe}.key_value`]=ie}else if(fe.model_type==="bloom"){const ie=[$*ge,q,0],pe=[$*ge,0,q];for(let X=0;X<le;++X)ae[`${A}.${X}.key`]=ie,ae[`${A}.${X}.value`]=pe}else if(fe.model_type==="openelm")for(let ie=0;ie<le;++ie){const pe=[$,ge[ie],0,q];ae[`${A}.${ie}.key`]=pe,ae[`${A}.${ie}.value`]=pe}else{const ie=[$,ge,0,q];for(let pe=0;pe<le;++pe)ae[`${A}.${pe}.key`]=ie,ae[`${A}.${pe}.value`]=ie}}return ae}class E{constructor(A){Fe(this,"model_type",null);Fe(this,"is_encoder_decoder",!1);Fe(this,"max_position_embeddings");Fe(this,"transformers.js_config");Object.assign(this,A),this.normalized_config=se(this)}static async from_pretrained(A,{progress_callback:$=null,config:ae=null,cache_dir:fe=null,local_files_only:ge=!1,revision:le="main"}={}){ae&&!(ae instanceof E)&&(ae=new E(ae));const q=ae??await Q(A,{progress_callback:$,config:ae,cache_dir:fe,local_files_only:ge,revision:le});return new this(q)}}class C{static async from_pretrained(...A){return E.from_pretrained(...A)}}},"./src/env.js":(ke,V,f)=>{var L;f.r(V),f.d(V,{apis:()=>le,env:()=>b});var P=f("?569f"),R=f("?3f59"),Q=f("?154a");const se="3.1.0",oe=typeof self<"u",E=oe&&self.constructor.name==="DedicatedWorkerGlobalScope",C=oe&&"caches"in self,k=typeof navigator<"u"&&"gpu"in navigator,A=typeof navigator<"u"&&"ml"in navigator,$=typeof process<"u",ae=$&&((L=process==null?void 0:process.release)==null?void 0:L.name)==="node",fe=!z(P),ge=!z(R),le=Object.freeze({IS_BROWSER_ENV:oe,IS_WEBWORKER_ENV:E,IS_WEB_CACHE_AVAILABLE:C,IS_WEBGPU_AVAILABLE:k,IS_WEBNN_AVAILABLE:A,IS_PROCESS_AVAILABLE:$,IS_NODE_ENV:ae,IS_FS_AVAILABLE:fe,IS_PATH_AVAILABLE:ge}),q=fe&&ge;let ie="./";if(q){const de=Object(import.meta).url;de?ie=R.dirname(R.dirname(Q.fileURLToPath(de))):typeof __dirname<"u"&&(ie=R.dirname(__dirname))}const pe=q?R.join(ie,"/.cache/"):null,X="/models/",W=q?R.join(ie,X):X,b={version:se,backends:{onnx:{}},allowRemoteModels:!0,remoteHost:"https://huggingface.co/",remotePathTemplate:"{model}/resolve/{revision}/",allowLocalModels:!oe,localModelPath:W,useFS:fe,useBrowserCache:C,useFSCache:fe,cacheDir:pe,useCustomCache:!1,customCache:null};function z(de){return Object.keys(de).length===0}},"./src/generation/configuration_utils.js":(ke,V,f)=>{f.r(V),f.d(V,{GenerationConfig:()=>R});var P=f("./src/utils/core.js");class R{constructor(se){Fe(this,"max_length",20);Fe(this,"max_new_tokens",null);Fe(this,"min_length",0);Fe(this,"min_new_tokens",null);Fe(this,"early_stopping",!1);Fe(this,"max_time",null);Fe(this,"do_sample",!1);Fe(this,"num_beams",1);Fe(this,"num_beam_groups",1);Fe(this,"penalty_alpha",null);Fe(this,"use_cache",!0);Fe(this,"temperature",1);Fe(this,"top_k",50);Fe(this,"top_p",1);Fe(this,"typical_p",1);Fe(this,"epsilon_cutoff",0);Fe(this,"eta_cutoff",0);Fe(this,"diversity_penalty",0);Fe(this,"repetition_penalty",1);Fe(this,"encoder_repetition_penalty",1);Fe(this,"length_penalty",1);Fe(this,"no_repeat_ngram_size",0);Fe(this,"bad_words_ids",null);Fe(this,"force_words_ids",null);Fe(this,"renormalize_logits",!1);Fe(this,"constraints",null);Fe(this,"forced_bos_token_id",null);Fe(this,"forced_eos_token_id",null);Fe(this,"remove_invalid_values",!1);Fe(this,"exponential_decay_length_penalty",null);Fe(this,"suppress_tokens",null);Fe(this,"begin_suppress_tokens",null);Fe(this,"forced_decoder_ids",null);Fe(this,"guidance_scale",null);Fe(this,"num_return_sequences",1);Fe(this,"output_attentions",!1);Fe(this,"output_hidden_states",!1);Fe(this,"output_scores",!1);Fe(this,"return_dict_in_generate",!1);Fe(this,"pad_token_id",null);Fe(this,"bos_token_id",null);Fe(this,"eos_token_id",null);Fe(this,"encoder_no_repeat_ngram_size",0);Fe(this,"decoder_start_token_id",null);Fe(this,"generation_kwargs",{});Object.assign(this,(0,P.pick)(se,Object.getOwnPropertyNames(this)))}}},"./src/generation/logits_process.js":(ke,V,f)=>{f.r(V),f.d(V,{ClassifierFreeGuidanceLogitsProcessor:()=>q,ForcedBOSTokenLogitsProcessor:()=>E,ForcedEOSTokenLogitsProcessor:()=>C,LogitsProcessor:()=>Q,LogitsProcessorList:()=>oe,LogitsWarper:()=>se,MinLengthLogitsProcessor:()=>fe,MinNewTokensLengthLogitsProcessor:()=>ge,NoBadWordsLogitsProcessor:()=>le,NoRepeatNGramLogitsProcessor:()=>$,RepetitionPenaltyLogitsProcessor:()=>ae,SuppressTokensAtBeginLogitsProcessor:()=>k,TemperatureLogitsWarper:()=>ie,TopKLogitsWarper:()=>X,TopPLogitsWarper:()=>pe,WhisperTimeStampLogitsProcessor:()=>A});var P=f("./src/utils/generic.js");f("./src/utils/tensor.js");var R=f("./src/utils/maths.js");class Q extends P.Callable{_call(b,z){throw Error("`_call` should be implemented in a subclass")}}class se extends P.Callable{_call(b,z){throw Error("`_call` should be implemented in a subclass")}}class oe extends P.Callable{constructor(){super(),this.processors=[]}push(b){this.processors.push(b)}extend(b){this.processors.push(...b)}_call(b,z){let L=z;for(const de of this.processors)L=de(b,L);return L}[Symbol.iterator](){return this.processors.values()}}class E extends Q{constructor(b){super(),this.bos_token_id=b}_call(b,z){for(let L=0;L<b.length;++L)if(b[L].length===1){const de=z[L].data;de.fill(-1/0),de[this.bos_token_id]=0}return z}}class C extends Q{constructor(b,z){super(),this.max_length=b,this.eos_token_id=Array.isArray(z)?z:[z]}_call(b,z){for(let L=0;L<b.length;++L)if(b[L].length===this.max_length-1){const de=z[L].data;de.fill(-1/0);for(const ce of this.eos_token_id)de[ce]=0}return z}}class k extends Q{constructor(b,z){super(),this.begin_suppress_tokens=b,this.begin_index=z}_call(b,z){for(let L=0;L<b.length;++L)if(b[L].length===this.begin_index){const de=z[L].data;for(const ce of this.begin_suppress_tokens)de[ce]=-1/0}return z}}class A extends Q{constructor(b,z){super(),this.eos_token_id=Array.isArray(b.eos_token_id)?b.eos_token_id[0]:b.eos_token_id,this.no_timestamps_token_id=b.no_timestamps_token_id,this.timestamp_begin=this.no_timestamps_token_id+1,this.begin_index=z.length,z.at(-1)===this.no_timestamps_token_id&&(this.begin_index-=1),this.max_initial_timestamp_index=b.max_initial_timestamp_index}_call(b,z){for(let L=0;L<b.length;++L){const de=z[L].data;if(de[this.no_timestamps_token_id]=-1/0,b[L].length===this.begin_index-1){de.fill(-1/0),de[this.timestamp_begin]=0;continue}const ce=b[L].slice(this.begin_index),Pe=ce.length>=1&&ce[ce.length-1]>=this.timestamp_begin,Ee=ce.length<2||ce[ce.length-2]>=this.timestamp_begin;if(Pe&&(Ee?de.subarray(this.timestamp_begin).fill(-1/0):de.subarray(0,this.eos_token_id).fill(-1/0)),b[L].length===this.begin_index&&this.max_initial_timestamp_index!==null){const He=this.timestamp_begin+this.max_initial_timestamp_index;de.subarray(He+1).fill(-1/0)}const Se=(0,R.log_softmax)(de),Be=Math.log(Se.subarray(this.timestamp_begin).map(Math.exp).reduce((He,Me)=>He+Me)),Le=(0,R.max)(Se.subarray(0,this.timestamp_begin))[0];Be>Le&&de.subarray(0,this.timestamp_begin).fill(-1/0)}return z}}class $ extends Q{constructor(b){super(),this.no_repeat_ngram_size=b}getNgrams(b){const z=b.length,L=[];for(let ce=0;ce<z+1-this.no_repeat_ngram_size;++ce){const Pe=[];for(let Ee=0;Ee<this.no_repeat_ngram_size;++Ee)Pe.push(b[ce+Ee]);L.push(Pe.map(Number))}const de=new Map;for(const ce of L){const Pe=ce.slice(0,ce.length-1),Ee=JSON.stringify(Pe),Se=de.get(Ee)??[];Se.push(ce[ce.length-1]),de.set(Ee,Se)}return de}getGeneratedNgrams(b,z){const L=z.slice(z.length+1-this.no_repeat_ngram_size,z.length);return b.get(JSON.stringify(L.map(Number)))??[]}calcBannedNgramTokens(b){const z=[];if(b.length+1<this.no_repeat_ngram_size)return z;{const L=this.getNgrams(b);return this.getGeneratedNgrams(L,b)}}_call(b,z){for(let L=0;L<b.length;++L){const de=z[L].data,ce=this.calcBannedNgramTokens(b[L]);for(const Pe of ce)de[Pe]=-1/0}return z}}class ae extends Q{constructor(b){super(),this.penalty=b}_call(b,z){for(let L=0;L<b.length;++L){const de=z[L].data;for(const ce of b[L]){const Pe=Number(ce);de[Pe]<0?de[Pe]*=this.penalty:de[Pe]/=this.penalty}}return z}}class fe extends Q{constructor(b,z){super(),this.min_length=b,this.eos_token_id=Array.isArray(z)?z:[z]}_call(b,z){for(let L=0;L<b.length;++L)if(b[L].length<this.min_length){const de=z[L].data;for(const ce of this.eos_token_id)de[ce]=-1/0}return z}}class ge extends Q{constructor(b,z,L){super(),this.prompt_length_to_skip=b,this.min_new_tokens=z,this.eos_token_id=Array.isArray(L)?L:[L]}_call(b,z){for(let L=0;L<b.length;++L)if(b[L].length-this.prompt_length_to_skip<this.min_new_tokens){const ce=z[L].data;for(const Pe of this.eos_token_id)ce[Pe]=-1/0}return z}}class le extends Q{constructor(b,z){super(),this.bad_words_ids=b,this.eos_token_id=Array.isArray(z)?z:[z]}_call(b,z){for(let L=0;L<b.length;++L){const de=z[L].data,ce=b[L];for(const Pe of this.bad_words_ids){let Ee=!0;for(let Se=1;Se<=Pe.length-1&&Pe.length<ce.length;++Se)if(Pe.at(-Se-1)!=ce.at(-Se)){Ee=!1;break}Ee&&(de[Pe.at(-1)]=-1/0)}}return z}}class q extends Q{constructor(b){if(super(),b<=1)throw new Error(`Require guidance scale >1 to use the classifier free guidance processor, got guidance scale ${b}.`);this.guidance_scale=b}_call(b,z){if(z.dims[0]!==2*b.length)throw new Error(`Logits should have twice the batch size of the input ids, the first half of batches corresponding to the conditional inputs, and the second half of batches corresponding to the unconditional inputs. Got batch size ${z.dims[0]} for the logits and ${b.length} for the input ids.`);const L=b.length,de=z.slice([0,L],null),ce=z.slice([L,z.dims[0]],null);for(let Pe=0;Pe<ce.data.length;++Pe)ce.data[Pe]+=(de.data[Pe]-ce.data[Pe])*this.guidance_scale;return ce}}class ie extends se{constructor(b){super(),this.temperature=b}_call(b,z){const L=z.data;for(let de=0;de<L.length;++de)L[de]/=this.temperature;return z}}class pe extends se{constructor(b,{filter_value:z=-1/0,min_tokens_to_keep:L=1}={}){if(super(),b<0||b>1)throw new Error(`\`top_p\` must be a float > 0 and < 1, but is ${b}`);if(!Number.isInteger(L)||L<1)throw new Error(`\`min_tokens_to_keep\` must be a positive integer, but is ${L}`);this.top_p=b,this.filter_value=z,this.min_tokens_to_keep=L}}class X extends se{constructor(b,{filter_value:z=-1/0,min_tokens_to_keep:L=1}={}){if(super(),!Number.isInteger(b)||b<0)throw new Error(`\`top_k\` must be a positive integer, but is ${b}`);this.top_k=Math.max(b,L),this.filter_value=z}}},"./src/generation/logits_sampler.js":(ke,V,f)=>{f.r(V),f.d(V,{LogitsSampler:()=>se});var P=f("./src/utils/generic.js"),R=f("./src/utils/tensor.js"),Q=f("./src/utils/maths.js");f("./src/generation/configuration_utils.js");class se extends P.Callable{constructor(A){super(),this.generation_config=A}async _call(A){return this.sample(A)}async sample(A){throw Error("sample should be implemented in subclasses.")}getLogits(A,$){let ae=A.dims.at(-1),fe=A.data;if($===-1)fe=fe.slice(-ae);else{let ge=$*ae;fe=fe.slice(ge,ge+ae)}return fe}randomSelect(A){let $=0;for(let fe=0;fe<A.length;++fe)$+=A[fe];let ae=Math.random()*$;for(let fe=0;fe<A.length;++fe)if(ae-=A[fe],ae<=0)return fe;return 0}static getSampler(A){if(A.do_sample)return new E(A);if(A.num_beams>1)return new C(A);if(A.num_return_sequences>1)throw Error(`num_return_sequences has to be 1 when doing greedy search, but is ${A.num_return_sequences}.`);return new oe(A)}}class oe extends se{async sample(A){const $=(0,Q.max)(A.data)[1];return[[BigInt($),0]]}}class E extends se{async sample(A){let $=A.dims.at(-1);this.generation_config.top_k>0&&($=Math.min(this.generation_config.top_k,$));const[ae,fe]=await(0,R.topk)(A,$),ge=(0,Q.softmax)(ae.data);return Array.from({length:this.generation_config.num_beams},()=>{const le=this.randomSelect(ge);return[fe.data[le],Math.log(ge[le])]})}}class C extends se{async sample(A){let $=A.dims.at(-1);this.generation_config.top_k>0&&($=Math.min(this.generation_config.top_k,$));const[ae,fe]=await(0,R.topk)(A,$),ge=(0,Q.softmax)(ae.data);return Array.from({length:this.generation_config.num_beams},(le,q)=>[fe.data[q],Math.log(ge[q])])}}},"./src/generation/stopping_criteria.js":(ke,V,f)=>{f.r(V),f.d(V,{EosTokenCriteria:()=>oe,InterruptableStoppingCriteria:()=>E,MaxLengthCriteria:()=>se,StoppingCriteria:()=>R,StoppingCriteriaList:()=>Q});var P=f("./src/utils/generic.js");class R extends P.Callable{_call(k,A){throw Error("StoppingCriteria needs to be subclassed")}}class Q extends P.Callable{constructor(){super(),this.criteria=[]}push(k){this.criteria.push(k)}extend(k){k instanceof Q?k=k.criteria:k instanceof R&&(k=[k]),this.criteria.push(...k)}_call(k,A){const $=new Array(k.length).fill(!1);for(const ae of this.criteria){const fe=ae(k,A);for(let ge=0;ge<$.length;++ge)$[ge]||($[ge]=fe[ge])}return $}[Symbol.iterator](){return this.criteria.values()}}class se extends R{constructor(k,A=null){super(),this.max_length=k,this.max_position_embeddings=A}_call(k){return k.map(A=>A.length>=this.max_length)}}class oe extends R{constructor(k){super(),Array.isArray(k)||(k=[k]),this.eos_token_id=k}_call(k,A){return k.map($=>{const ae=$.at(-1);return this.eos_token_id.some(fe=>ae==fe)})}}class E extends R{constructor(){super(),this.interrupted=!1}interrupt(){this.interrupted=!0}reset(){this.interrupted=!1}_call(k,A){return new Array(k.length).fill(this.interrupted)}}},"./src/generation/streamers.js":(ke,V,f)=>{f.r(V),f.d(V,{BaseStreamer:()=>se,TextStreamer:()=>E,WhisperTextStreamer:()=>C});var P=f("./src/utils/core.js"),R=f("./src/tokenizers.js"),Q=f("./src/env.js");class se{put(A){throw Error("Not implemented")}end(){throw Error("Not implemented")}}const oe=Q.apis.IS_PROCESS_AVAILABLE?k=>process.stdout.write(k):k=>console.log(k);class E extends se{constructor(A,{skip_prompt:$=!1,callback_function:ae=null,token_callback_function:fe=null,decode_kwargs:ge={},...le}={}){super(),this.tokenizer=A,this.skip_prompt=$,this.callback_function=ae??oe,this.token_callback_function=fe,this.decode_kwargs={...ge,...le},this.token_cache=[],this.print_len=0,this.next_tokens_are_prompt=!0}put(A){var ge;if(A.length>1)throw Error("TextStreamer only supports batch size of 1");if(this.skip_prompt&&this.next_tokens_are_prompt){this.next_tokens_are_prompt=!1;return}const $=A[0];(ge=this.token_callback_function)==null||ge.call(this,$),this.token_cache=(0,P.mergeArrays)(this.token_cache,$);const ae=this.tokenizer.decode(this.token_cache,this.decode_kwargs);let fe;ae.endsWith(`
`)?(fe=ae.slice(this.print_len),this.token_cache=[],this.print_len=0):ae.length>0&&(0,R.is_chinese_char)(ae.charCodeAt(ae.length-1))?(fe=ae.slice(this.print_len),this.print_len+=fe.length):(fe=ae.slice(this.print_len,ae.lastIndexOf(" ")+1),this.print_len+=fe.length),this.on_finalized_text(fe,!1)}end(){let A;this.token_cache.length>0?(A=this.tokenizer.decode(this.token_cache,this.decode_kwargs).slice(this.print_len),this.token_cache=[],this.print_len=0):A="",this.next_tokens_are_prompt=!0,this.on_finalized_text(A,!0)}on_finalized_text(A,$){var ae,fe;A.length>0&&((ae=this.callback_function)==null||ae.call(this,A)),$&&this.callback_function===oe&&Q.apis.IS_PROCESS_AVAILABLE&&((fe=this.callback_function)==null||fe.call(this,`
`))}}class C extends E{constructor(A,{skip_prompt:$=!1,callback_function:ae=null,token_callback_function:fe=null,on_chunk_start:ge=null,on_chunk_end:le=null,on_finalize:q=null,time_precision:ie=.02,skip_special_tokens:pe=!0,decode_kwargs:X={}}={}){super(A,{skip_prompt:$,callback_function:ae,token_callback_function:fe,decode_kwargs:{skip_special_tokens:pe,...X}}),this.timestamp_begin=A.timestamp_begin,this.on_chunk_start=ge,this.on_chunk_end=le,this.on_finalize=q,this.time_precision=ie,this.waiting_for_timestamp=!1}put(A){var ae,fe;if(A.length>1)throw Error("WhisperTextStreamer only supports batch size of 1");const $=A[0];if($.length===1){const ge=Number($[0])-this.timestamp_begin;if(ge>=0){const le=ge*this.time_precision;this.waiting_for_timestamp?(ae=this.on_chunk_end)==null||ae.call(this,le):(fe=this.on_chunk_start)==null||fe.call(this,le),this.waiting_for_timestamp=!this.waiting_for_timestamp,A=[[]]}}return super.put(A)}end(){var A;super.end(),(A=this.on_finalize)==null||A.call(this)}}},"./src/models.js":(ke,V,f)=>{f.r(V),f.d(V,{ASTForAudioClassification:()=>al,ASTModel:()=>Ut,ASTPreTrainedModel:()=>it,AlbertForMaskedLM:()=>ga,AlbertForQuestionAnswering:()=>_a,AlbertForSequenceClassification:()=>ki,AlbertModel:()=>Rt,AlbertPreTrainedModel:()=>po,AutoModel:()=>ou,AutoModelForAudioClassification:()=>au,AutoModelForAudioFrameClassification:()=>Tn,AutoModelForCTC:()=>Vc,AutoModelForCausalLM:()=>Zd,AutoModelForDepthEstimation:()=>Gc,AutoModelForDocumentQuestionAnswering:()=>vs,AutoModelForImageClassification:()=>ep,AutoModelForImageFeatureExtraction:()=>Ls,AutoModelForImageMatting:()=>Eo,AutoModelForImageSegmentation:()=>tp,AutoModelForImageToImage:()=>Wc,AutoModelForMaskGeneration:()=>Uc,AutoModelForMaskedLM:()=>Dt,AutoModelForNormalEstimation:()=>Ms,AutoModelForObjectDetection:()=>jc,AutoModelForPoseEstimation:()=>uu,AutoModelForQuestionAnswering:()=>gi,AutoModelForSemanticSegmentation:()=>ia,AutoModelForSeq2SeqLM:()=>Yd,AutoModelForSequenceClassification:()=>_i,AutoModelForSpeechSeq2Seq:()=>Jd,AutoModelForTextToSpectrogram:()=>Ya,AutoModelForTextToWaveform:()=>Ln,AutoModelForTokenClassification:()=>An,AutoModelForUniversalSegmentation:()=>Ja,AutoModelForVision2Seq:()=>iu,AutoModelForXVector:()=>lu,AutoModelForZeroShotObjectDetection:()=>Nc,BartForConditionalGeneration:()=>De,BartForSequenceClassification:()=>Ge,BartModel:()=>Ie,BartPretrainedModel:()=>we,BaseModelOutput:()=>Je,BeitForImageClassification:()=>Ad,BeitModel:()=>Ju,BeitPreTrainedModel:()=>Yu,BertForMaskedLM:()=>Re,BertForQuestionAnswering:()=>st,BertForSequenceClassification:()=>lt,BertForTokenClassification:()=>ot,BertModel:()=>be,BertPreTrainedModel:()=>We,BlenderbotForConditionalGeneration:()=>Fr,BlenderbotModel:()=>ar,BlenderbotPreTrainedModel:()=>xr,BlenderbotSmallForConditionalGeneration:()=>fn,BlenderbotSmallModel:()=>hr,BlenderbotSmallPreTrainedModel:()=>Ht,BloomForCausalLM:()=>Ea,BloomModel:()=>Bu,BloomPreTrainedModel:()=>wr,CLIPModel:()=>ad,CLIPPreTrainedModel:()=>ks,CLIPSegForImageSegmentation:()=>md,CLIPSegModel:()=>hd,CLIPSegPreTrainedModel:()=>fl,CLIPTextModel:()=>mo,CLIPTextModelWithProjection:()=>ul,CLIPVisionModel:()=>va,CLIPVisionModelWithProjection:()=>Ma,CamembertForMaskedLM:()=>Pn,CamembertForQuestionAnswering:()=>Ps,CamembertForSequenceClassification:()=>Ns,CamembertForTokenClassification:()=>Us,CamembertModel:()=>an,CamembertPreTrainedModel:()=>rn,CausalLMOutput:()=>Po,CausalLMOutputWithPast:()=>Hc,ChineseCLIPModel:()=>dd,ChineseCLIPPreTrainedModel:()=>dl,ClapAudioModelWithProjection:()=>Wl,ClapModel:()=>ls,ClapPreTrainedModel:()=>as,ClapTextModelWithProjection:()=>Ua,CodeGenForCausalLM:()=>Pu,CodeGenModel:()=>Eu,CodeGenPreTrainedModel:()=>yl,CohereForCausalLM:()=>Ml,CohereModel:()=>vl,CoherePreTrainedModel:()=>Ta,ConvBertForMaskedLM:()=>Ne,ConvBertForQuestionAnswering:()=>gt,ConvBertForSequenceClassification:()=>at,ConvBertForTokenClassification:()=>ct,ConvBertModel:()=>xe,ConvBertPreTrainedModel:()=>Z,ConvNextForImageClassification:()=>$n,ConvNextModel:()=>Ia,ConvNextPreTrainedModel:()=>$a,ConvNextV2ForImageClassification:()=>ws,ConvNextV2Model:()=>Kr,ConvNextV2PreTrainedModel:()=>Gn,DPTForDepthEstimation:()=>nn,DPTModel:()=>Mo,DPTPreTrainedModel:()=>si,DebertaForMaskedLM:()=>fs,DebertaForQuestionAnswering:()=>Io,DebertaForSequenceClassification:()=>Vs,DebertaForTokenClassification:()=>so,DebertaModel:()=>Gt,DebertaPreTrainedModel:()=>Bn,DebertaV2ForMaskedLM:()=>io,DebertaV2ForQuestionAnswering:()=>Cn,DebertaV2ForSequenceClassification:()=>hs,DebertaV2ForTokenClassification:()=>Cs,DebertaV2Model:()=>oo,DebertaV2PreTrainedModel:()=>ts,DecisionTransformerModel:()=>bc,DecisionTransformerPreTrainedModel:()=>Tc,DeiTForImageClassification:()=>ri,DeiTModel:()=>Ol,DeiTPreTrainedModel:()=>Wi,DepthAnythingForDepthEstimation:()=>Ki,DepthAnythingPreTrainedModel:()=>Gi,DepthProForDepthEstimation:()=>qi,DepthProPreTrainedModel:()=>To,DetrForObjectDetection:()=>go,DetrForSegmentation:()=>Al,DetrModel:()=>Il,DetrObjectDetectionOutput:()=>Zo,DetrPreTrainedModel:()=>ka,DetrSegmentationOutput:()=>As,Dinov2ForImageClassification:()=>tc,Dinov2Model:()=>ec,Dinov2PreTrainedModel:()=>Ll,DistilBertForMaskedLM:()=>ao,DistilBertForQuestionAnswering:()=>Ws,DistilBertForSequenceClassification:()=>jt,DistilBertForTokenClassification:()=>ln,DistilBertModel:()=>Pt,DistilBertPreTrainedModel:()=>dt,DonutSwinModel:()=>Ld,DonutSwinPreTrainedModel:()=>jo,EfficientNetForImageClassification:()=>Wa,EfficientNetModel:()=>gc,EfficientNetPreTrainedModel:()=>mi,ElectraForMaskedLM:()=>St,ElectraForQuestionAnswering:()=>Cr,ElectraForSequenceClassification:()=>Ft,ElectraForTokenClassification:()=>gr,ElectraModel:()=>$t,ElectraPreTrainedModel:()=>zt,EsmForMaskedLM:()=>zr,EsmForSequenceClassification:()=>Ss,EsmForTokenClassification:()=>Sr,EsmModel:()=>rs,EsmPreTrainedModel:()=>Dr,FalconForCausalLM:()=>fc,FalconModel:()=>Vl,FalconPreTrainedModel:()=>Na,FastViTForImageClassification:()=>qu,FastViTModel:()=>Bi,FastViTPreTrainedModel:()=>zi,Florence2ForConditionalGeneration:()=>Un,Florence2PreTrainedModel:()=>qo,GLPNForDepthEstimation:()=>Js,GLPNModel:()=>ys,GLPNPreTrainedModel:()=>Ys,GPT2LMHeadModel:()=>hl,GPT2Model:()=>_d,GPT2PreTrainedModel:()=>Mu,GPTBigCodeForCausalLM:()=>bu,GPTBigCodeModel:()=>Md,GPTBigCodePreTrainedModel:()=>Qo,GPTJForCausalLM:()=>gl,GPTJModel:()=>vd,GPTJPreTrainedModel:()=>Tu,GPTNeoForCausalLM:()=>ml,GPTNeoModel:()=>yd,GPTNeoPreTrainedModel:()=>ss,GPTNeoXForCausalLM:()=>wd,GPTNeoXModel:()=>Is,GPTNeoXPreTrainedModel:()=>_l,Gemma2ForCausalLM:()=>Pd,Gemma2Model:()=>Ed,Gemma2PreTrainedModel:()=>Au,GemmaForCausalLM:()=>Iu,GemmaModel:()=>bd,GemmaPreTrainedModel:()=>ba,GraniteForCausalLM:()=>$u,GraniteModel:()=>xa,GranitePreTrainedModel:()=>ku,GroupViTModel:()=>Pl,GroupViTPreTrainedModel:()=>Gr,HieraForImageClassification:()=>Ur,HieraModel:()=>Zr,HieraPreTrainedModel:()=>Qs,HubertForCTC:()=>Zi,HubertForSequenceClassification:()=>Vo,HubertModel:()=>za,HubertPreTrainedModel:()=>ro,ImageMattingOutput:()=>cs,JAISLMHeadModel:()=>fp,JAISModel:()=>gd,JAISPreTrainedModel:()=>xu,JinaCLIPModel:()=>$s,JinaCLIPPreTrainedModel:()=>pl,JinaCLIPTextModel:()=>pd,JinaCLIPVisionModel:()=>fd,LlamaForCausalLM:()=>xd,LlamaModel:()=>Xo,LlamaPreTrainedModel:()=>os,LlavaForConditionalGeneration:()=>Lo,LlavaOnevisionForConditionalGeneration:()=>vu,LlavaPreTrainedModel:()=>wa,LongT5ForConditionalGeneration:()=>kr,LongT5Model:()=>ya,LongT5PreTrainedModel:()=>Ks,M2M100ForConditionalGeneration:()=>Rl,M2M100Model:()=>No,M2M100PreTrainedModel:()=>Xi,MBartForCausalLM:()=>Zt,MBartForConditionalGeneration:()=>yt,MBartForSequenceClassification:()=>kt,MBartModel:()=>bt,MBartPreTrainedModel:()=>mt,MPNetForMaskedLM:()=>Yr,MPNetForQuestionAnswering:()=>ms,MPNetForSequenceClassification:()=>il,MPNetForTokenClassification:()=>Gs,MPNetModel:()=>ma,MPNetPreTrainedModel:()=>uo,MT5ForConditionalGeneration:()=>ne,MT5Model:()=>I,MT5PreTrainedModel:()=>Oe,MarianMTModel:()=>nc,MarianModel:()=>li,MarianPreTrainedModel:()=>ai,MaskFormerForInstanceSegmentation:()=>is,MaskFormerModel:()=>Wn,MaskFormerPreTrainedModel:()=>Qi,MaskedLMOutput:()=>bn,MgpstrForSceneTextRecognition:()=>us,MgpstrModelOutput:()=>Ud,MgpstrPreTrainedModel:()=>Vd,MistralForCausalLM:()=>ja,MistralModel:()=>Ra,MistralPreTrainedModel:()=>mn,MobileBertForMaskedLM:()=>ha,MobileBertForQuestionAnswering:()=>Ci,MobileBertForSequenceClassification:()=>Pi,MobileBertModel:()=>Ei,MobileBertPreTrainedModel:()=>lo,MobileLLMForCausalLM:()=>Su,MobileLLMModel:()=>Td,MobileLLMPreTrainedModel:()=>Cu,MobileNetV1ForImageClassification:()=>Bd,MobileNetV1Model:()=>wc,MobileNetV1PreTrainedModel:()=>Ql,MobileNetV2ForImageClassification:()=>Mc,MobileNetV2Model:()=>vc,MobileNetV2PreTrainedModel:()=>xn,MobileNetV3ForImageClassification:()=>ta,MobileNetV3Model:()=>Rd,MobileNetV3PreTrainedModel:()=>Ga,MobileNetV4ForImageClassification:()=>Xl,MobileNetV4Model:()=>jd,MobileNetV4PreTrainedModel:()=>xc,MobileViTForImageClassification:()=>Qu,MobileViTModel:()=>Jo,MobileViTPreTrainedModel:()=>ji,MobileViTV2ForImageClassification:()=>Sl,MobileViTV2Model:()=>Id,MobileViTV2PreTrainedModel:()=>Xu,ModelOutput:()=>Ve,Moondream1ForConditionalGeneration:()=>Xn,MptForCausalLM:()=>Ru,MptModel:()=>Tl,MptPreTrainedModel:()=>Bo,MultiModalityCausalLM:()=>Nd,MultiModalityPreTrainedModel:()=>ra,MusicgenForCausalLM:()=>yc,MusicgenForConditionalGeneration:()=>ql,MusicgenModel:()=>mp,MusicgenPreTrainedModel:()=>ea,NomicBertModel:()=>pt,NomicBertPreTrainedModel:()=>Xe,OPTForCausalLM:()=>Nu,OPTModel:()=>ju,OPTPreTrainedModel:()=>Li,OlmoForCausalLM:()=>Ai,OlmoModel:()=>Ii,OlmoPreTrainedModel:()=>wl,OpenELMForCausalLM:()=>_s,OpenELMModel:()=>Cd,OpenELMPreTrainedModel:()=>Fi,OwlViTForObjectDetection:()=>Ca,OwlViTModel:()=>Ui,OwlViTPreTrainedModel:()=>Ni,Owlv2ForObjectDetection:()=>$l,Owlv2Model:()=>kl,Owlv2PreTrainedModel:()=>Sa,PatchTSMixerForPrediction:()=>qa,PatchTSMixerModel:()=>Wd,PatchTSMixerPreTrainedModel:()=>Jl,PatchTSTForPrediction:()=>Yl,PatchTSTModel:()=>Ha,PatchTSTPreTrainedModel:()=>Ka,Phi3ForCausalLM:()=>Oi,Phi3Model:()=>zu,Phi3PreTrainedModel:()=>zo,PhiForCausalLM:()=>kd,PhiModel:()=>Sd,PhiPreTrainedModel:()=>xl,PreTrainedModel:()=>he,PretrainedMixin:()=>vr,PvtForImageClassification:()=>$d,PvtModel:()=>Yo,PvtPreTrainedModel:()=>Pa,PyAnnoteForAudioFrameClassification:()=>ui,PyAnnoteModel:()=>oc,PyAnnotePreTrainedModel:()=>Oa,QuestionAnsweringModelOutput:()=>Dn,Qwen2ForCausalLM:()=>Ou,Qwen2Model:()=>Fu,Qwen2PreTrainedModel:()=>Do,Qwen2VLForConditionalGeneration:()=>Du,Qwen2VLPreTrainedModel:()=>Lu,RTDetrForObjectDetection:()=>Fl,RTDetrModel:()=>yn,RTDetrObjectDetectionOutput:()=>Fd,RTDetrPreTrainedModel:()=>ei,ResNetForImageClassification:()=>Vn,ResNetModel:()=>kn,ResNetPreTrainedModel:()=>Xs,RoFormerForMaskedLM:()=>wt,RoFormerForQuestionAnswering:()=>_e,RoFormerForSequenceClassification:()=>vt,RoFormerForTokenClassification:()=>U,RoFormerModel:()=>Et,RoFormerPreTrainedModel:()=>_t,RobertaForMaskedLM:()=>mr,RobertaForQuestionAnswering:()=>Nn,RobertaForSequenceClassification:()=>Mn,RobertaForTokenClassification:()=>Qn,RobertaModel:()=>Qe,RobertaPreTrainedModel:()=>Nr,SamImageSegmentationOutput:()=>Dd,SamModel:()=>Bl,SamPreTrainedModel:()=>ii,SapiensForDepthEstimation:()=>xo,SapiensForNormalEstimation:()=>oi,SapiensForSemanticSegmentation:()=>Od,SapiensPreTrainedModel:()=>Hi,SegformerForImageClassification:()=>hc,SegformerForSemanticSegmentation:()=>mc,SegformerModel:()=>hp,SegformerPreTrainedModel:()=>Va,Seq2SeqLMOutput:()=>_p,SequenceClassifierOutput:()=>lr,SiglipModel:()=>ld,SiglipPreTrainedModel:()=>cl,SiglipTextModel:()=>ud,SiglipVisionModel:()=>cd,SpeechT5ForSpeechToText:()=>Ba,SpeechT5ForTextToSpeech:()=>Ul,SpeechT5HifiGan:()=>Ko,SpeechT5Model:()=>dc,SpeechT5PreTrainedModel:()=>fi,SqueezeBertForMaskedLM:()=>Ao,SqueezeBertForQuestionAnswering:()=>jn,SqueezeBertForSequenceClassification:()=>co,SqueezeBertModel:()=>Si,SqueezeBertPreTrainedModel:()=>Rn,StableLmForCausalLM:()=>zd,StableLmModel:()=>_c,StableLmPreTrainedModel:()=>Hl,Starcoder2ForCausalLM:()=>In,Starcoder2Model:()=>pc,Starcoder2PreTrainedModel:()=>hi,Swin2SRForImageSuperResolution:()=>vo,Swin2SRModel:()=>wo,Swin2SRPreTrainedModel:()=>gs,SwinForImageClassification:()=>Yn,SwinModel:()=>ni,SwinPreTrainedModel:()=>yo,T5ForConditionalGeneration:()=>ho,T5Model:()=>Fo,T5PreTrainedModel:()=>fo,TableTransformerForObjectDetection:()=>Vi,TableTransformerModel:()=>Ro,TableTransformerObjectDetectionOutput:()=>ti,TableTransformerPreTrainedModel:()=>Zu,TokenClassifierOutput:()=>wn,TrOCRForCausalLM:()=>hn,TrOCRPreTrainedModel:()=>en,UniSpeechForCTC:()=>Zs,UniSpeechForSequenceClassification:()=>eo,UniSpeechModel:()=>ic,UniSpeechPreTrainedModel:()=>Yi,UniSpeechSatForAudioFrameClassification:()=>La,UniSpeechSatForCTC:()=>to,UniSpeechSatForSequenceClassification:()=>bo,UniSpeechSatModel:()=>ac,UniSpeechSatPreTrainedModel:()=>di,ViTForImageClassification:()=>Vu,ViTMAEModel:()=>Di,ViTMAEPreTrainedModel:()=>El,ViTMSNForImageClassification:()=>Hu,ViTMSNModel:()=>Ku,ViTMSNPreTrainedModel:()=>Gu,ViTModel:()=>Uu,ViTPreTrainedModel:()=>bl,VisionEncoderDecoderModel:()=>or,VitMatteForImageMatting:()=>Ri,VitMattePreTrainedModel:()=>Cl,VitPoseForPoseEstimation:()=>_o,VitPosePreTrainedModel:()=>Wu,VitsModel:()=>Kl,VitsModelOutput:()=>Tr,VitsPreTrainedModel:()=>Gl,Wav2Vec2BertForCTC:()=>lc,Wav2Vec2BertForSequenceClassification:()=>Ji,Wav2Vec2BertModel:()=>Nl,Wav2Vec2BertPreTrainedModel:()=>Da,Wav2Vec2ForAudioFrameClassification:()=>jl,Wav2Vec2ForCTC:()=>Uo,Wav2Vec2ForSequenceClassification:()=>sc,Wav2Vec2Model:()=>Fa,Wav2Vec2PreTrainedModel:()=>Fs,WavLMForAudioFrameClassification:()=>Go,WavLMForCTC:()=>uc,WavLMForSequenceClassification:()=>cc,WavLMForXVector:()=>Hr,WavLMModel:()=>pi,WavLMPreTrainedModel:()=>Wo,WeSpeakerResNetModel:()=>ci,WeSpeakerResNetPreTrainedModel:()=>Jn,WhisperForConditionalGeneration:()=>Oo,WhisperModel:()=>ll,WhisperPreTrainedModel:()=>qs,XLMForQuestionAnswering:()=>Tt,XLMForSequenceClassification:()=>_r,XLMForTokenClassification:()=>$r,XLMModel:()=>gn,XLMPreTrainedModel:()=>qt,XLMRobertaForMaskedLM:()=>ns,XLMRobertaForQuestionAnswering:()=>$i,XLMRobertaForSequenceClassification:()=>Hs,XLMRobertaForTokenClassification:()=>Nt,XLMRobertaModel:()=>Jr,XLMRobertaPreTrainedModel:()=>Jt,XLMWithLMHeadModel:()=>Sn,XVectorOutput:()=>Kc,YolosForObjectDetection:()=>Dl,YolosModel:()=>rc,YolosObjectDetectionOutput:()=>zl,YolosPreTrainedModel:()=>Aa});var P=f("./src/configs.js"),R=f("./src/backends/onnx.js"),Q=f("./src/utils/dtypes.js"),se=f("./src/utils/generic.js"),oe=f("./src/utils/core.js"),E=f("./src/utils/hub.js"),C=f("./src/utils/constants.js"),k=f("./src/generation/logits_process.js"),A=f("./src/generation/configuration_utils.js"),$=f("./src/utils/tensor.js"),ae=f("./src/utils/image.js"),fe=f("./src/utils/maths.js"),ge=f("./src/generation/stopping_criteria.js"),le=f("./src/generation/logits_sampler.js"),q=f("./src/env.js"),ie=f("./src/models/whisper/generation_whisper.js"),pe=f("./src/models/whisper/common_whisper.js");const X={EncoderOnly:0,EncoderDecoder:1,Seq2Seq:2,Vision2Seq:3,DecoderOnly:4,MaskGeneration:5,ImageTextToText:6,Musicgen:7,MultiModality:8},W=new Map,b=new Map,z=new Map;async function L(T,O,G){var br;const $e=((br=G.config)==null?void 0:br["transformers.js_config"])??{};let Ue=G.device??$e.device;Ue&&typeof Ue!="string"&&(Ue.hasOwnProperty(O)?Ue=Ue[O]:(console.warn(`device not specified for "${O}". Using the default device.`),Ue=null));const ze=Ue??(q.apis.IS_NODE_ENV?"cpu":"wasm"),rt=(0,R.deviceToExecutionProviders)(ze);let ut=G.dtype??$e.dtype;typeof ut!="string"&&(ut&&ut.hasOwnProperty(O)?ut=ut[O]:(ut=Q.DEFAULT_DEVICE_DTYPE_MAPPING[ze]??Q.DATA_TYPES.fp32,console.warn(`dtype not specified for "${O}". Using the default dtype (${ut}) for this device (${ze}).`)));const Mt=ut;if(Q.DEFAULT_DTYPE_SUFFIX_MAPPING.hasOwnProperty(Mt)){if(Mt===Q.DATA_TYPES.fp16&&ze==="webgpu"&&!await(0,Q.isWebGpuFp16Supported)())throw new Error(`The device (${ze}) does not support fp16.`)}else throw new Error(`Invalid dtype: ${Mt}. Should be one of: ${Object.keys(Q.DATA_TYPES).join(", ")}`);const At=$e.kv_cache_dtype?typeof $e.kv_cache_dtype=="string"?$e.kv_cache_dtype:$e.kv_cache_dtype[Mt]??"float32":void 0;if(At&&!["float32","float16"].includes(At))throw new Error(`Invalid kv_cache_dtype: ${At}. Should be one of: float32, float16`);const Kt={dtype:Mt,kv_cache_dtype:At},Ot=Q.DEFAULT_DTYPE_SUFFIX_MAPPING[Mt],Qt=`${G.subfolder??""}/${O}${Ot}.onnx`,Vt={...G.session_options};Vt.executionProviders??(Vt.executionProviders=rt);const nr=$e.free_dimension_overrides;nr?Vt.freeDimensionOverrides??(Vt.freeDimensionOverrides=nr):ze.startsWith("webnn")&&!Vt.freeDimensionOverrides&&console.warn('WebNN does not currently support dynamic shapes and requires `free_dimension_overrides` to be set in config.json as a field within "transformers.js_config". When `free_dimension_overrides` is not set, you may experience significant performance degradation.');const dr=(0,E.getModelFile)(T,Qt,!0,G),sr=G.use_external_data_format??$e.use_external_data_format;let pr=[];if(sr&&(sr===!0||typeof sr=="object"&&sr.hasOwnProperty(O)&&sr[O]===!0)){if(q.apis.IS_NODE_ENV)throw new Error("External data format is not yet supported in Node.js");const Br=`${O}${Ot}.onnx_data`,Or=`${G.subfolder??""}/${Br}`;pr.push(new Promise(async(qr,_n)=>{const un=await(0,E.getModelFile)(T,Or,!0,G);qr({path:Br,data:un})}))}else Vt.externalData!==void 0&&(pr=Vt.externalData.map(async Br=>{if(typeof Br.data=="string"){const Or=await(0,E.getModelFile)(T,Br.data,!0,G);return{...Br,data:Or}}return Br}));if(pr.length>0&&(Vt.externalData=await Promise.all(pr)),ze==="webgpu"){const Br=(0,P.getKeyValueShapes)(G.config,{prefix:"present"});if(Object.keys(Br).length>0&&!(0,R.isONNXProxy)()){const Or={};for(const qr in Br)Or[qr]="gpu-buffer";Vt.preferredOutputLocation=Or}}return{buffer:await dr,session_options:Vt,session_config:Kt}}async function de(T,O,G){return Object.fromEntries(await Promise.all(Object.keys(O).map(async $e=>{const{buffer:Ue,session_options:ze,session_config:rt}=await L(T,O[$e],G),ut=await(0,R.createInferenceSession)(Ue,ze,rt);return[$e,ut]})))}async function ce(T,O,G){return Object.fromEntries(await Promise.all(Object.keys(O).map(async $e=>{const Ue=await(0,E.getModelJSON)(T,O[$e],!1,G);return[$e,Ue]})))}function Pe(T,O){const G=Object.create(null),$e=[];for(const rt of T.inputNames){const ut=O[rt];if(!(ut instanceof $.Tensor)){$e.push(rt);continue}G[rt]=(0,R.isONNXProxy)()?ut.clone():ut}if($e.length>0)throw new Error(`An error occurred during model execution: "Missing the following inputs: ${$e.join(", ")}.`);const Ue=Object.keys(O).length,ze=T.inputNames.length;if(Ue>ze){let rt=Object.keys(O).filter(ut=>!T.inputNames.includes(ut));console.warn(`WARNING: Too many inputs were provided (${Ue} > ${ze}). The following inputs will be ignored: "${rt.join(", ")}".`)}return G}async function Ee(T,O){const G=Pe(T,O);try{const $e=Object.fromEntries(Object.entries(G).map(([ze,rt])=>[ze,rt.ort_tensor]));let Ue=await T.run($e);return Ue=Se(Ue),Ue}catch($e){throw console.error(`An error occurred during model execution: "${$e}".`),console.error("Inputs given to model:",G),$e}}function Se(T){for(let O in T)(0,R.isONNXTensor)(T[O])?T[O]=new $.Tensor(T[O]):typeof T[O]=="object"&&Se(T[O]);return T}function Be(T){if(T instanceof $.Tensor)return T;if(T.length===0)throw Error("items must be non-empty");if(Array.isArray(T[0])){if(T.some(O=>O.length!==T[0].length))throw Error("Unable to create tensor, you should probably activate truncation and/or padding with 'padding=True' and/or 'truncation=True' to have batched tensors with the same length.");return new $.Tensor("int64",BigInt64Array.from(T.flat().map(O=>BigInt(O))),[T.length,T[0].length])}else return new $.Tensor("int64",BigInt64Array.from(T.map(O=>BigInt(O))),[1,T.length])}function Le(T){return new $.Tensor("bool",[T],[1])}async function He(T,O){let{encoder_outputs:G,input_ids:$e,decoder_input_ids:Ue,...ze}=O;if(!G){const ut=(0,oe.pick)(O,T.sessions.model.inputNames);G=(await Me(T,ut)).last_hidden_state}return ze.input_ids=Ue,ze.encoder_hidden_states=G,T.sessions.decoder_model_merged.inputNames.includes("encoder_attention_mask")&&(ze.encoder_attention_mask=O.attention_mask),await N(T,ze,!0)}async function Me(T,O){const G=T.sessions.model,$e=(0,oe.pick)(O,G.inputNames);if(G.inputNames.includes("inputs_embeds")&&!$e.inputs_embeds){if(!O.input_ids)throw new Error("Both `input_ids` and `inputs_embeds` are missing in the model inputs.");$e.inputs_embeds=await T.encode_text({input_ids:O.input_ids})}return G.inputNames.includes("token_type_ids")&&!$e.token_type_ids&&($e.token_type_ids=new $.Tensor("int64",new BigInt64Array($e.input_ids.data.length),$e.input_ids.dims)),await Ee(G,$e)}async function N(T,O,G=!1){const $e=T.sessions[G?"decoder_model_merged":"model"],{past_key_values:Ue,...ze}=O;$e.inputNames.includes("use_cache_branch")&&(ze.use_cache_branch=Le(!!Ue)),$e.inputNames.includes("position_ids")&&ze.attention_mask&&!ze.position_ids&&(ze.position_ids=ee(ze,Ue)),T.addPastKeyValues(ze,Ue);const rt=(0,oe.pick)(ze,$e.inputNames);return await Ee($e,rt)}async function me(T,{input_ids:O=null,attention_mask:G=null,pixel_values:$e=null,position_ids:Ue=null,inputs_embeds:ze=null,past_key_values:rt=null,generation_config:ut=null,logits_processor:Mt=null,...At}){if(!ze){if(ze=await T.encode_text({input_ids:O,...At}),$e&&O.dims[1]!==1){const Ot=await T.encode_image({pixel_values:$e,...At});({inputs_embeds:ze,attention_mask:G}=T._merge_input_ids_with_image_features({image_features:Ot,inputs_embeds:ze,input_ids:O,attention_mask:G}))}else if(rt&&$e&&O.dims[1]===1){const Ot=O.dims[1],Qt=Object.values(rt)[0].dims.at(-2);G=(0,$.cat)([(0,$.ones)([O.dims[0],Qt]),G.slice(null,[G.dims[1]-Ot,G.dims[1]])],1)}}if(!Ue&&T.config.model_type==="qwen2_vl"){const{image_grid_thw:Ot,video_grid_thw:Qt}=At;[Ue]=T.get_rope_index(O,Ot,Qt,G)}return await N(T,{inputs_embeds:ze,past_key_values:rt,attention_mask:G,position_ids:Ue,generation_config:ut,logits_processor:Mt},!0)}function ue(T){const[O,G]=T.dims,$e=T.data,Ue=new BigInt64Array($e.length);for(let ze=0;ze<O;++ze){const rt=ze*G;let ut=BigInt(0);for(let Mt=0;Mt<G;++Mt){const At=rt+Mt;$e[At]===0n?Ue[At]=BigInt(1):(Ue[At]=ut,ut+=$e[At])}}return{data:Ue,dims:T.dims}}function ee(T,O=null){const{input_ids:G,inputs_embeds:$e,attention_mask:Ue}=T,{data:ze,dims:rt}=ue(Ue);let ut=new $.Tensor("int64",ze,rt);if(O){const Mt=-(G??$e).dims.at(1);ut=ut.slice(null,[Mt,null])}return ut}function Te(T,O,G,$e){if(G.past_key_values){const Ue=Object.values(G.past_key_values)[0].dims.at(-2),{input_ids:ze,attention_mask:rt}=G;if(!(rt&&rt.dims[1]>ze.dims[1])){if(Ue<ze.dims[1])G.input_ids=ze.slice(null,[Ue,null]);else if(T.config.image_token_index!=null&&ze.data.some(ut=>ut==T.config.image_token_index)){const ut=T.config.num_image_tokens;if(!ut)throw new Error("`num_image_tokens` is missing in the model configuration.");const Mt=ze.dims[1]-(Ue-ut);G.input_ids=ze.slice(null,[-Mt,null]),G.attention_mask=(0,$.ones)([1,Ue+Mt])}}}return G}function je(T,O,G,$e){return G.past_key_values&&(O=O.map(Ue=>[Ue.at(-1)])),{...G,decoder_input_ids:Be(O)}}function qe(T,...O){return T.config.is_encoder_decoder?je(T,...O):Te(T,...O)}function tt(T,O,G,$e){const Ue=!!G.past_key_values;return $e.guidance_scale!==null&&$e.guidance_scale>1&&(Ue?G.input_ids=(0,$.cat)([G.input_ids,G.input_ids],0):(G.input_ids=(0,$.cat)([G.input_ids,(0,$.full_like)(G.input_ids,BigInt($e.pad_token_id))],0),G.attention_mask=(0,$.cat)([G.attention_mask,(0,$.full_like)(G.attention_mask,0n)],0))),(Ue||!G.pixel_values)&&(G.pixel_values=(0,$.full)([0,0,3,384,384],1)),Ue&&(G.images_seq_mask=new $.Tensor("bool",new Array(1).fill(!0).fill(!1,0,1),[1,1]),G.images_emb_mask=new $.Tensor("bool",new Array(0).fill(!1),[1,1,0])),G}class he extends se.Callable{constructor(G,$e,Ue){super();Fe(this,"main_input_name","input_ids");Fe(this,"forward_params",["input_ids","attention_mask"]);this.config=G,this.sessions=$e,this.configs=Ue;const ze=z.get(this.constructor),rt=W.get(ze);switch(this.can_generate=!1,this._forward=null,this._prepare_inputs_for_generation=null,rt){case X.DecoderOnly:this.can_generate=!0,this._forward=N,this._prepare_inputs_for_generation=Te;break;case X.Seq2Seq:case X.Vision2Seq:case X.Musicgen:this.can_generate=!0,this._forward=He,this._prepare_inputs_for_generation=je;break;case X.EncoderDecoder:this._forward=He;break;case X.ImageTextToText:this.can_generate=!0,this._forward=me,this._prepare_inputs_for_generation=qe;break;case X.MultiModality:this.can_generate=!0,this._prepare_inputs_for_generation=tt;break;default:this._forward=Me;break}this.can_generate&&this.forward_params.push("past_key_values"),this.custom_config=this.config["transformers.js_config"]??{}}async dispose(){var $e;const G=[];for(const Ue of Object.values(this.sessions))($e=Ue==null?void 0:Ue.handler)!=null&&$e.dispose&&G.push(Ue.handler.dispose());return await Promise.all(G)}static async from_pretrained(G,{progress_callback:$e=null,config:Ue=null,cache_dir:ze=null,local_files_only:rt=!1,revision:ut="main",model_file_name:Mt=null,subfolder:At="onnx",device:Kt=null,dtype:Ot=null,use_external_data_format:Qt=null,session_options:Vt={}}={}){let nr={progress_callback:$e,config:Ue,cache_dir:ze,local_files_only:rt,revision:ut,model_file_name:Mt,subfolder:At,device:Kt,dtype:Ot,use_external_data_format:Qt,session_options:Vt};const dr=z.get(this),sr=W.get(dr);Ue=nr.config=await P.AutoConfig.from_pretrained(G,nr);let pr;if(sr===X.DecoderOnly)pr=await Promise.all([de(G,{model:nr.model_file_name??"model"},nr),ce(G,{generation_config:"generation_config.json"},nr)]);else if(sr===X.Seq2Seq||sr===X.Vision2Seq)pr=await Promise.all([de(G,{model:"encoder_model",decoder_model_merged:"decoder_model_merged"},nr),ce(G,{generation_config:"generation_config.json"},nr)]);else if(sr===X.MaskGeneration)pr=await Promise.all([de(G,{model:"vision_encoder",prompt_encoder_mask_decoder:"prompt_encoder_mask_decoder"},nr)]);else if(sr===X.EncoderDecoder)pr=await Promise.all([de(G,{model:"encoder_model",decoder_model_merged:"decoder_model_merged"},nr)]);else if(sr===X.ImageTextToText){const sn={embed_tokens:"embed_tokens",vision_encoder:"vision_encoder",decoder_model_merged:"decoder_model_merged"};Ue.is_encoder_decoder&&(sn.model="encoder_model"),pr=await Promise.all([de(G,sn,nr),ce(G,{generation_config:"generation_config.json"},nr)])}else sr===X.Musicgen?pr=await Promise.all([de(G,{model:"text_encoder",decoder_model_merged:"decoder_model_merged",encodec_decode:"encodec_decode"},nr),ce(G,{generation_config:"generation_config.json"},nr)]):sr===X.MultiModality?pr=await Promise.all([de(G,{prepare_inputs_embeds:"prepare_inputs_embeds",model:"language_model",lm_head:"lm_head",gen_head:"gen_head",gen_img_embeds:"gen_img_embeds",image_decode:"image_decode"},nr),ce(G,{generation_config:"generation_config.json"},nr)]):(sr!==X.EncoderOnly&&console.warn(`Model type for '${dr??(Ue==null?void 0:Ue.model_type)}' not found, assuming encoder-only architecture. Please report this at ${C.GITHUB_ISSUE_URL}.`),pr=await Promise.all([de(G,{model:nr.model_file_name??"model"},nr)]));return new this(Ue,...pr)}async _call(G){return await this.forward(G)}async forward(G){return await this._forward(this,G)}get generation_config(){var G;return((G=this.configs)==null?void 0:G.generation_config)??null}_get_logits_warper(G){const $e=new k.LogitsProcessorList;return G.temperature!==null&&G.temperature!==1&&$e.push(new k.TemperatureLogitsWarper(G.temperature)),G.top_k!==null&&G.top_k!==0&&$e.push(new k.TopKLogitsWarper(G.top_k)),G.top_p!==null&&G.top_p<1&&$e.push(new k.TopPLogitsWarper(G.top_p)),$e}_get_logits_processor(G,$e,Ue=null){const ze=new k.LogitsProcessorList;if(G.repetition_penalty!==null&&G.repetition_penalty!==1&&ze.push(new k.RepetitionPenaltyLogitsProcessor(G.repetition_penalty)),G.no_repeat_ngram_size!==null&&G.no_repeat_ngram_size>0&&ze.push(new k.NoRepeatNGramLogitsProcessor(G.no_repeat_ngram_size)),G.bad_words_ids!==null&&ze.push(new k.NoBadWordsLogitsProcessor(G.bad_words_ids,G.eos_token_id)),G.min_length!==null&&G.eos_token_id!==null&&G.min_length>0&&ze.push(new k.MinLengthLogitsProcessor(G.min_length,G.eos_token_id)),G.min_new_tokens!==null&&G.eos_token_id!==null&&G.min_new_tokens>0&&ze.push(new k.MinNewTokensLengthLogitsProcessor($e,G.min_new_tokens,G.eos_token_id)),G.forced_bos_token_id!==null&&ze.push(new k.ForcedBOSTokenLogitsProcessor(G.forced_bos_token_id)),G.forced_eos_token_id!==null&&ze.push(new k.ForcedEOSTokenLogitsProcessor(G.max_length,G.forced_eos_token_id)),G.begin_suppress_tokens!==null){const rt=$e>1||G.forced_bos_token_id===null?$e:$e+1;ze.push(new k.SuppressTokensAtBeginLogitsProcessor(G.begin_suppress_tokens,rt))}return G.guidance_scale!==null&&G.guidance_scale>1&&ze.push(new k.ClassifierFreeGuidanceLogitsProcessor(G.guidance_scale)),Ue!==null&&ze.extend(Ue),ze}_prepare_generation_config(G,$e,Ue=A.GenerationConfig){const ze={...this.config};for(const ut of["decoder","generator","text_config"])ut in ze&&Object.assign(ze,ze[ut]);const rt=new Ue(ze);return Object.assign(rt,this.generation_config??{}),G&&Object.assign(rt,G),$e&&Object.assign(rt,(0,oe.pick)($e,Object.getOwnPropertyNames(rt))),rt}_get_stopping_criteria(G,$e=null){const Ue=new ge.StoppingCriteriaList;return G.max_length!==null&&Ue.push(new ge.MaxLengthCriteria(G.max_length,this.config.max_position_embeddings??null)),G.eos_token_id!==null&&Ue.push(new ge.EosTokenCriteria(G.eos_token_id)),$e&&Ue.extend($e),Ue}_validate_model_class(){if(!this.can_generate){const G=[On,eu,$c,Zl],$e=z.get(this.constructor),Ue=new Set,ze=this.config.model_type;for(const ut of G){const Mt=ut.get(ze);Mt&&Ue.add(Mt[0])}let rt=`The current model class (${$e}) is not compatible with \`.generate()\`, as it doesn't have a language model head.`;throw Ue.size>0&&(rt+=` Please use the following class instead: ${[...Ue].join(", ")}`),Error(rt)}}prepare_inputs_for_generation(...G){return this._prepare_inputs_for_generation(this,...G)}_update_model_kwargs_for_generation({generated_input_ids:G,outputs:$e,model_inputs:Ue,is_encoder_decoder:ze}){return Ue.past_key_values=this.getPastKeyValues($e,Ue.past_key_values),Ue.input_ids=new $.Tensor("int64",G.flat(),[G.length,1]),ze||(Ue.attention_mask=(0,$.cat)([Ue.attention_mask,(0,$.ones)([Ue.attention_mask.dims[0],1])],1)),Ue.position_ids=null,Ue}_prepare_model_inputs({inputs:G,bos_token_id:$e,model_kwargs:Ue}){const ze=(0,oe.pick)(Ue,this.forward_params),rt=this.main_input_name;if(rt in ze){if(G)throw new Error("`inputs`: {inputs}` were passed alongside {input_name} which is not allowed. Make sure to either pass {inputs} or {input_name}=...")}else ze[rt]=G;return{inputs_tensor:ze[rt],model_inputs:ze,model_input_name:rt}}async _prepare_encoder_decoder_kwargs_for_generation({inputs_tensor:G,model_inputs:$e,model_input_name:Ue,generation_config:ze}){if(this.sessions.model.inputNames.includes("inputs_embeds")&&!$e.inputs_embeds&&"_prepare_inputs_embeds"in this){const{input_ids:ut,pixel_values:Mt,attention_mask:At,...Kt}=$e,Ot=await this._prepare_inputs_embeds($e);$e={...Kt,...(0,oe.pick)(Ot,["inputs_embeds","attention_mask"])}}let{last_hidden_state:rt}=await Me(this,$e);if(ze.guidance_scale!==null&&ze.guidance_scale>1)rt=(0,$.cat)([rt,(0,$.full_like)(rt,0)],0),"attention_mask"in $e&&($e.attention_mask=(0,$.cat)([$e.attention_mask,(0,$.zeros_like)($e.attention_mask)],0));else if($e.decoder_input_ids){const ut=Be($e.decoder_input_ids).dims[0];if(ut!==rt.dims[0]){if(rt.dims[0]!==1)throw new Error(`The encoder outputs have a different batch size (${rt.dims[0]}) than the decoder inputs (${ut}).`);rt=(0,$.cat)(Array.from({length:ut},()=>rt),0)}}return $e.encoder_outputs=rt,$e}_prepare_decoder_input_ids_for_generation({batch_size:G,model_input_name:$e,model_kwargs:Ue,decoder_start_token_id:ze,bos_token_id:rt,generation_config:ut}){let{decoder_input_ids:Mt,...At}=Ue;if(!(Mt instanceof $.Tensor)){if(Mt)Array.isArray(Mt[0])||(Mt=Array.from({length:G},()=>Mt));else if(ze??(ze=rt),this.config.model_type==="musicgen")Mt=Array.from({length:G*this.config.decoder.num_codebooks},()=>[ze]);else if(Array.isArray(ze)){if(ze.length!==G)throw new Error(`\`decoder_start_token_id\` expcted to have length ${G} but got ${ze.length}`);Mt=ze}else Mt=Array.from({length:G},()=>[ze]);Mt=Be(Mt)}return Ue.decoder_attention_mask=(0,$.ones_like)(Mt),{input_ids:Mt,model_inputs:At}}async generate({inputs:G=null,generation_config:$e=null,logits_processor:Ue=null,stopping_criteria:ze=null,streamer:rt=null,...ut}){this._validate_model_class(),$e=this._prepare_generation_config($e,ut);let{inputs_tensor:Mt,model_inputs:At,model_input_name:Kt}=this._prepare_model_inputs({inputs:G,model_kwargs:ut});const Ot=this.config.is_encoder_decoder;Ot&&("encoder_outputs"in At||(At=await this._prepare_encoder_decoder_kwargs_for_generation({inputs_tensor:Mt,model_inputs:At,model_input_name:Kt,generation_config:$e})));let Qt;Ot?{input_ids:Qt,model_inputs:At}=this._prepare_decoder_input_ids_for_generation({batch_size:At[Kt].dims.at(0),model_input_name:Kt,model_kwargs:At,decoder_start_token_id:$e.decoder_start_token_id,bos_token_id:$e.bos_token_id,generation_config:$e}):Qt=At[Kt];let Vt=Qt.dims.at(-1);$e.max_new_tokens!==null&&($e.max_length=Vt+$e.max_new_tokens);const nr=this._get_logits_processor($e,Vt,Ue),dr=this._get_stopping_criteria($e,ze),sr=At[Kt].dims.at(0),pr=le.LogitsSampler.getSampler($e),sn=new Array(sr).fill(0),br=Qt.tolist();rt&&rt.put(br);let Br,Or={};for(;;){if(At=this.prepare_inputs_for_generation(br,At,$e),Br=await this.forward(At),$e.output_attentions&&$e.return_dict_in_generate){const Qr=this.getAttentions(Br);for(const Ds in Qr)Ds in Or||(Or[Ds]=[]),Or[Ds].push(Qr[Ds])}const un=Br.logits.slice(null,-1,null),tn=nr(br,un),xs=[];for(let Qr=0;Qr<tn.dims.at(0);++Qr){const Ds=tn[Qr],cu=await pr(Ds);for(const[aa,qc]of cu){const zs=BigInt(aa);sn[Qr]+=qc,br[Qr].push(zs),xs.push([zs]);break}}if(rt&&rt.put(xs),dr(br).every(Qr=>Qr))break;At=this._update_model_kwargs_for_generation({generated_input_ids:xs,outputs:Br,model_inputs:At,is_encoder_decoder:Ot})}rt&&rt.end();const qr=this.getPastKeyValues(Br,At.past_key_values,!0),_n=new $.Tensor("int64",br.flat(),[br.length,br[0].length]);if($e.return_dict_in_generate)return{sequences:_n,past_key_values:qr,...Or};for(const un of Object.values(Br))un.location==="gpu-buffer"&&un.dispose();return _n}getPastKeyValues(G,$e,Ue=!1){const ze=Object.create(null);for(const rt in G)if(rt.startsWith("present")){const ut=rt.replace("present","past_key_values"),Mt=rt.includes("encoder");if(Mt&&$e?ze[ut]=$e[ut]:ze[ut]=G[rt],$e&&(!Mt||Ue)){const At=$e[ut];At.location==="gpu-buffer"&&At.dispose()}}return ze}getAttentions(G){const $e={};for(const Ue of["cross_attentions","encoder_attentions","decoder_attentions"])for(const ze in G)ze.startsWith(Ue)&&(Ue in $e||($e[Ue]=[]),$e[Ue].push(G[ze]));return $e}addPastKeyValues(G,$e){var Ue,ze;if($e)Object.assign(G,$e);else{const rt=this.sessions.decoder_model_merged??this.sessions.model,ut=((Ue=rt==null?void 0:rt.config)==null?void 0:Ue.kv_cache_dtype)??"float32",Mt=ut==="float16"?new Uint16Array:[],At=((ze=(G[this.main_input_name]??G.attention_mask).dims)==null?void 0:ze[0])??1,Kt=(0,P.getKeyValueShapes)(this.config,{batch_size:At});for(const Ot in Kt)G[Ot]=new $.Tensor(ut,Mt,Kt[Ot])}}async encode_image({pixel_values:G}){const $e=(await Ee(this.sessions.vision_encoder,{pixel_values:G})).image_features;return this.config.num_image_tokens||(console.warn(`The number of image tokens was not set in the model configuration. Setting it to the number of features detected by the vision encoder (${$e.dims[1]}).`),this.config.num_image_tokens=$e.dims[1]),$e}async encode_text({input_ids:G}){return(await Ee(this.sessions.embed_tokens,{input_ids:G})).inputs_embeds}}class Ve{}class Je extends Ve{constructor({last_hidden_state:O,hidden_states:G=null,attentions:$e=null}){super(),this.last_hidden_state=O,this.hidden_states=G,this.attentions=$e}}class We extends he{}class be extends We{}class Re extends We{async _call(O){return new bn(await super._call(O))}}class lt extends We{async _call(O){return new lr(await super._call(O))}}class ot extends We{async _call(O){return new wn(await super._call(O))}}class st extends We{async _call(O){return new Dn(await super._call(O))}}class Xe extends he{}class pt extends Xe{}class _t extends he{}class Et extends _t{}class wt extends _t{async _call(O){return new bn(await super._call(O))}}class vt extends _t{async _call(O){return new lr(await super._call(O))}}class U extends _t{async _call(O){return new wn(await super._call(O))}}class _e extends _t{async _call(O){return new Dn(await super._call(O))}}class Z extends he{}class xe extends Z{}class Ne extends Z{async _call(O){return new bn(await super._call(O))}}class at extends Z{async _call(O){return new lr(await super._call(O))}}class ct extends Z{async _call(O){return new wn(await super._call(O))}}class gt extends Z{async _call(O){return new Dn(await super._call(O))}}class zt extends he{}class $t extends zt{}class St extends zt{async _call(O){return new bn(await super._call(O))}}class Ft extends zt{async _call(O){return new lr(await super._call(O))}}class gr extends zt{async _call(O){return new wn(await super._call(O))}}class Cr extends zt{async _call(O){return new Dn(await super._call(O))}}class rn extends he{}class an extends rn{}class Pn extends rn{async _call(O){return new bn(await super._call(O))}}class Ns extends rn{async _call(O){return new lr(await super._call(O))}}class Us extends rn{async _call(O){return new wn(await super._call(O))}}class Ps extends rn{async _call(O){return new Dn(await super._call(O))}}class Bn extends he{}class Gt extends Bn{}class fs extends Bn{async _call(O){return new bn(await super._call(O))}}class Vs extends Bn{async _call(O){return new lr(await super._call(O))}}class so extends Bn{async _call(O){return new wn(await super._call(O))}}class Io extends Bn{async _call(O){return new Dn(await super._call(O))}}class ts extends he{}class oo extends ts{}class io extends ts{async _call(O){return new bn(await super._call(O))}}class hs extends ts{async _call(O){return new lr(await super._call(O))}}class Cs extends ts{async _call(O){return new wn(await super._call(O))}}class Cn extends ts{async _call(O){return new Dn(await super._call(O))}}class dt extends he{}class Pt extends dt{}class jt extends dt{async _call(O){return new lr(await super._call(O))}}class ln extends dt{async _call(O){return new wn(await super._call(O))}}class Ws extends dt{async _call(O){return new Dn(await super._call(O))}}class ao extends dt{async _call(O){return new bn(await super._call(O))}}class Dr extends he{}class rs extends Dr{}class zr extends Dr{async _call(O){return new bn(await super._call(O))}}class Ss extends Dr{async _call(O){return new lr(await super._call(O))}}class Sr extends Dr{async _call(O){return new wn(await super._call(O))}}class lo extends he{}class Ei extends lo{}class ha extends lo{async _call(O){return new bn(await super._call(O))}}class Pi extends lo{async _call(O){return new lr(await super._call(O))}}class Ci extends lo{async _call(O){return new Dn(await super._call(O))}}class uo extends he{}class ma extends uo{}class Yr extends uo{async _call(O){return new bn(await super._call(O))}}class il extends uo{async _call(O){return new lr(await super._call(O))}}class Gs extends uo{async _call(O){return new wn(await super._call(O))}}class ms extends uo{async _call(O){return new Dn(await super._call(O))}}class Rn extends he{}class Si extends Rn{}class Ao extends Rn{async _call(O){return new bn(await super._call(O))}}class co extends Rn{async _call(O){return new lr(await super._call(O))}}class jn extends Rn{async _call(O){return new Dn(await super._call(O))}}class po extends he{}class Rt extends po{}class ki extends po{async _call(O){return new lr(await super._call(O))}}class _a extends po{async _call(O){return new Dn(await super._call(O))}}class ga extends po{async _call(O){return new bn(await super._call(O))}}class fo extends he{constructor(){super(...arguments);Fe(this,"forward_params",["input_ids","attention_mask","encoder_outputs","decoder_input_ids","decoder_attention_mask","past_key_values"])}}class Fo extends fo{}class ho extends fo{}class Ks extends he{}class ya extends Ks{}class kr extends Ks{}class Oe extends he{}class I extends Oe{}class ne extends Oe{}class we extends he{}class Ie extends we{}class De extends we{}class Ge extends we{async _call(O){return new lr(await super._call(O))}}class mt extends he{}class bt extends mt{}class yt extends mt{}class kt extends mt{async _call(O){return new lr(await super._call(O))}}class Zt extends mt{}class xr extends he{}class ar extends xr{}class Fr extends xr{}class Ht extends he{}class hr extends Ht{}class fn extends Ht{}class Nr extends he{}class Qe extends Nr{}class mr extends Nr{async _call(O){return new bn(await super._call(O))}}class Mn extends Nr{async _call(O){return new lr(await super._call(O))}}class Qn extends Nr{async _call(O){return new wn(await super._call(O))}}class Nn extends Nr{async _call(O){return new Dn(await super._call(O))}}class qt extends he{}class gn extends qt{}class Sn extends qt{async _call(O){return new bn(await super._call(O))}}class _r extends qt{async _call(O){return new lr(await super._call(O))}}class $r extends qt{async _call(O){return new wn(await super._call(O))}}class Tt extends qt{async _call(O){return new Dn(await super._call(O))}}class Jt extends he{}class Jr extends Jt{}class ns extends Jt{async _call(O){return new bn(await super._call(O))}}class Hs extends Jt{async _call(O){return new lr(await super._call(O))}}class Nt extends Jt{async _call(O){return new wn(await super._call(O))}}class $i extends Jt{async _call(O){return new Dn(await super._call(O))}}class it extends he{}class Ut extends it{}class al extends it{}class qs extends he{constructor(){super(...arguments);Fe(this,"requires_attention_mask",!1);Fe(this,"main_input_name","input_features");Fe(this,"forward_params",["input_features","attention_mask","decoder_input_ids","decoder_attention_mask","past_key_values"])}}class ll extends qs{}class Oo extends qs{_prepare_generation_config(O,G){return super._prepare_generation_config(O,G,ie.WhisperGenerationConfig)}_retrieve_init_tokens(O){const G=[O.decoder_start_token_id];let $e=O.language;const Ue=O.task;if(O.is_multilingual){$e||(console.warn("No language specified - defaulting to English (en)."),$e="en");const rt=`<|${(0,pe.whisper_language_to_code)($e)}|>`;G.push(O.lang_to_id[rt]),G.push(O.task_to_id[Ue??"transcribe"])}else if($e||Ue)throw new Error("Cannot specify `task` or `language` for an English-only model. If the model is intended to be multilingual, pass `is_multilingual=true` to generate, or update the generation config.");return!O.return_timestamps&&O.no_timestamps_token_id&&G.at(-1)!==O.no_timestamps_token_id?G.push(O.no_timestamps_token_id):O.return_timestamps&&G.at(-1)===O.no_timestamps_token_id&&(console.warn("<|notimestamps|> prompt token is removed from generation_config since `return_timestamps` is set to `true`."),G.pop()),G.filter(ze=>ze!=null)}async generate({inputs:O=null,generation_config:G=null,logits_processor:$e=null,stopping_criteria:Ue=null,...ze}){G=this._prepare_generation_config(G,ze);const rt=ze.decoder_input_ids??this._retrieve_init_tokens(G);if(G.return_timestamps&&($e??($e=new k.LogitsProcessorList),$e.push(new k.WhisperTimeStampLogitsProcessor(G,rt))),G.begin_suppress_tokens&&($e??($e=new k.LogitsProcessorList),$e.push(new k.SuppressTokensAtBeginLogitsProcessor(G.begin_suppress_tokens,rt.length))),G.return_token_timestamps){if(!G.alignment_heads)throw new Error("Model generation config has no `alignment_heads`, token-level timestamps not available. See https://gist.github.com/hollance/42e32852f24243b748ae6bc1f985b13a on how to add this property to the generation config.");G.task==="translate"&&console.warn("Token-level timestamps may not be reliable for task 'translate'."),G.output_attentions=!0,G.return_dict_in_generate=!0}const ut=await super.generate({inputs:O,generation_config:G,logits_processor:$e,decoder_input_ids:rt,...ze});return G.return_token_timestamps&&(ut.token_timestamps=this._extract_token_timestamps(ut,G.alignment_heads,G.num_frames)),ut}_extract_token_timestamps(O,G,$e=null,Ue=.02){if(!O.cross_attentions)throw new Error("Model outputs must contain cross attentions to extract timestamps. This is most likely because the model was not exported with `output_attentions=True`.");$e==null&&console.warn("`num_frames` has not been set, meaning the entire audio will be analyzed. This may lead to inaccurate token-level timestamps for short audios (< 30 seconds).");let ze=this.config.median_filter_width;ze===void 0&&(console.warn("Model config has no `median_filter_width`, using default value of 7."),ze=7);const rt=O.cross_attentions,ut=Array.from({length:this.config.decoder_layers},(dr,sr)=>(0,$.cat)(rt.map(pr=>pr[sr]),2)),Mt=(0,$.stack)(G.map(([dr,sr])=>{if(dr>=ut.length)throw new Error(`Layer index ${dr} is out of bounds for cross attentions (length ${ut.length}).`);return $e?ut[dr].slice(null,sr,null,[0,$e]):ut[dr].slice(null,sr)})).transpose(1,0,2,3),[At,Kt]=(0,$.std_mean)(Mt,-2,0,!0),Ot=Mt.clone();for(let dr=0;dr<Ot.dims[0];++dr){const sr=Ot[dr];for(let pr=0;pr<sr.dims[0];++pr){const sn=sr[pr],br=At[dr][pr][0].data,Br=Kt[dr][pr][0].data;for(let Or=0;Or<sn.dims[0];++Or){let qr=sn[Or].data;for(let _n=0;_n<qr.length;++_n)qr[_n]=(qr[_n]-Br[_n])/br[_n];qr.set((0,fe.medianFilter)(qr,ze))}}}const Qt=[(0,$.mean)(Ot,1)],Vt=O.sequences.dims,nr=new $.Tensor("float32",new Float32Array(Vt[0]*Vt[1]),Vt);for(let dr=0;dr<Vt[0];++dr){const sr=Qt[dr].neg().squeeze_(0),[pr,sn]=(0,fe.dynamic_time_warping)(sr.tolist()),br=Array.from({length:pr.length-1},(qr,_n)=>pr[_n+1]-pr[_n]),Br=(0,oe.mergeArrays)([1],br).map(qr=>!!qr),Or=[];for(let qr=0;qr<Br.length;++qr)Br[qr]&&Or.push(sn[qr]*Ue);nr[dr].data.set(Or,1)}return nr}}class or extends he{constructor(){super(...arguments);Fe(this,"main_input_name","pixel_values");Fe(this,"forward_params",["pixel_values","decoder_input_ids","encoder_hidden_states","past_key_values"])}}class wa extends he{constructor(){super(...arguments);Fe(this,"forward_params",["input_ids","pixel_values","attention_mask","position_ids","past_key_values"])}}class Lo extends wa{_merge_input_ids_with_image_features({inputs_embeds:O,image_features:G,input_ids:$e,attention_mask:Ue}){const ze=this.config.image_token_index,ut=$e.tolist().map(Qt=>Qt.findIndex(Vt=>Vt==ze)),Mt=ut.every(Qt=>Qt===-1),At=ut.every(Qt=>Qt!==-1);if(!Mt&&!At)throw new Error("Every input should contain either 0 or 1 image token.");if(Mt)return{inputs_embeds:O,attention_mask:Ue};const Kt=[],Ot=[];for(let Qt=0;Qt<ut.length;++Qt){const Vt=ut[Qt],nr=O[Qt],dr=G[Qt],sr=Ue[Qt];Kt.push((0,$.cat)([nr.slice([0,Vt]),dr,nr.slice([Vt+1,nr.dims[0]])],0)),Ot.push((0,$.cat)([sr.slice([0,Vt]),(0,$.ones)([dr.dims[0]]),sr.slice([Vt+1,sr.dims[0]])],0))}return{inputs_embeds:(0,$.stack)(Kt,0),attention_mask:(0,$.stack)(Ot,0)}}}class vu extends Lo{}class Xn extends Lo{}class qo extends he{constructor(){super(...arguments);Fe(this,"forward_params",["input_ids","inputs_embeds","attention_mask","pixel_values","encoder_outputs","decoder_input_ids","decoder_inputs_embeds","decoder_attention_mask","past_key_values"]);Fe(this,"main_input_name","inputs_embeds")}}class Un extends qo{_merge_input_ids_with_image_features({inputs_embeds:O,image_features:G,input_ids:$e,attention_mask:Ue}){return{inputs_embeds:(0,$.cat)([G,O],1),attention_mask:(0,$.cat)([(0,$.ones)(G.dims.slice(0,2)),Ue],1)}}async _prepare_inputs_embeds({input_ids:O,pixel_values:G,inputs_embeds:$e,attention_mask:Ue}){if(!O&&!G)throw new Error("Either `input_ids` or `pixel_values` should be provided.");let ze,rt;return O&&(ze=await this.encode_text({input_ids:O})),G&&(rt=await this.encode_image({pixel_values:G})),ze&&rt?{inputs_embeds:$e,attention_mask:Ue}=this._merge_input_ids_with_image_features({inputs_embeds:ze,image_features:rt,input_ids:O,attention_mask:Ue}):$e=ze||rt,{inputs_embeds:$e,attention_mask:Ue}}async forward({input_ids:O,pixel_values:G,attention_mask:$e,decoder_input_ids:Ue,decoder_attention_mask:ze,encoder_outputs:rt,past_key_values:ut,inputs_embeds:Mt,decoder_inputs_embeds:At}){if(Mt||({inputs_embeds:Mt,attention_mask:$e}=await this._prepare_inputs_embeds({input_ids:O,pixel_values:G,inputs_embeds:Mt,attention_mask:$e})),!rt){let{last_hidden_state:Qt}=await Me(this,{inputs_embeds:Mt,attention_mask:$e});rt=Qt}if(!At){if(!Ue)throw new Error("Either `decoder_input_ids` or `decoder_inputs_embeds` should be provided.");At=await this.encode_text({input_ids:Ue})}return await N(this,{inputs_embeds:At,attention_mask:ze,encoder_attention_mask:$e,encoder_hidden_states:rt,past_key_values:ut},!0)}}class ks extends he{}class ad extends ks{}class mo extends ks{static async from_pretrained(O,G={}){return G.model_file_name??(G.model_file_name="text_model"),super.from_pretrained(O,G)}}class ul extends ks{static async from_pretrained(O,G={}){return G.model_file_name??(G.model_file_name="text_model"),super.from_pretrained(O,G)}}class va extends ks{static async from_pretrained(O,G={}){return G.model_file_name??(G.model_file_name="vision_model"),super.from_pretrained(O,G)}}class Ma extends ks{static async from_pretrained(O,G={}){return G.model_file_name??(G.model_file_name="vision_model"),super.from_pretrained(O,G)}}class cl extends he{}class ld extends cl{}class ud extends cl{static async from_pretrained(O,G={}){return G.model_file_name??(G.model_file_name="text_model"),super.from_pretrained(O,G)}}class cd extends ks{static async from_pretrained(O,G={}){return G.model_file_name??(G.model_file_name="vision_model"),super.from_pretrained(O,G)}}class dl extends he{}class dd extends dl{}class pl extends he{}class $s extends pl{async forward(O){const G=!O.input_ids,$e=!O.pixel_values;if(G&&$e)throw new Error("Either `input_ids` or `pixel_values` should be provided.");if(G&&(O.input_ids=(0,$.ones)([O.pixel_values.dims[0],1])),$e){const{image_size:At}=this.config.vision_config;O.pixel_values=(0,$.full)([0,3,At,At],0)}const{text_embeddings:Ue,image_embeddings:ze,l2norm_text_embeddings:rt,l2norm_image_embeddings:ut}=await super.forward(O),Mt={};return G||(Mt.text_embeddings=Ue,Mt.l2norm_text_embeddings=rt),$e||(Mt.image_embeddings=ze,Mt.l2norm_image_embeddings=ut),Mt}}class pd extends pl{static async from_pretrained(O,G={}){return G.model_file_name??(G.model_file_name="text_model"),super.from_pretrained(O,G)}}class fd extends pl{static async from_pretrained(O,G={}){return G.model_file_name??(G.model_file_name="vision_model"),super.from_pretrained(O,G)}}class fl extends he{}class hd extends fl{}class md extends fl{}class Mu extends he{}class _d extends Mu{}class hl extends Mu{}class xu extends he{}class gd extends xu{}class fp extends xu{}class ss extends he{}class yd extends ss{}class ml extends ss{}class _l extends he{}class Is extends _l{}class wd extends _l{}class Tu extends he{}class vd extends Tu{}class gl extends Tu{}class Qo extends he{}class Md extends Qo{}class bu extends Qo{}class yl extends he{}class Eu extends yl{}class Pu extends yl{}class os extends he{}class Xo extends os{}class xd extends os{}class Cu extends he{}class Td extends Cu{}class Su extends Cu{}class wl extends he{}class Ii extends wl{}class Ai extends wl{}class ku extends he{}class xa extends ku{}class $u extends ku{}class Ta extends he{}class vl extends Ta{}class Ml extends Ta{}class ba extends he{}class bd extends ba{}class Iu extends ba{}class Au extends he{}class Ed extends Au{}class Pd extends Au{}class Fi extends he{}class Cd extends Fi{}class _s extends Fi{}class Do extends he{}class Fu extends Do{}class Ou extends Do{}class Lu extends he{constructor(){super(...arguments);Fe(this,"forward_params",["input_ids","attention_mask","position_ids","past_key_values","pixel_values","image_grid_thw"])}}class Du extends Lu{get_rope_index(O,G,$e,Ue){const{vision_config:ze,image_token_id:rt,video_token_id:ut,vision_start_token_id:Mt}=this.config,At=ze.spatial_merge_size??2,Kt=[];if(G||$e){let Ot=O.tolist();Ue||(Ue=(0,$.ones_like)(O));const Qt=Ue.tolist(),Vt=Array.from({length:3},sn=>Array.from({length:O.dims[0]},br=>Array.from({length:O.dims[1]},Br=>1))),nr=G?G.tolist():[],dr=$e?$e.tolist():[];let sr=0,pr=0;for(let sn=0;sn<Ot.length;++sn){const br=Ot[sn].filter((Xr,cn)=>Qt[sn][cn]==1),Or=br.reduce((Xr,cn,Zn)=>(cn==Mt&&Xr.push(Zn),Xr),[]).map(Xr=>br[Xr+1]),qr=Or.filter(Xr=>Xr==rt).length,_n=Or.filter(Xr=>Xr==ut).length;let un=[],tn=0,xs=qr,ds=_n;for(let Xr=0;Xr<Or.length;++Xr){const cn=br.findIndex((wi,Bs)=>Bs>tn&&wi==rt),Zn=br.findIndex((wi,Bs)=>Bs>tn&&wi==ut),Co=xs>0&&cn!==-1?cn:br.length+1,Ts=ds>0&&Zn!==-1?Zn:br.length+1;let du,pu,la,yi;Co<Ts?([pu,la,yi]=nr[sr],++sr,--xs,du=Co):([pu,la,yi]=dr[pr],++pr,--ds,du=Ts);const[gp,Qc,fu]=[Number(pu),Math.floor(Number(la)/At),Math.floor(Number(yi)/At)],Za=du-tn,Ho=un.length>0?(0,fe.max)(un.at(-1))[0]+1:0;un.push(Array.from({length:3*Za},(wi,Bs)=>Ho+Bs%Za));const rp=Za+Ho,So=gp*Qc*fu,hu=Array.from({length:So},(wi,Bs)=>rp+Math.floor(Bs/(Qc*fu))),dn=Array.from({length:So},(wi,Bs)=>rp+Math.floor(Bs/fu)%Qc),yp=Array.from({length:So},(wi,Bs)=>rp+Bs%fu);un.push([hu,dn,yp].flat()),tn=du+So}if(tn<br.length){const Xr=un.length>0?(0,fe.max)(un.at(-1))[0]+1:0,cn=br.length-tn;un.push(Array.from({length:3*cn},(Zn,Co)=>Xr+Co%cn))}const Qr=un.reduce((Xr,cn)=>Xr+cn.length,0),Ds=new Array(Qr);let cu=0;for(let Xr=0;Xr<3;++Xr)for(let cn=0;cn<un.length;++cn){const Zn=un[cn],Co=Zn.length/3;for(let Ts=Xr*Co;Ts<(Xr+1)*Co;++Ts)Ds[cu++]=Zn[Ts]}let aa=0;const qc=Qt[sn];for(let Xr=0;Xr<qc.length;++Xr)if(qc[Xr]==1){for(let cn=0;cn<3;++cn)Vt[cn][sn][Xr]=Ds[cn*Qr/3+aa];++aa}const zs=(0,fe.max)(Ds)[0];Kt.push(zs+1-Ot[sn].length)}return[new $.Tensor("int64",Vt.flat(1/0),[3,O.dims[0],O.dims[1]]),new $.Tensor("int64",Kt,[Kt.length,1])]}else if(Ue){const{data:Ot,dims:Qt}=ue(Ue),Vt=BigInt64Array.from({length:3*Ot.length},(dr,sr)=>Ot[sr%Ot.length]),nr=Array.from({length:Qt[0]},(dr,sr)=>(0,fe.max)(Ot.subarray(Qt[1]*sr,Qt[1]*(sr+1)))[0]+1+Qt[1]);return[new $.Tensor("int64",Vt,[3,...Qt]),new $.Tensor("int64",nr,[nr.length,1])]}else{const[Ot,Qt]=O.dims,Vt=BigInt64Array.from({length:3*Ot*Qt},(nr,dr)=>BigInt(Math.floor(dr%Qt/Ot)));return[new $.Tensor("int64",Vt,[3,...O.dims]),(0,$.zeros)([Ot,1])]}}async encode_image({pixel_values:O,image_grid_thw:G}){return(await Ee(this.sessions.vision_encoder,{pixel_values:O,grid_thw:G})).image_features}_merge_input_ids_with_image_features({inputs_embeds:O,image_features:G,input_ids:$e,attention_mask:Ue}){const{image_token_id:ze}=this.config,rt=$e.tolist().map(Kt=>Kt.reduce((Ot,Qt,Vt)=>(Qt==ze&&Ot.push(Vt),Ot),[])),ut=rt.reduce((Kt,Ot)=>Kt+Ot.length,0),Mt=G.dims[0];if(ut!==Mt)throw new Error(`Image features and image tokens do not match: tokens: ${ut}, features ${Mt}`);let At=0;for(let Kt=0;Kt<rt.length;++Kt){const Ot=rt[Kt],Qt=O[Kt];for(let Vt=0;Vt<Ot.length;++Vt)Qt[Ot[Vt]].data.set(G[At++].data)}return{inputs_embeds:O,attention_mask:Ue}}prepare_inputs_for_generation(O,G,$e){if(G.attention_mask&&!G.position_ids)if(!G.past_key_values)[G.position_ids,G.rope_deltas]=this.get_rope_index(G.input_ids,G.image_grid_thw,G.video_grid_thw,G.attention_mask);else{G.pixel_values=null;const Ue=BigInt(Object.values(G.past_key_values)[0].dims.at(-2)),ze=G.rope_deltas.map(rt=>Ue+rt);G.position_ids=(0,$.stack)([ze,ze,ze],0)}return G}}class xl extends he{}class Sd extends xl{}class kd extends xl{}class zo extends he{}class zu extends zo{}class Oi extends zo{}class wr extends he{}class Bu extends wr{}class Ea extends wr{}class Bo extends he{}class Tl extends Bo{}class Ru extends Bo{}class Li extends he{}class ju extends Li{}class Nu extends Li{}class bl extends he{}class Uu extends bl{}class Vu extends bl{async _call(O){return new lr(await super._call(O))}}class Wu extends he{}class _o extends Wu{}class Pa extends he{}class Yo extends Pa{}class $d extends Pa{async _call(O){return new lr(await super._call(O))}}class El extends he{}class Di extends El{}class Gu extends he{}class Ku extends Gu{}class Hu extends Gu{async _call(O){return new lr(await super._call(O))}}class Gr extends he{}class Pl extends Gr{}class zi extends he{}class Bi extends zi{}class qu extends zi{async _call(O){return new lr(await super._call(O))}}class Cl extends he{}class Ri extends Cl{async _call(O){return new cs(await super._call(O))}}class ji extends he{}class Jo extends ji{}class Qu extends ji{async _call(O){return new lr(await super._call(O))}}class Xu extends he{}class Id extends Xu{}class Sl extends Xu{async _call(O){return new lr(await super._call(O))}}class Ni extends he{}class Ui extends Ni{}class Ca extends Ni{}class Sa extends he{}class kl extends Sa{}class $l extends Sa{}class Yu extends he{}class Ju extends Yu{}class Ad extends Yu{async _call(O){return new lr(await super._call(O))}}class ka extends he{}class Il extends ka{}class go extends ka{async _call(O){return new Zo(await super._call(O))}}class Al extends ka{async _call(O){return new As(await super._call(O))}}class Zo extends Ve{constructor({logits:O,pred_boxes:G}){super(),this.logits=O,this.pred_boxes=G}}class As extends Ve{constructor({logits:O,pred_boxes:G,pred_masks:$e}){super(),this.logits=O,this.pred_boxes=G,this.pred_masks=$e}}class ei extends he{}class yn extends ei{}class Fl extends ei{async _call(O){return new Fd(await super._call(O))}}class Fd extends Ve{constructor({logits:O,pred_boxes:G}){super(),this.logits=O,this.pred_boxes=G}}class Zu extends he{}class Ro extends Zu{}class Vi extends Zu{async _call(O){return new ti(await super._call(O))}}class ti extends Zo{}class Wi extends he{}class Ol extends Wi{}class ri extends Wi{async _call(O){return new lr(await super._call(O))}}class Qs extends he{}class Zr extends Qs{}class Ur extends Qs{async _call(O){return new lr(await super._call(O))}}class Xs extends he{}class kn extends Xs{}class Vn extends Xs{async _call(O){return new lr(await super._call(O))}}class yo extends he{}class ni extends yo{}class Yn extends yo{async _call(O){return new lr(await super._call(O))}}class gs extends he{}class wo extends gs{}class vo extends gs{}class si extends he{}class Mo extends si{}class nn extends si{}class Gi extends he{}class Ki extends Gi{}class Hi extends he{}class Od extends Hi{}class xo extends Hi{}class oi extends Hi{}class To extends he{}class qi extends To{}class Qi extends he{}class Wn extends Qi{}class is extends Qi{}class Ys extends he{}class ys extends Ys{}class Js extends Ys{}class jo extends he{}class Ld extends jo{}class $a extends he{}class Ia extends $a{}class $n extends $a{async _call(O){return new lr(await super._call(O))}}class Gn extends he{}class Kr extends Gn{}class ws extends Gn{async _call(O){return new lr(await super._call(O))}}class Ll extends he{}class ec extends Ll{}class tc extends Ll{async _call(O){return new lr(await super._call(O))}}class Aa extends he{}class rc extends Aa{}class Dl extends Aa{async _call(O){return new zl(await super._call(O))}}class zl extends Ve{constructor({logits:O,pred_boxes:G}){super(),this.logits=O,this.pred_boxes=G}}class ii extends he{}class Bl extends ii{async get_image_embeddings({pixel_values:O}){return await Me(this,{pixel_values:O})}async forward(O){if((!O.image_embeddings||!O.image_positional_embeddings)&&(O={...O,...await this.get_image_embeddings(O)}),!O.input_labels&&O.input_points){const $e=O.input_points.dims.slice(0,-1),Ue=$e.reduce((ze,rt)=>ze*rt,1);O.input_labels=new $.Tensor("int64",new BigInt64Array(Ue).fill(1n),$e)}const G={image_embeddings:O.image_embeddings,image_positional_embeddings:O.image_positional_embeddings};return O.input_points&&(G.input_points=O.input_points),O.input_labels&&(G.input_labels=O.input_labels),O.input_boxes&&(G.input_boxes=O.input_boxes),await Ee(this.sessions.prompt_encoder_mask_decoder,G)}async _call(O){return new Dd(await super._call(O))}}class Dd extends Ve{constructor({iou_scores:O,pred_masks:G}){super(),this.iou_scores=O,this.pred_masks=G}}class ai extends he{}class li extends ai{}class nc extends ai{}class Xi extends he{}class No extends Xi{}class Rl extends Xi{}class Fs extends he{}class Fa extends Fs{}class Uo extends Fs{async _call(O){return new Po(await super._call(O))}}class sc extends Fs{async _call(O){return new lr(await super._call(O))}}class jl extends Fs{async _call(O){return new wn(await super._call(O))}}class Oa extends he{}class oc extends Oa{}class ui extends Oa{async _call(O){return new wn(await super._call(O))}}class Jn extends he{}class ci extends Jn{}class Yi extends he{}class ic extends Yi{}class Zs extends Yi{async _call(O){return new Po(await super._call(O))}}class eo extends Yi{async _call(O){return new lr(await super._call(O))}}class di extends he{}class ac extends di{}class to extends di{async _call(O){return new Po(await super._call(O))}}class bo extends di{async _call(O){return new lr(await super._call(O))}}class La extends di{async _call(O){return new wn(await super._call(O))}}class Da extends he{}class Nl extends Da{}class lc extends Da{async _call(O){return new Po(await super._call(O))}}class Ji extends Da{async _call(O){return new lr(await super._call(O))}}class ro extends he{}class za extends Fs{}class Zi extends Fs{async _call(O){return new Po(await super._call(O))}}class Vo extends Fs{async _call(O){return new lr(await super._call(O))}}class Wo extends he{}class pi extends Wo{}class uc extends Wo{async _call(O){return new Po(await super._call(O))}}class cc extends Wo{async _call(O){return new lr(await super._call(O))}}class Hr extends Wo{async _call(O){return new Kc(await super._call(O))}}class Go extends Wo{async _call(O){return new wn(await super._call(O))}}class fi extends he{}class dc extends fi{}class Ba extends fi{}class Ul extends fi{async generate_speech(O,G,{threshold:$e=.5,minlenratio:Ue=0,maxlenratio:ze=20,vocoder:rt=null}={}){const ut={input_ids:O},{encoder_outputs:Mt,encoder_attention_mask:At}=await Me(this,ut),Kt=Mt.dims[1]/this.config.reduction_factor,Ot=Math.floor(Kt*ze),Qt=Math.floor(Kt*Ue),Vt=this.config.num_mel_bins;let nr=[],dr=null,sr=null,pr=0;for(;;){++pr;const Br=Le(!!sr);let Or;sr?Or=sr.output_sequence_out:Or=new $.Tensor("float32",new Float32Array(Vt),[1,1,Vt]);let qr={use_cache_branch:Br,output_sequence:Or,encoder_attention_mask:At,speaker_embeddings:G,encoder_hidden_states:Mt};this.addPastKeyValues(qr,dr),sr=await Ee(this.sessions.decoder_model_merged,qr),dr=this.getPastKeyValues(sr,dr);const{prob:_n,spectrum:un}=sr;if(nr.push(un),pr>=Qt&&(Array.from(_n.data).filter(tn=>tn>=$e).length>0||pr>=Ot))break}const sn=(0,$.cat)(nr),{waveform:br}=await Ee(rt.sessions.model,{spectrogram:sn});return{spectrogram:sn,waveform:br}}}class Ko extends he{constructor(){super(...arguments);Fe(this,"main_input_name","spectrogram")}}class en extends he{}class hn extends en{}class mn extends he{}class Ra extends mn{}class ja extends mn{}class hi extends he{}class pc extends hi{}class In extends hi{}class Na extends he{}class Vl extends Na{}class fc extends Na{}class as extends he{}class ls extends as{}class Ua extends as{static async from_pretrained(O,G={}){return G.model_file_name??(G.model_file_name="text_model"),super.from_pretrained(O,G)}}class Wl extends as{static async from_pretrained(O,G={}){return G.model_file_name??(G.model_file_name="audio_model"),super.from_pretrained(O,G)}}class Gl extends he{}class Kl extends Gl{async _call(O){return new Tr(await super._call(O))}}class Va extends he{}class hp extends Va{}class hc extends Va{}class mc extends Va{}class Hl extends he{}class _c extends Hl{}class zd extends Hl{}class mi extends he{}class gc extends mi{}class Wa extends mi{async _call(O){return new lr(await super._call(O))}}class ea extends he{}class mp extends ea{}class yc extends ea{}class ql extends he{constructor(){super(...arguments);Fe(this,"forward_params",["input_ids","attention_mask","encoder_outputs","decoder_input_ids","decoder_attention_mask","past_key_values"])}_apply_and_filter_by_delay_pattern_mask(G){const[$e,Ue]=G.dims,ze=this.config.decoder.num_codebooks,rt=Ue-ze;let ut=0;for(let Kt=0;Kt<G.size;++Kt){if(G.data[Kt]===this.config.decoder.pad_token_id)continue;const Ot=Kt%Ue,Qt=Math.floor(Kt/Ue)%ze,Vt=Ot-Qt;Vt>0&&Vt<=rt&&(G.data[ut++]=G.data[Kt])}const Mt=Math.floor($e/ze),At=ut/(Mt*ze);return new $.Tensor(G.type,G.data.slice(0,ut),[Mt,ze,At])}prepare_inputs_for_generation(G,$e,Ue){let ze=structuredClone(G);for(let ut=0;ut<ze.length;++ut)for(let Mt=0;Mt<ze[ut].length;++Mt)ut%this.config.decoder.num_codebooks>=Mt&&(ze[ut][Mt]=BigInt(this.config.decoder.pad_token_id));return Ue.guidance_scale!==null&&Ue.guidance_scale>1&&(ze=ze.concat(ze)),super.prepare_inputs_for_generation(ze,$e,Ue)}async generate(G){const $e=await super.generate(G),Ue=this._apply_and_filter_by_delay_pattern_mask($e).unsqueeze_(0),{audio_values:ze}=await Ee(this.sessions.encodec_decode,{audio_codes:Ue});return ze}}class Ql extends he{}class wc extends Ql{}class Bd extends Ql{async _call(O){return new lr(await super._call(O))}}class xn extends he{}class vc extends xn{}class Mc extends xn{async _call(O){return new lr(await super._call(O))}}class Ga extends he{}class Rd extends Ga{}class ta extends Ga{async _call(O){return new lr(await super._call(O))}}class xc extends he{}class jd extends xc{}class Xl extends xc{async _call(O){return new lr(await super._call(O))}}class Tc extends he{}class bc extends Tc{}class ra extends he{}class Nd extends ra{constructor(...G){super(...G);Fe(this,"forward_params",["input_ids","pixel_values","images_seq_mask","images_emb_mask","attention_mask","position_ids","past_key_values"]);this._generation_mode="text"}async forward(G){const $e=this._generation_mode??"text";let Ue;if($e==="text"||!G.past_key_values){const At=this.sessions.prepare_inputs_embeds,Kt=(0,oe.pick)(G,At.inputNames);Ue=await Ee(At,Kt)}else{const At=this.sessions.gen_img_embeds,Kt=(0,oe.pick)({image_ids:G.input_ids},At.inputNames);Ue=await Ee(At,Kt)}const ze={...G,...Ue},rt=await N(this,ze),ut=this.sessions[$e==="text"?"lm_head":"gen_head"];if(!ut)throw new Error(`Unable to find "${ut}" generation head`);const Mt=await Ee(ut,(0,oe.pick)(rt,ut.inputNames));return{...Ue,...rt,...Mt}}async generate(G){return this._generation_mode="text",super.generate(G)}async generate_images(G){this._generation_mode="image";const $e=(G.inputs??G[this.main_input_name]).dims[1],ze=(await super.generate(G)).slice(null,[$e,null]),rt=this.sessions.image_decode,{decoded_image:ut}=await Ee(rt,{generated_tokens:ze}),Mt=ut.add_(1).mul_(255/2).clamp_(0,255).to("uint8"),At=[];for(const Kt of Mt){const Ot=ae.RawImage.fromTensor(Kt);At.push(Ot)}return At}}class Ud extends Ve{constructor({char_logits:O,bpe_logits:G,wp_logits:$e}){super(),this.char_logits=O,this.bpe_logits=G,this.wp_logits=$e}get logits(){return[this.char_logits,this.bpe_logits,this.wp_logits]}}class Vd extends he{}class us extends Vd{async _call(O){return new Ud(await super._call(O))}}class Ka extends he{}class Ha extends Ka{}class Yl extends Ka{}class Jl extends he{}class Wd extends Jl{}class qa extends Jl{}class vr{static async from_pretrained(O,{progress_callback:G=null,config:$e=null,cache_dir:Ue=null,local_files_only:ze=!1,revision:rt="main",model_file_name:ut=null,subfolder:Mt="onnx",device:At=null,dtype:Kt=null,use_external_data_format:Ot=null,session_options:Qt={}}={}){const Vt={progress_callback:G,config:$e,cache_dir:Ue,local_files_only:ze,revision:rt,model_file_name:ut,subfolder:Mt,device:At,dtype:Kt,use_external_data_format:Ot,session_options:Qt};if(Vt.config=await P.AutoConfig.from_pretrained(O,Vt),!this.MODEL_CLASS_MAPPINGS)throw new Error("`MODEL_CLASS_MAPPINGS` not implemented for this type of `AutoClass`: "+this.name);for(const nr of this.MODEL_CLASS_MAPPINGS){const dr=nr.get(Vt.config.model_type);if(dr)return await dr[1].from_pretrained(O,Vt)}if(this.BASE_IF_FAIL)return console.warn(`Unknown model class "${Vt.config.model_type}", attempting to construct from base class.`),await he.from_pretrained(O,Vt);throw Error(`Unsupported model type: ${Vt.config.model_type}`)}}Fe(vr,"MODEL_CLASS_MAPPINGS",null),Fe(vr,"BASE_IF_FAIL",!1);const Ec=new Map([["bert",["BertModel",be]],["nomic_bert",["NomicBertModel",pt]],["roformer",["RoFormerModel",Et]],["electra",["ElectraModel",$t]],["esm",["EsmModel",rs]],["convbert",["ConvBertModel",xe]],["camembert",["CamembertModel",an]],["deberta",["DebertaModel",Gt]],["deberta-v2",["DebertaV2Model",oo]],["mpnet",["MPNetModel",ma]],["albert",["AlbertModel",Rt]],["distilbert",["DistilBertModel",Pt]],["roberta",["RobertaModel",Qe]],["xlm",["XLMModel",gn]],["xlm-roberta",["XLMRobertaModel",Jr]],["clap",["ClapModel",ls]],["clip",["CLIPModel",ad]],["clipseg",["CLIPSegModel",hd]],["chinese_clip",["ChineseCLIPModel",dd]],["siglip",["SiglipModel",ld]],["jina_clip",["JinaCLIPModel",$s]],["mobilebert",["MobileBertModel",Ei]],["squeezebert",["SqueezeBertModel",Si]],["wav2vec2",["Wav2Vec2Model",Fa]],["wav2vec2-bert",["Wav2Vec2BertModel",Nl]],["unispeech",["UniSpeechModel",ic]],["unispeech-sat",["UniSpeechSatModel",ac]],["hubert",["HubertModel",za]],["wavlm",["WavLMModel",pi]],["audio-spectrogram-transformer",["ASTModel",Ut]],["vits",["VitsModel",Kl]],["pyannote",["PyAnnoteModel",oc]],["wespeaker-resnet",["WeSpeakerResNetModel",ci]],["detr",["DetrModel",Il]],["rt_detr",["RTDetrModel",yn]],["table-transformer",["TableTransformerModel",Ro]],["vit",["ViTModel",Uu]],["pvt",["PvtModel",Yo]],["vit_msn",["ViTMSNModel",Ku]],["vit_mae",["ViTMAEModel",Di]],["groupvit",["GroupViTModel",Pl]],["fastvit",["FastViTModel",Bi]],["mobilevit",["MobileViTModel",Jo]],["mobilevitv2",["MobileViTV2Model",Id]],["owlvit",["OwlViTModel",Ui]],["owlv2",["Owlv2Model",kl]],["beit",["BeitModel",Ju]],["deit",["DeiTModel",Ol]],["hiera",["HieraModel",Zr]],["convnext",["ConvNextModel",Ia]],["convnextv2",["ConvNextV2Model",Kr]],["dinov2",["Dinov2Model",ec]],["resnet",["ResNetModel",kn]],["swin",["SwinModel",ni]],["swin2sr",["Swin2SRModel",wo]],["donut-swin",["DonutSwinModel",Ld]],["yolos",["YolosModel",rc]],["dpt",["DPTModel",Mo]],["glpn",["GLPNModel",ys]],["hifigan",["SpeechT5HifiGan",Ko]],["efficientnet",["EfficientNetModel",gc]],["decision_transformer",["DecisionTransformerModel",bc]],["patchtst",["PatchTSTForPrediction",Ha]],["patchtsmixer",["PatchTSMixerForPrediction",Wd]],["mobilenet_v1",["MobileNetV1Model",wc]],["mobilenet_v2",["MobileNetV2Model",vc]],["mobilenet_v3",["MobileNetV3Model",Rd]],["mobilenet_v4",["MobileNetV4Model",jd]],["maskformer",["MaskFormerModel",Wn]],["mgp-str",["MgpstrForSceneTextRecognition",us]]]),Pc=new Map([["t5",["T5Model",Fo]],["longt5",["LongT5Model",ya]],["mt5",["MT5Model",I]],["bart",["BartModel",Ie]],["mbart",["MBartModel",bt]],["marian",["MarianModel",li]],["whisper",["WhisperModel",ll]],["m2m_100",["M2M100Model",No]],["blenderbot",["BlenderbotModel",ar]],["blenderbot-small",["BlenderbotSmallModel",hr]]]),kp=new Map([["bloom",["BloomModel",Bu]],["jais",["JAISModel",gd]],["gpt2",["GPT2Model",_d]],["gptj",["GPTJModel",vd]],["gpt_bigcode",["GPTBigCodeModel",Md]],["gpt_neo",["GPTNeoModel",yd]],["gpt_neox",["GPTNeoXModel",Is]],["codegen",["CodeGenModel",Eu]],["llama",["LlamaModel",Xo]],["olmo",["OlmoModel",Ii]],["mobilellm",["MobileLLMModel",Td]],["granite",["GraniteModel",xa]],["cohere",["CohereModel",vl]],["gemma",["GemmaModel",bd]],["gemma2",["Gemma2Model",Ed]],["openelm",["OpenELMModel",Cd]],["qwen2",["Qwen2Model",Fu]],["phi",["PhiModel",Sd]],["phi3",["Phi3Model",zu]],["mpt",["MptModel",Tl]],["opt",["OPTModel",ju]],["mistral",["MistralModel",Ra]],["starcoder2",["Starcoder2Model",pc]],["falcon",["FalconModel",Vl]],["stablelm",["StableLmModel",_c]]]),Zl=new Map([["speecht5",["SpeechT5ForSpeechToText",Ba]],["whisper",["WhisperForConditionalGeneration",Oo]]]),Cc=new Map([["speecht5",["SpeechT5ForTextToSpeech",Ul]]]),Sc=new Map([["vits",["VitsModel",Kl]],["musicgen",["MusicgenForConditionalGeneration",ql]]]),Gd=new Map([["bert",["BertForSequenceClassification",lt]],["roformer",["RoFormerForSequenceClassification",vt]],["electra",["ElectraForSequenceClassification",Ft]],["esm",["EsmForSequenceClassification",Ss]],["convbert",["ConvBertForSequenceClassification",at]],["camembert",["CamembertForSequenceClassification",Ns]],["deberta",["DebertaForSequenceClassification",Vs]],["deberta-v2",["DebertaV2ForSequenceClassification",hs]],["mpnet",["MPNetForSequenceClassification",il]],["albert",["AlbertForSequenceClassification",ki]],["distilbert",["DistilBertForSequenceClassification",jt]],["roberta",["RobertaForSequenceClassification",Mn]],["xlm",["XLMForSequenceClassification",_r]],["xlm-roberta",["XLMRobertaForSequenceClassification",Hs]],["bart",["BartForSequenceClassification",Ge]],["mbart",["MBartForSequenceClassification",kt]],["mobilebert",["MobileBertForSequenceClassification",Pi]],["squeezebert",["SqueezeBertForSequenceClassification",co]]]),kc=new Map([["bert",["BertForTokenClassification",ot]],["roformer",["RoFormerForTokenClassification",U]],["electra",["ElectraForTokenClassification",gr]],["esm",["EsmForTokenClassification",Sr]],["convbert",["ConvBertForTokenClassification",ct]],["camembert",["CamembertForTokenClassification",Us]],["deberta",["DebertaForTokenClassification",so]],["deberta-v2",["DebertaV2ForTokenClassification",Cs]],["mpnet",["MPNetForTokenClassification",Gs]],["distilbert",["DistilBertForTokenClassification",ln]],["roberta",["RobertaForTokenClassification",Qn]],["xlm",["XLMForTokenClassification",$r]],["xlm-roberta",["XLMRobertaForTokenClassification",Nt]]]),$c=new Map([["t5",["T5ForConditionalGeneration",ho]],["longt5",["LongT5ForConditionalGeneration",kr]],["mt5",["MT5ForConditionalGeneration",ne]],["bart",["BartForConditionalGeneration",De]],["mbart",["MBartForConditionalGeneration",yt]],["marian",["MarianMTModel",nc]],["m2m_100",["M2M100ForConditionalGeneration",Rl]],["blenderbot",["BlenderbotForConditionalGeneration",Fr]],["blenderbot-small",["BlenderbotSmallForConditionalGeneration",fn]]]),On=new Map([["bloom",["BloomForCausalLM",Ea]],["gpt2",["GPT2LMHeadModel",hl]],["jais",["JAISLMHeadModel",fp]],["gptj",["GPTJForCausalLM",gl]],["gpt_bigcode",["GPTBigCodeForCausalLM",bu]],["gpt_neo",["GPTNeoForCausalLM",ml]],["gpt_neox",["GPTNeoXForCausalLM",wd]],["codegen",["CodeGenForCausalLM",Pu]],["llama",["LlamaForCausalLM",xd]],["olmo",["OlmoForCausalLM",Ai]],["mobilellm",["MobileLLMForCausalLM",Su]],["granite",["GraniteForCausalLM",$u]],["cohere",["CohereForCausalLM",Ml]],["gemma",["GemmaForCausalLM",Iu]],["gemma2",["Gemma2ForCausalLM",Pd]],["openelm",["OpenELMForCausalLM",_s]],["qwen2",["Qwen2ForCausalLM",Ou]],["phi",["PhiForCausalLM",kd]],["phi3",["Phi3ForCausalLM",Oi]],["mpt",["MptForCausalLM",Ru]],["opt",["OPTForCausalLM",Nu]],["mbart",["MBartForCausalLM",Zt]],["mistral",["MistralForCausalLM",ja]],["starcoder2",["Starcoder2ForCausalLM",In]],["falcon",["FalconForCausalLM",fc]],["trocr",["TrOCRForCausalLM",hn]],["stablelm",["StableLmForCausalLM",zd]]]),Kn=new Map([["multi_modality",["MultiModalityCausalLM",Nd]]]),Ic=new Map([["bert",["BertForMaskedLM",Re]],["roformer",["RoFormerForMaskedLM",wt]],["electra",["ElectraForMaskedLM",St]],["esm",["EsmForMaskedLM",zr]],["convbert",["ConvBertForMaskedLM",Ne]],["camembert",["CamembertForMaskedLM",Pn]],["deberta",["DebertaForMaskedLM",fs]],["deberta-v2",["DebertaV2ForMaskedLM",io]],["mpnet",["MPNetForMaskedLM",Yr]],["albert",["AlbertForMaskedLM",ga]],["distilbert",["DistilBertForMaskedLM",ao]],["roberta",["RobertaForMaskedLM",mr]],["xlm",["XLMWithLMHeadModel",Sn]],["xlm-roberta",["XLMRobertaForMaskedLM",ns]],["mobilebert",["MobileBertForMaskedLM",ha]],["squeezebert",["SqueezeBertForMaskedLM",Ao]]]),Kd=new Map([["bert",["BertForQuestionAnswering",st]],["roformer",["RoFormerForQuestionAnswering",_e]],["electra",["ElectraForQuestionAnswering",Cr]],["convbert",["ConvBertForQuestionAnswering",gt]],["camembert",["CamembertForQuestionAnswering",Ps]],["deberta",["DebertaForQuestionAnswering",Io]],["deberta-v2",["DebertaV2ForQuestionAnswering",Cn]],["mpnet",["MPNetForQuestionAnswering",ms]],["albert",["AlbertForQuestionAnswering",_a]],["distilbert",["DistilBertForQuestionAnswering",Ws]],["roberta",["RobertaForQuestionAnswering",Nn]],["xlm",["XLMForQuestionAnswering",Tt]],["xlm-roberta",["XLMRobertaForQuestionAnswering",$i]],["mobilebert",["MobileBertForQuestionAnswering",Ci]],["squeezebert",["SqueezeBertForQuestionAnswering",jn]]]),eu=new Map([["vision-encoder-decoder",["VisionEncoderDecoderModel",or]]]),Hd=new Map([["llava",["LlavaForConditionalGeneration",Lo]],["llava_onevision",["LlavaOnevisionForConditionalGeneration",vu]],["moondream1",["Moondream1ForConditionalGeneration",Xn]],["florence2",["Florence2ForConditionalGeneration",Un]],["qwen2-vl",["Qwen2VLForConditionalGeneration",Du]]]),qd=new Map([["vision-encoder-decoder",["VisionEncoderDecoderModel",or]]]),tu=new Map([["vit",["ViTForImageClassification",Vu]],["pvt",["PvtForImageClassification",$d]],["vit_msn",["ViTMSNForImageClassification",Hu]],["fastvit",["FastViTForImageClassification",qu]],["mobilevit",["MobileViTForImageClassification",Qu]],["mobilevitv2",["MobileViTV2ForImageClassification",Sl]],["beit",["BeitForImageClassification",Ad]],["deit",["DeiTForImageClassification",ri]],["hiera",["HieraForImageClassification",Ur]],["convnext",["ConvNextForImageClassification",$n]],["convnextv2",["ConvNextV2ForImageClassification",ws]],["dinov2",["Dinov2ForImageClassification",tc]],["resnet",["ResNetForImageClassification",Vn]],["swin",["SwinForImageClassification",Yn]],["segformer",["SegformerForImageClassification",hc]],["efficientnet",["EfficientNetForImageClassification",Wa]],["mobilenet_v1",["MobileNetV1ForImageClassification",Bd]],["mobilenet_v2",["MobileNetV2ForImageClassification",Mc]],["mobilenet_v3",["MobileNetV3ForImageClassification",ta]],["mobilenet_v4",["MobileNetV4ForImageClassification",Xl]]]),Ac=new Map([["detr",["DetrForObjectDetection",go]],["rt_detr",["RTDetrForObjectDetection",Fl]],["table-transformer",["TableTransformerForObjectDetection",Vi]],["yolos",["YolosForObjectDetection",Dl]]]),ru=new Map([["owlvit",["OwlViTForObjectDetection",Ca]],["owlv2",["Owlv2ForObjectDetection",$l]]]),Fc=new Map([["detr",["DetrForSegmentation",Al]],["clipseg",["CLIPSegForImageSegmentation",md]]]),Oc=new Map([["segformer",["SegformerForSemanticSegmentation",mc]],["sapiens",["SapiensForSemanticSegmentation",Od]]]),nu=new Map([["detr",["DetrForSegmentation",Al]],["maskformer",["MaskFormerForInstanceSegmentation",is]]]),Lc=new Map([["sam",["SamModel",Bl]]]),na=new Map([["wav2vec2",["Wav2Vec2ForCTC",Uo]],["wav2vec2-bert",["Wav2Vec2BertForCTC",lc]],["unispeech",["UniSpeechForCTC",Zs]],["unispeech-sat",["UniSpeechSatForCTC",to]],["wavlm",["WavLMForCTC",uc]],["hubert",["HubertForCTC",Zi]]]),Qa=new Map([["wav2vec2",["Wav2Vec2ForSequenceClassification",sc]],["wav2vec2-bert",["Wav2Vec2BertForSequenceClassification",Ji]],["unispeech",["UniSpeechForSequenceClassification",eo]],["unispeech-sat",["UniSpeechSatForSequenceClassification",bo]],["wavlm",["WavLMForSequenceClassification",cc]],["hubert",["HubertForSequenceClassification",Vo]],["audio-spectrogram-transformer",["ASTForAudioClassification",al]]]),sa=new Map([["wavlm",["WavLMForXVector",Hr]]]),Dc=new Map([["unispeech-sat",["UniSpeechSatForAudioFrameClassification",La]],["wavlm",["WavLMForAudioFrameClassification",Go]],["wav2vec2",["Wav2Vec2ForAudioFrameClassification",jl]],["pyannote",["PyAnnoteForAudioFrameClassification",ui]]]),su=new Map([["vitmatte",["VitMatteForImageMatting",Ri]]]),zc=new Map([["patchtst",["PatchTSTForPrediction",Yl]],["patchtsmixer",["PatchTSMixerForPrediction",qa]]]),Bc=new Map([["swin2sr",["Swin2SRForImageSuperResolution",vo]]]),oa=new Map([["dpt",["DPTForDepthEstimation",nn]],["depth_anything",["DepthAnythingForDepthEstimation",Ki]],["glpn",["GLPNForDepthEstimation",Js]],["sapiens",["SapiensForDepthEstimation",xo]],["depth_pro",["DepthProForDepthEstimation",qi]]]),Os=new Map([["sapiens",["SapiensForNormalEstimation",oi]]]),Qd=new Map([["vitpose",["VitPoseForPoseEstimation",_o]]]),Rc=new Map([["clip",["CLIPVisionModelWithProjection",Ma]],["siglip",["SiglipVisionModel",cd]],["jina_clip",["JinaCLIPVisionModel",fd]]]),Xa=[[Ec,X.EncoderOnly],[Pc,X.EncoderDecoder],[kp,X.DecoderOnly],[Gd,X.EncoderOnly],[kc,X.EncoderOnly],[$c,X.Seq2Seq],[Zl,X.Seq2Seq],[On,X.DecoderOnly],[Kn,X.MultiModality],[Ic,X.EncoderOnly],[Kd,X.EncoderOnly],[eu,X.Vision2Seq],[Hd,X.ImageTextToText],[tu,X.EncoderOnly],[Fc,X.EncoderOnly],[nu,X.EncoderOnly],[Oc,X.EncoderOnly],[su,X.EncoderOnly],[zc,X.EncoderOnly],[Bc,X.EncoderOnly],[oa,X.EncoderOnly],[Os,X.EncoderOnly],[Qd,X.EncoderOnly],[Ac,X.EncoderOnly],[ru,X.EncoderOnly],[Lc,X.MaskGeneration],[na,X.EncoderOnly],[Qa,X.EncoderOnly],[Cc,X.Seq2Seq],[Sc,X.EncoderOnly],[sa,X.EncoderOnly],[Dc,X.EncoderOnly],[Rc,X.EncoderOnly]];for(const[T,O]of Xa)for(const[G,$e]of T.values())W.set(G,O),z.set($e,G),b.set(G,$e);const Xd=[["MusicgenForConditionalGeneration",ql,X.Musicgen],["CLIPTextModelWithProjection",ul,X.EncoderOnly],["SiglipTextModel",ud,X.EncoderOnly],["JinaCLIPTextModel",pd,X.EncoderOnly],["ClapTextModelWithProjection",Ua,X.EncoderOnly],["ClapAudioModelWithProjection",Wl,X.EncoderOnly]];for(const[T,O,G]of Xd)W.set(T,G),z.set(O,T),b.set(T,O);class ou extends vr{}Fe(ou,"MODEL_CLASS_MAPPINGS",Xa.map(O=>O[0])),Fe(ou,"BASE_IF_FAIL",!0);class _i extends vr{}Fe(_i,"MODEL_CLASS_MAPPINGS",[Gd]);class An extends vr{}Fe(An,"MODEL_CLASS_MAPPINGS",[kc]);class Yd extends vr{}Fe(Yd,"MODEL_CLASS_MAPPINGS",[$c]);class Jd extends vr{}Fe(Jd,"MODEL_CLASS_MAPPINGS",[Zl]);class Ya extends vr{}Fe(Ya,"MODEL_CLASS_MAPPINGS",[Cc]);class Ln extends vr{}Fe(Ln,"MODEL_CLASS_MAPPINGS",[Sc]);class Zd extends vr{}Fe(Zd,"MODEL_CLASS_MAPPINGS",[On]);class Dt extends vr{}Fe(Dt,"MODEL_CLASS_MAPPINGS",[Ic]);class gi extends vr{}Fe(gi,"MODEL_CLASS_MAPPINGS",[Kd]);class iu extends vr{}Fe(iu,"MODEL_CLASS_MAPPINGS",[eu]);class ep extends vr{}Fe(ep,"MODEL_CLASS_MAPPINGS",[tu]);class tp extends vr{}Fe(tp,"MODEL_CLASS_MAPPINGS",[Fc]);class ia extends vr{}Fe(ia,"MODEL_CLASS_MAPPINGS",[Oc]);class Ja extends vr{}Fe(Ja,"MODEL_CLASS_MAPPINGS",[nu]);class jc extends vr{}Fe(jc,"MODEL_CLASS_MAPPINGS",[Ac]);class Nc extends vr{}Fe(Nc,"MODEL_CLASS_MAPPINGS",[ru]);class Uc extends vr{}Fe(Uc,"MODEL_CLASS_MAPPINGS",[Lc]);class Vc extends vr{}Fe(Vc,"MODEL_CLASS_MAPPINGS",[na]);class au extends vr{}Fe(au,"MODEL_CLASS_MAPPINGS",[Qa]);class lu extends vr{}Fe(lu,"MODEL_CLASS_MAPPINGS",[sa]);class Tn extends vr{}Fe(Tn,"MODEL_CLASS_MAPPINGS",[Dc]);class vs extends vr{}Fe(vs,"MODEL_CLASS_MAPPINGS",[qd]);class Eo extends vr{}Fe(Eo,"MODEL_CLASS_MAPPINGS",[su]);class Wc extends vr{}Fe(Wc,"MODEL_CLASS_MAPPINGS",[Bc]);class Gc extends vr{}Fe(Gc,"MODEL_CLASS_MAPPINGS",[oa]);class Ms extends vr{}Fe(Ms,"MODEL_CLASS_MAPPINGS",[Os]);class uu extends vr{}Fe(uu,"MODEL_CLASS_MAPPINGS",[Qd]);class Ls extends vr{}Fe(Ls,"MODEL_CLASS_MAPPINGS",[Rc]);class _p extends Ve{constructor({logits:O,past_key_values:G,encoder_outputs:$e,decoder_attentions:Ue=null,cross_attentions:ze=null}){super(),this.logits=O,this.past_key_values=G,this.encoder_outputs=$e,this.decoder_attentions=Ue,this.cross_attentions=ze}}class lr extends Ve{constructor({logits:O}){super(),this.logits=O}}class Kc extends Ve{constructor({logits:O,embeddings:G}){super(),this.logits=O,this.embeddings=G}}class wn extends Ve{constructor({logits:O}){super(),this.logits=O}}class bn extends Ve{constructor({logits:O}){super(),this.logits=O}}class Dn extends Ve{constructor({start_logits:O,end_logits:G}){super(),this.start_logits=O,this.end_logits=G}}class Po extends Ve{constructor({logits:O}){super(),this.logits=O}}class Hc extends Ve{constructor({logits:O,past_key_values:G}){super(),this.logits=O,this.past_key_values=G}}class cs extends Ve{constructor({alphas:O}){super(),this.alphas=O}}class Tr extends Ve{constructor({waveform:O,spectrogram:G}){super(),this.waveform=O,this.spectrogram=G}}},"./src/models/audio_spectrogram_transformer/feature_extraction_audio_spectrogram_transformer.js":(ke,V,f)=>{f.r(V),f.d(V,{ASTFeatureExtractor:()=>Q});var P=f("./src/base/feature_extraction_utils.js");f("./src/utils/tensor.js");var R=f("./src/utils/audio.js");class Q extends P.FeatureExtractor{constructor(oe){super(oe);const E=this.config.sampling_rate,C=(0,R.mel_filter_bank)(256,this.config.num_mel_bins,20,Math.floor(E/2),E,null,"kaldi",!0);for(let k=0;k<C.length;++k)C[k].push(0);this.mel_filters=C,this.window=(0,R.window_function)(400,"hann",{periodic:!1}),this.mean=this.config.mean,this.std=this.config.std}async _extract_fbank_features(oe,E){return(0,R.spectrogram)(oe,this.window,400,160,{fft_length:512,power:2,center:!1,preemphasis:.97,mel_filters:this.mel_filters,log_mel:"log",mel_floor:1192092955078125e-22,remove_dc_offset:!0,max_num_frames:E,transpose:!0})}async _call(oe){(0,P.validate_audio_inputs)(oe,"ASTFeatureExtractor");const E=await this._extract_fbank_features(oe,this.config.max_length);if(this.config.do_normalize){const C=this.std*2,k=E.data;for(let A=0;A<k.length;++A)k[A]=(k[A]-this.mean)/C}return{input_values:E.unsqueeze_(0)}}}},"./src/models/auto/feature_extraction_auto.js":(ke,V,f)=>{f.r(V),f.d(V,{AutoFeatureExtractor:()=>se});var P=f("./src/utils/constants.js"),R=f("./src/utils/hub.js");f("./src/base/feature_extraction_utils.js");var Q=f("./src/models/feature_extractors.js");class se{static async from_pretrained(E,C={}){const k=await(0,R.getModelJSON)(E,P.FEATURE_EXTRACTOR_NAME,!0,C),A=k.feature_extractor_type,$=Q[A];if(!$)throw new Error(`Unknown feature_extractor_type: '${A}'. Please report this at ${P.GITHUB_ISSUE_URL}.`);return new $(k)}}},"./src/models/auto/image_processing_auto.js":(ke,V,f)=>{f.r(V),f.d(V,{AutoImageProcessor:()=>oe});var P=f("./src/utils/constants.js"),R=f("./src/utils/hub.js"),Q=f("./src/base/image_processors_utils.js"),se=f("./src/models/image_processors.js");class oe{static async from_pretrained(C,k={}){const A=await(0,R.getModelJSON)(C,P.IMAGE_PROCESSOR_NAME,!0,k),$=A.image_processor_type??A.feature_extractor_type;let ae=se[$];return ae||($!==void 0&&console.warn(`Image processor type '${$}' not found, assuming base ImageProcessor. Please report this at ${P.GITHUB_ISSUE_URL}.`),ae=Q.ImageProcessor),new ae(A)}}},"./src/models/auto/processing_auto.js":(ke,V,f)=>{f.r(V),f.d(V,{AutoProcessor:()=>C});var P=f("./src/utils/constants.js"),R=f("./src/utils/hub.js"),Q=f("./src/base/processing_utils.js"),se=f("./src/models/processors.js"),oe=f("./src/models/image_processors.js"),E=f("./src/models/feature_extractors.js");class C{static async from_pretrained(A,$={}){const ae=await(0,R.getModelJSON)(A,P.IMAGE_PROCESSOR_NAME,!0,$),{image_processor_type:fe,feature_extractor_type:ge,processor_class:le}=ae;if(le&&se[le])return se[le].from_pretrained(A,$);if(!fe&&!ge)throw new Error("No `image_processor_type` or `feature_extractor_type` found in the config.");const q={};if(fe){const pe=oe[fe];if(!pe)throw new Error(`Unknown image_processor_type: '${fe}'.`);q.image_processor=new pe(ae)}if(ge){const pe=oe[ge];if(pe)q.image_processor=new pe(ae);else{const X=E[ge];if(!X)throw new Error(`Unknown feature_extractor_type: '${ge}'.`);q.feature_extractor=new X(ae)}}const ie={};return new Q.Processor(ie,q)}}},"./src/models/beit/image_processing_beit.js":(ke,V,f)=>{f.r(V),f.d(V,{BeitFeatureExtractor:()=>R});var P=f("./src/base/image_processors_utils.js");class R extends P.ImageProcessor{}},"./src/models/bit/image_processing_bit.js":(ke,V,f)=>{f.r(V),f.d(V,{BitImageProcessor:()=>R});var P=f("./src/base/image_processors_utils.js");class R extends P.ImageProcessor{}},"./src/models/chinese_clip/image_processing_chinese_clip.js":(ke,V,f)=>{f.r(V),f.d(V,{ChineseCLIPFeatureExtractor:()=>R});var P=f("./src/base/image_processors_utils.js");class R extends P.ImageProcessor{}},"./src/models/clap/feature_extraction_clap.js":(ke,V,f)=>{f.r(V),f.d(V,{ClapFeatureExtractor:()=>Q});var P=f("./src/base/feature_extraction_utils.js");f("./src/utils/tensor.js");var R=f("./src/utils/audio.js");class Q extends P.FeatureExtractor{constructor(oe){super(oe),this.mel_filters=(0,R.mel_filter_bank)(this.config.nb_frequency_bins,this.config.feature_size,this.config.frequency_min,this.config.frequency_max,this.config.sampling_rate,null,"htk"),this.mel_filters_slaney=(0,R.mel_filter_bank)(this.config.nb_frequency_bins,this.config.feature_size,this.config.frequency_min,this.config.frequency_max,this.config.sampling_rate,"slaney","slaney"),this.window=(0,R.window_function)(this.config.fft_window_size,"hann")}async _get_input_mel(oe,E,C,k){let A;const $=oe.length-E;if($>0)if(C==="rand_trunc"){const ae=Math.floor(Math.random()*($+1));oe=oe.subarray(ae,ae+E),A=await this._extract_fbank_features(oe,this.mel_filters_slaney,this.config.nb_max_samples)}else throw new Error(`Truncation strategy "${C}" not implemented`);else{if($<0){let ae=new Float64Array(E);if(ae.set(oe),k==="repeat")for(let fe=oe.length;fe<E;fe+=oe.length)ae.set(oe.subarray(0,Math.min(oe.length,E-fe)),fe);else if(k==="repeatpad")for(let fe=oe.length;fe<-$;fe+=oe.length)ae.set(oe,fe);oe=ae}if(C==="fusion")throw new Error(`Truncation strategy "${C}" not implemented`);A=await this._extract_fbank_features(oe,this.mel_filters_slaney,this.config.nb_max_samples)}return A.unsqueeze_(0)}async _extract_fbank_features(oe,E,C=null){return(0,R.spectrogram)(oe,this.window,this.config.fft_window_size,this.config.hop_length,{power:2,mel_filters:E,log_mel:"dB",max_num_frames:C,do_pad:!1,transpose:!0})}async _call(oe,{max_length:E=null}={}){return(0,P.validate_audio_inputs)(oe,"ClapFeatureExtractor"),{input_features:(await this._get_input_mel(oe,E??this.config.nb_max_samples,this.config.truncation,this.config.padding)).unsqueeze_(0)}}}},"./src/models/clip/image_processing_clip.js":(ke,V,f)=>{f.r(V),f.d(V,{CLIPFeatureExtractor:()=>Q,CLIPImageProcessor:()=>R});var P=f("./src/base/image_processors_utils.js");class R extends P.ImageProcessor{}class Q extends R{}},"./src/models/convnext/image_processing_convnext.js":(ke,V,f)=>{f.r(V),f.d(V,{ConvNextFeatureExtractor:()=>Q,ConvNextImageProcessor:()=>R});var P=f("./src/base/image_processors_utils.js");class R extends P.ImageProcessor{constructor(oe){super(oe),this.crop_pct=this.config.crop_pct??224/256}async resize(oe){var C;const E=(C=this.size)==null?void 0:C.shortest_edge;if(E===void 0)throw new Error("Size dictionary must contain 'shortest_edge' key.");if(E<384){const k=Math.floor(E/this.crop_pct),[A,$]=this.get_resize_output_image_size(oe,{shortest_edge:k});oe=await oe.resize(A,$,{resample:this.resample}),oe=await oe.center_crop(E,E)}else oe=await oe.resize(E,E,{resample:this.resample});return oe}}class Q extends R{}},"./src/models/deit/image_processing_deit.js":(ke,V,f)=>{f.r(V),f.d(V,{DeiTFeatureExtractor:()=>Q,DeiTImageProcessor:()=>R});var P=f("./src/base/image_processors_utils.js");class R extends P.ImageProcessor{}class Q extends R{}},"./src/models/detr/image_processing_detr.js":(ke,V,f)=>{f.r(V),f.d(V,{DetrFeatureExtractor:()=>se,DetrImageProcessor:()=>Q});var P=f("./src/base/image_processors_utils.js"),R=f("./src/utils/tensor.js");class Q extends P.ImageProcessor{async _call(E){const C=await super._call(E),k=[C.pixel_values.dims[0],64,64],A=(0,R.full)(k,1n);return{...C,pixel_mask:A}}post_process_object_detection(...E){return(0,P.post_process_object_detection)(...E)}post_process_panoptic_segmentation(...E){return(0,P.post_process_panoptic_segmentation)(...E)}post_process_instance_segmentation(...E){return(0,P.post_process_instance_segmentation)(...E)}}class se extends Q{}},"./src/models/donut/image_processing_donut.js":(ke,V,f)=>{f.r(V),f.d(V,{DonutFeatureExtractor:()=>Q,DonutImageProcessor:()=>R});var P=f("./src/base/image_processors_utils.js");class R extends P.ImageProcessor{pad_image(oe,E,C,k={}){const[A,$,ae]=E;let fe=this.image_mean;Array.isArray(this.image_mean)||(fe=new Array(ae).fill(fe));let ge=this.image_std;Array.isArray(ge)||(ge=new Array(ae).fill(fe));const le=fe.map((q,ie)=>-q/ge[ie]);return super.pad_image(oe,E,C,{center:!0,constant_values:le,...k})}}class Q extends R{}},"./src/models/dpt/image_processing_dpt.js":(ke,V,f)=>{f.r(V),f.d(V,{DPTFeatureExtractor:()=>Q,DPTImageProcessor:()=>R});var P=f("./src/base/image_processors_utils.js");class R extends P.ImageProcessor{}class Q extends R{}},"./src/models/efficientnet/image_processing_efficientnet.js":(ke,V,f)=>{f.r(V),f.d(V,{EfficientNetImageProcessor:()=>R});var P=f("./src/base/image_processors_utils.js");class R extends P.ImageProcessor{constructor(se){super(se),this.include_top=this.config.include_top??!0,this.include_top&&(this.image_std=this.image_std.map(oe=>oe*oe))}}},"./src/models/feature_extractors.js":(ke,V,f)=>{f.r(V),f.d(V,{ASTFeatureExtractor:()=>P.ASTFeatureExtractor,ClapFeatureExtractor:()=>R.ClapFeatureExtractor,ImageFeatureExtractor:()=>A.ImageProcessor,PyAnnoteFeatureExtractor:()=>Q.PyAnnoteFeatureExtractor,SeamlessM4TFeatureExtractor:()=>se.SeamlessM4TFeatureExtractor,SpeechT5FeatureExtractor:()=>oe.SpeechT5FeatureExtractor,Wav2Vec2FeatureExtractor:()=>E.Wav2Vec2FeatureExtractor,WeSpeakerFeatureExtractor:()=>C.WeSpeakerFeatureExtractor,WhisperFeatureExtractor:()=>k.WhisperFeatureExtractor});var P=f("./src/models/audio_spectrogram_transformer/feature_extraction_audio_spectrogram_transformer.js"),R=f("./src/models/clap/feature_extraction_clap.js"),Q=f("./src/models/pyannote/feature_extraction_pyannote.js"),se=f("./src/models/seamless_m4t/feature_extraction_seamless_m4t.js"),oe=f("./src/models/speecht5/feature_extraction_speecht5.js"),E=f("./src/models/wav2vec2/feature_extraction_wav2vec2.js"),C=f("./src/models/wespeaker/feature_extraction_wespeaker.js"),k=f("./src/models/whisper/feature_extraction_whisper.js"),A=f("./src/base/image_processors_utils.js")},"./src/models/florence2/processing_florence2.js":(ke,V,f)=>{f.r(V),f.d(V,{Florence2Processor:()=>se});var P=f("./src/base/processing_utils.js"),R=f("./src/models/auto/image_processing_auto.js"),Q=f("./src/tokenizers.js");class se extends P.Processor{constructor(E,C){super(E,C);const{tasks_answer_post_processing_type:k,task_prompts_without_inputs:A,task_prompts_with_input:$}=this.image_processor.config;this.tasks_answer_post_processing_type=new Map(Object.entries(k??{})),this.task_prompts_without_inputs=new Map(Object.entries(A??{})),this.task_prompts_with_input=new Map(Object.entries($??{})),this.regexes={quad_boxes:/(.+?)<loc_(\d+)><loc_(\d+)><loc_(\d+)><loc_(\d+)><loc_(\d+)><loc_(\d+)><loc_(\d+)><loc_(\d+)>/gm,bboxes:/([^<]+)?<loc_(\d+)><loc_(\d+)><loc_(\d+)><loc_(\d+)>/gm},this.size_per_bin=1e3}construct_prompts(E){typeof E=="string"&&(E=[E]);const C=[];for(const k of E)if(this.task_prompts_without_inputs.has(k))C.push(this.task_prompts_without_inputs.get(k));else{for(const[A,$]of this.task_prompts_with_input)if(k.includes(A)){C.push($.replaceAll("{input}",k).replaceAll(A,""));break}C.length!==E.length&&C.push(k)}return C}post_process_generation(E,C,k){const A=this.tasks_answer_post_processing_type.get(C)??"pure_text";E=E.replaceAll("<s>","").replaceAll("</s>","");let $;switch(A){case"pure_text":$=E;break;case"description_with_bboxes":case"bboxes":case"phrase_grounding":case"ocr":const ae=A==="ocr"?"quad_boxes":"bboxes",fe=E.matchAll(this.regexes[ae]),ge=[],le=[];for(const[q,ie,...pe]of fe)ge.push(ie?ie.trim():ge.at(-1)??""),le.push(pe.map((X,W)=>(Number(X)+.5)/this.size_per_bin*k[W%2]));$={labels:ge,[ae]:le};break;default:throw new Error(`Task "${C}" (of type "${A}") not yet implemented.`)}return{[C]:$}}async _call(E,C=null,k={}){if(!E&&!C)throw new Error("Either text or images must be provided");const A=await this.image_processor(E,k),$=C?this.tokenizer(C,k):{};return{...A,...$}}}Fe(se,"tokenizer_class",Q.AutoTokenizer),Fe(se,"image_processor_class",R.AutoImageProcessor)},"./src/models/glpn/image_processing_glpn.js":(ke,V,f)=>{f.r(V),f.d(V,{GLPNFeatureExtractor:()=>R});var P=f("./src/base/image_processors_utils.js");class R extends P.ImageProcessor{}},"./src/models/image_processors.js":(ke,V,f)=>{f.r(V),f.d(V,{BeitFeatureExtractor:()=>P.BeitFeatureExtractor,BitImageProcessor:()=>R.BitImageProcessor,CLIPFeatureExtractor:()=>se.CLIPFeatureExtractor,CLIPImageProcessor:()=>se.CLIPImageProcessor,ChineseCLIPFeatureExtractor:()=>Q.ChineseCLIPFeatureExtractor,ConvNextFeatureExtractor:()=>oe.ConvNextFeatureExtractor,ConvNextImageProcessor:()=>oe.ConvNextImageProcessor,DPTFeatureExtractor:()=>A.DPTFeatureExtractor,DPTImageProcessor:()=>A.DPTImageProcessor,DeiTFeatureExtractor:()=>E.DeiTFeatureExtractor,DeiTImageProcessor:()=>E.DeiTImageProcessor,DetrFeatureExtractor:()=>C.DetrFeatureExtractor,DetrImageProcessor:()=>C.DetrImageProcessor,DonutFeatureExtractor:()=>k.DonutFeatureExtractor,DonutImageProcessor:()=>k.DonutImageProcessor,EfficientNetImageProcessor:()=>$.EfficientNetImageProcessor,GLPNFeatureExtractor:()=>ae.GLPNFeatureExtractor,JinaCLIPImageProcessor:()=>ge.JinaCLIPImageProcessor,LlavaOnevisionImageProcessor:()=>le.LlavaOnevisionImageProcessor,Mask2FormerImageProcessor:()=>q.Mask2FormerImageProcessor,MaskFormerFeatureExtractor:()=>ie.MaskFormerFeatureExtractor,MaskFormerImageProcessor:()=>ie.MaskFormerImageProcessor,MobileNetV1FeatureExtractor:()=>pe.MobileNetV1FeatureExtractor,MobileNetV1ImageProcessor:()=>pe.MobileNetV1ImageProcessor,MobileNetV2FeatureExtractor:()=>X.MobileNetV2FeatureExtractor,MobileNetV2ImageProcessor:()=>X.MobileNetV2ImageProcessor,MobileNetV3FeatureExtractor:()=>W.MobileNetV3FeatureExtractor,MobileNetV3ImageProcessor:()=>W.MobileNetV3ImageProcessor,MobileNetV4FeatureExtractor:()=>b.MobileNetV4FeatureExtractor,MobileNetV4ImageProcessor:()=>b.MobileNetV4ImageProcessor,MobileViTFeatureExtractor:()=>z.MobileViTFeatureExtractor,MobileViTImageProcessor:()=>z.MobileViTImageProcessor,NougatImageProcessor:()=>L.NougatImageProcessor,OwlViTFeatureExtractor:()=>ce.OwlViTFeatureExtractor,OwlViTImageProcessor:()=>ce.OwlViTImageProcessor,Owlv2ImageProcessor:()=>de.Owlv2ImageProcessor,PvtImageProcessor:()=>Pe.PvtImageProcessor,Qwen2VLImageProcessor:()=>Ee.Qwen2VLImageProcessor,RTDetrImageProcessor:()=>Se.RTDetrImageProcessor,SamImageProcessor:()=>Be.SamImageProcessor,SegformerFeatureExtractor:()=>Le.SegformerFeatureExtractor,SegformerImageProcessor:()=>Le.SegformerImageProcessor,SiglipImageProcessor:()=>He.SiglipImageProcessor,Swin2SRImageProcessor:()=>Me.Swin2SRImageProcessor,VLMImageProcessor:()=>fe.VLMImageProcessor,ViTFeatureExtractor:()=>N.ViTFeatureExtractor,ViTImageProcessor:()=>N.ViTImageProcessor,VitMatteImageProcessor:()=>me.VitMatteImageProcessor,VitPoseImageProcessor:()=>ue.VitPoseImageProcessor,YolosFeatureExtractor:()=>ee.YolosFeatureExtractor,YolosImageProcessor:()=>ee.YolosImageProcessor});var P=f("./src/models/beit/image_processing_beit.js"),R=f("./src/models/bit/image_processing_bit.js"),Q=f("./src/models/chinese_clip/image_processing_chinese_clip.js"),se=f("./src/models/clip/image_processing_clip.js"),oe=f("./src/models/convnext/image_processing_convnext.js"),E=f("./src/models/deit/image_processing_deit.js"),C=f("./src/models/detr/image_processing_detr.js"),k=f("./src/models/donut/image_processing_donut.js"),A=f("./src/models/dpt/image_processing_dpt.js"),$=f("./src/models/efficientnet/image_processing_efficientnet.js"),ae=f("./src/models/glpn/image_processing_glpn.js"),fe=f("./src/models/janus/image_processing_janus.js"),ge=f("./src/models/jina_clip/image_processing_jina_clip.js"),le=f("./src/models/llava_onevision/image_processing_llava_onevision.js"),q=f("./src/models/mask2former/image_processing_mask2former.js"),ie=f("./src/models/maskformer/image_processing_maskformer.js"),pe=f("./src/models/mobilenet_v1/image_processing_mobilenet_v1.js"),X=f("./src/models/mobilenet_v2/image_processing_mobilenet_v2.js"),W=f("./src/models/mobilenet_v3/image_processing_mobilenet_v3.js"),b=f("./src/models/mobilenet_v4/image_processing_mobilenet_v4.js"),z=f("./src/models/mobilevit/image_processing_mobilevit.js"),L=f("./src/models/nougat/image_processing_nougat.js"),de=f("./src/models/owlv2/image_processing_owlv2.js"),ce=f("./src/models/owlvit/image_processing_owlvit.js"),Pe=f("./src/models/pvt/image_processing_pvt.js"),Ee=f("./src/models/qwen2_vl/image_processing_qwen2_vl.js"),Se=f("./src/models/rt_detr/image_processing_rt_detr.js"),Be=f("./src/models/sam/image_processing_sam.js"),Le=f("./src/models/segformer/image_processing_segformer.js"),He=f("./src/models/siglip/image_processing_siglip.js"),Me=f("./src/models/swin2sr/image_processing_swin2sr.js"),N=f("./src/models/vit/image_processing_vit.js"),me=f("./src/models/vitmatte/image_processing_vitmatte.js"),ue=f("./src/models/vitpose/image_processing_vitpose.js"),ee=f("./src/models/yolos/image_processing_yolos.js")},"./src/models/janus/image_processing_janus.js":(ke,V,f)=>{f.r(V),f.d(V,{VLMImageProcessor:()=>R});var P=f("./src/base/image_processors_utils.js");class R extends P.ImageProcessor{constructor(se){super({do_pad:!0,pad_size:{width:se.image_size,height:se.image_size},...se}),this.constant_values=this.config.background_color.map(oe=>oe*this.rescale_factor)}pad_image(se,oe,E,C){return super.pad_image(se,oe,E,{constant_values:this.constant_values,center:!0,...C})}}},"./src/models/janus/processing_janus.js":(ke,V,f)=>{f.r(V),f.d(V,{VLChatProcessor:()=>C});var P=f("./src/base/processing_utils.js"),R=f("./src/models/auto/image_processing_auto.js"),Q=f("./src/tokenizers.js"),se=f("./src/utils/core.js"),oe=f("./src/utils/tensor.js"),E=f("./src/utils/image.js");class C extends P.Processor{constructor(A,$){super(A,$),this.image_tag=this.config.image_tag,this.image_start_tag=this.config.image_start_tag,this.image_end_tag=this.config.image_end_tag,this.num_image_tokens=this.config.num_image_tokens}async _call(A,{images:$=null,chat_template:ae="default"}={}){$?Array.isArray($)||($=[$]):$=await Promise.all(A.filter(ce=>ce.images).flatMap(ce=>ce.images).map(ce=>E.RawImage.read(ce)));const fe=this.tokenizer,ge=fe.apply_chat_template(A,{tokenize:!1,add_generation_prompt:!0,chat_template:ae}),le=ce=>fe.encode(ce,{add_special_tokens:!1}),q=ge.split(this.image_tag),ie=q.length-1;if($.length!==ie)throw new Error(`Number of images provided (${$.length}) does not match number of "${this.image_tag}" image tags (${ie})`);const[pe,X,W]=fe.model.convert_tokens_to_ids([this.image_tag,this.image_start_tag,this.image_end_tag]);let b=le(q[0]),z=new Array(b.length).fill(!1);for(let ce=1;ce<q.length;++ce){const Pe=new Array(this.num_image_tokens).fill(pe),Ee=le(q[ce]);b=(0,se.mergeArrays)(b,[X],Pe,[W],Ee);const Se=new Array(this.num_image_tokens).fill(!0);z=(0,se.mergeArrays)(z,[!1],Se,[!1],new Array(Ee.length).fill(!1))}const L=[1,b.length],de={input_ids:new oe.Tensor("int64",b,L),attention_mask:new oe.Tensor("int64",new Array(b.length).fill(1),L),images_seq_mask:new oe.Tensor("bool",z,L),images_emb_mask:new oe.Tensor("bool",new Array(ie*this.num_image_tokens).fill(!0),[1,ie,this.num_image_tokens])};if($&&$.length>0){const ce=await this.image_processor($);return ce.pixel_values.unsqueeze_(0),{...de,...ce}}return de}}Fe(C,"image_processor_class",R.AutoImageProcessor),Fe(C,"tokenizer_class",Q.AutoTokenizer),Fe(C,"uses_processor_config",!0)},"./src/models/jina_clip/image_processing_jina_clip.js":(ke,V,f)=>{f.r(V),f.d(V,{JinaCLIPImageProcessor:()=>R});var P=f("./src/base/image_processors_utils.js");class R extends P.ImageProcessor{constructor(se){const{resize_mode:oe,fill_color:E,interpolation:C,size:k,...A}=se,$=oe==="squash"?{width:k,height:k}:oe==="shortest"?{shortest_edge:k}:{longest_edge:k},ae=C==="bicubic"?3:2;super({...A,size:$,resample:ae,do_center_crop:!0,crop_size:k,do_normalize:!0})}}},"./src/models/jina_clip/processing_jina_clip.js":(ke,V,f)=>{f.r(V),f.d(V,{JinaCLIPProcessor:()=>se});var P=f("./src/base/processing_utils.js"),R=f("./src/models/auto/image_processing_auto.js"),Q=f("./src/tokenizers.js");class se extends P.Processor{async _call(E=null,C=null,k={}){if(!E&&!C)throw new Error("Either text or images must be provided");const A=E?this.tokenizer(E,k):{},$=C?await this.image_processor(C,k):{};return{...A,...$}}}Fe(se,"tokenizer_class",Q.AutoTokenizer),Fe(se,"image_processor_class",R.AutoImageProcessor)},"./src/models/llava_onevision/image_processing_llava_onevision.js":(ke,V,f)=>{f.r(V),f.d(V,{LlavaOnevisionImageProcessor:()=>R});var P=f("./src/base/image_processors_utils.js");class R extends P.ImageProcessor{}},"./src/models/mask2former/image_processing_mask2former.js":(ke,V,f)=>{f.r(V),f.d(V,{Mask2FormerImageProcessor:()=>R});var P=f("./src/models/maskformer/image_processing_maskformer.js");class R extends P.MaskFormerImageProcessor{}},"./src/models/maskformer/image_processing_maskformer.js":(ke,V,f)=>{f.r(V),f.d(V,{MaskFormerFeatureExtractor:()=>Q,MaskFormerImageProcessor:()=>R});var P=f("./src/base/image_processors_utils.js");class R extends P.ImageProcessor{post_process_panoptic_segmentation(...oe){return(0,P.post_process_panoptic_segmentation)(...oe)}post_process_instance_segmentation(...oe){return(0,P.post_process_instance_segmentation)(...oe)}}class Q extends R{}},"./src/models/mgp_str/processing_mgp_str.js":(ke,V,f)=>{f.r(V),f.d(V,{MgpstrProcessor:()=>E});var P=f("./src/base/processing_utils.js"),R=f("./src/models/auto/image_processing_auto.js"),Q=f("./src/tokenizers.js"),se=f("./src/utils/maths.js");const oe={char:["char_decode",1],bpe:["bpe_decode",2],wp:["wp_decode",102]};class E extends P.Processor{get char_tokenizer(){return this.components.char_tokenizer}get bpe_tokenizer(){return this.components.bpe_tokenizer}get wp_tokenizer(){return this.components.wp_tokenizer}_decode_helper(k,A){if(!oe.hasOwnProperty(A))throw new Error(`Format ${A} is not supported.`);const[$,ae]=oe[A],fe=this[$].bind(this),[ge,le]=k.dims,q=[],ie=[],pe=k.tolist();for(let W=0;W<ge;++W){const b=pe[W],z=[],L=[];for(let ce=1;ce<le;++ce){const[Pe,Ee]=(0,se.max)((0,se.softmax)(b[ce]));if(L.push(Pe),Ee==ae)break;z.push(Ee)}const de=L.length>0?L.reduce((ce,Pe)=>ce*Pe,1):0;ie.push(z),q.push(de)}return[fe(ie),q]}char_decode(k){return this.char_tokenizer.batch_decode(k).map(A=>A.replaceAll(" ",""))}bpe_decode(k){return this.bpe_tokenizer.batch_decode(k)}wp_decode(k){return this.wp_tokenizer.batch_decode(k).map(A=>A.replaceAll(" ",""))}batch_decode([k,A,$]){const[ae,fe]=this._decode_helper(k,"char"),[ge,le]=this._decode_helper(A,"bpe"),[q,ie]=this._decode_helper($,"wp"),pe=[],X=[];for(let W=0;W<ae.length;++W){const[b,z]=(0,se.max)([fe[W],le[W],ie[W]]);pe.push([ae[W],ge[W],q[W]][z]),X.push(b)}return{generated_text:pe,scores:X,char_preds:ae,bpe_preds:ge,wp_preds:q}}static async from_pretrained(...k){const A=await super.from_pretrained(...k),$=await Q.AutoTokenizer.from_pretrained("Xenova/gpt2"),ae=await Q.AutoTokenizer.from_pretrained("Xenova/bert-base-uncased");return A.components={image_processor:A.image_processor,char_tokenizer:A.tokenizer,bpe_tokenizer:$,wp_tokenizer:ae},A}async _call(k,A=null){const $=await this.image_processor(k);return A&&($.labels=this.tokenizer(A).input_ids),$}}Fe(E,"tokenizer_class",Q.AutoTokenizer),Fe(E,"image_processor_class",R.AutoImageProcessor)},"./src/models/mobilenet_v1/image_processing_mobilenet_v1.js":(ke,V,f)=>{f.r(V),f.d(V,{MobileNetV1FeatureExtractor:()=>Q,MobileNetV1ImageProcessor:()=>R});var P=f("./src/base/image_processors_utils.js");class R extends P.ImageProcessor{}class Q extends R{}},"./src/models/mobilenet_v2/image_processing_mobilenet_v2.js":(ke,V,f)=>{f.r(V),f.d(V,{MobileNetV2FeatureExtractor:()=>Q,MobileNetV2ImageProcessor:()=>R});var P=f("./src/base/image_processors_utils.js");class R extends P.ImageProcessor{}class Q extends R{}},"./src/models/mobilenet_v3/image_processing_mobilenet_v3.js":(ke,V,f)=>{f.r(V),f.d(V,{MobileNetV3FeatureExtractor:()=>Q,MobileNetV3ImageProcessor:()=>R});var P=f("./src/base/image_processors_utils.js");class R extends P.ImageProcessor{}class Q extends R{}},"./src/models/mobilenet_v4/image_processing_mobilenet_v4.js":(ke,V,f)=>{f.r(V),f.d(V,{MobileNetV4FeatureExtractor:()=>Q,MobileNetV4ImageProcessor:()=>R});var P=f("./src/base/image_processors_utils.js");class R extends P.ImageProcessor{}class Q extends R{}},"./src/models/mobilevit/image_processing_mobilevit.js":(ke,V,f)=>{f.r(V),f.d(V,{MobileViTFeatureExtractor:()=>Q,MobileViTImageProcessor:()=>R});var P=f("./src/base/image_processors_utils.js");class R extends P.ImageProcessor{}class Q extends R{}},"./src/models/nougat/image_processing_nougat.js":(ke,V,f)=>{f.r(V),f.d(V,{NougatImageProcessor:()=>R});var P=f("./src/models/donut/image_processing_donut.js");class R extends P.DonutImageProcessor{}},"./src/models/owlv2/image_processing_owlv2.js":(ke,V,f)=>{f.r(V),f.d(V,{Owlv2ImageProcessor:()=>R});var P=f("./src/models/owlvit/image_processing_owlvit.js");class R extends P.OwlViTImageProcessor{}},"./src/models/owlvit/image_processing_owlvit.js":(ke,V,f)=>{f.r(V),f.d(V,{OwlViTFeatureExtractor:()=>Q,OwlViTImageProcessor:()=>R});var P=f("./src/base/image_processors_utils.js");class R extends P.ImageProcessor{post_process_object_detection(...oe){return(0,P.post_process_object_detection)(...oe)}}class Q extends R{}},"./src/models/owlvit/processing_owlvit.js":(ke,V,f)=>{f.r(V),f.d(V,{OwlViTProcessor:()=>se});var P=f("./src/base/processing_utils.js"),R=f("./src/models/auto/image_processing_auto.js"),Q=f("./src/tokenizers.js");class se extends P.Processor{}Fe(se,"tokenizer_class",Q.AutoTokenizer),Fe(se,"image_processor_class",R.AutoImageProcessor)},"./src/models/processors.js":(ke,V,f)=>{f.r(V),f.d(V,{Florence2Processor:()=>P.Florence2Processor,JinaCLIPProcessor:()=>se.JinaCLIPProcessor,MgpstrProcessor:()=>R.MgpstrProcessor,OwlViTProcessor:()=>oe.OwlViTProcessor,PyAnnoteProcessor:()=>E.PyAnnoteProcessor,Qwen2VLProcessor:()=>C.Qwen2VLProcessor,SamProcessor:()=>k.SamProcessor,SpeechT5Processor:()=>A.SpeechT5Processor,VLChatProcessor:()=>Q.VLChatProcessor,Wav2Vec2ProcessorWithLM:()=>$.Wav2Vec2ProcessorWithLM,WhisperProcessor:()=>ae.WhisperProcessor});var P=f("./src/models/florence2/processing_florence2.js"),R=f("./src/models/mgp_str/processing_mgp_str.js"),Q=f("./src/models/janus/processing_janus.js"),se=f("./src/models/jina_clip/processing_jina_clip.js"),oe=f("./src/models/owlvit/processing_owlvit.js"),E=f("./src/models/pyannote/processing_pyannote.js"),C=f("./src/models/qwen2_vl/processing_qwen2_vl.js"),k=f("./src/models/sam/processing_sam.js"),A=f("./src/models/speecht5/processing_speecht5.js"),$=f("./src/models/wav2vec2/processing_wav2vec2.js"),ae=f("./src/models/whisper/processing_whisper.js")},"./src/models/pvt/image_processing_pvt.js":(ke,V,f)=>{f.r(V),f.d(V,{PvtImageProcessor:()=>R});var P=f("./src/base/image_processors_utils.js");class R extends P.ImageProcessor{}},"./src/models/pyannote/feature_extraction_pyannote.js":(ke,V,f)=>{f.r(V),f.d(V,{PyAnnoteFeatureExtractor:()=>Q});var P=f("./src/base/feature_extraction_utils.js"),R=f("./src/utils/tensor.js");class Q extends P.FeatureExtractor{async _call(oe){(0,P.validate_audio_inputs)(oe,"PyAnnoteFeatureExtractor"),oe instanceof Float64Array&&(oe=new Float32Array(oe));const E=[1,1,oe.length];return{input_values:new R.Tensor("float32",oe,E)}}}},"./src/models/pyannote/processing_pyannote.js":(ke,V,f)=>{f.r(V),f.d(V,{PyAnnoteProcessor:()=>se});var P=f("./src/base/processing_utils.js"),R=f("./src/models/auto/feature_extraction_auto.js"),Q=f("./src/utils/maths.js");class se extends P.Processor{async _call(E){return await this.feature_extractor(E)}samples_to_frames(E){return(E-this.config.offset)/this.config.step}post_process_speaker_diarization(E,C){const k=C/this.samples_to_frames(C)/this.config.sampling_rate,A=[];for(const $ of E.tolist()){const ae=[];let fe=-1;for(let ge=0;ge<$.length;++ge){const le=(0,Q.softmax)($[ge]),[q,ie]=(0,Q.max)(le),[pe,X]=[ge,ge+1];ie!==fe?(fe=ie,ae.push({id:ie,start:pe,end:X,score:q})):(ae.at(-1).end=X,ae.at(-1).score+=q)}A.push(ae.map(({id:ge,start:le,end:q,score:ie})=>({id:ge,start:le*k,end:q*k,confidence:ie/(q-le)})))}return A}}Fe(se,"feature_extractor_class",R.AutoFeatureExtractor)},"./src/models/qwen2_vl/image_processing_qwen2_vl.js":(ke,V,f)=>{f.r(V),f.d(V,{Qwen2VLImageProcessor:()=>Q});var P=f("./src/base/image_processors_utils.js"),R=f("./src/utils/tensor.js");class Q extends P.ImageProcessor{async _call(oe,...E){const{pixel_values:C,original_sizes:k,reshaped_input_sizes:A}=await super._call(oe,...E);let $=C;const{temporal_patch_size:ae,merge_size:fe,patch_size:ge}=this.config;$.dims[0]===1&&($=(0,R.cat)(Array.from({length:ae},()=>$),0));const le=$.dims[0]/ae,q=$.dims[1],ie=Math.floor($.dims[2]/ge),pe=Math.floor($.dims[3]/ge),X=$.view(le,ae,q,Math.floor(ie/fe),fe,ge,Math.floor(pe/fe),fe,ge).permute(0,3,6,4,7,2,1,5,8).view(le*ie*pe,q*ae*ge*ge),W=new R.Tensor("int64",[le,ie,pe],[1,3]);return{pixel_values:X,image_grid_thw:W,original_sizes:k,reshaped_input_sizes:A}}}},"./src/models/qwen2_vl/processing_qwen2_vl.js":(ke,V,f)=>{f.r(V),f.d(V,{Qwen2VLProcessor:()=>se});var P=f("./src/base/processing_utils.js"),R=f("./src/models/auto/image_processing_auto.js"),Q=f("./src/tokenizers.js");f("./src/utils/image.js");class se extends P.Processor{async _call(E,C=null,...k){Array.isArray(E)||(E=[E]);let A,$;if(C&&(A=await this.image_processor(C),$=A.image_grid_thw),$){let fe=this.image_processor.config.merge_size**2,ge=0;const le=$.tolist();E=E.map(q=>{for(;q.includes("<|image_pad|>");){const ie=Number(le[ge++].reduce((pe,X)=>pe*X,1n));q=q.replace("<|image_pad|>","<|placeholder|>".repeat(Math.floor(ie/fe)))}return q.replaceAll("<|placeholder|>","<|image_pad|>")})}return{...this.tokenizer(E),...A}}}Fe(se,"image_processor_class",R.AutoImageProcessor),Fe(se,"tokenizer_class",Q.AutoTokenizer)},"./src/models/rt_detr/image_processing_rt_detr.js":(ke,V,f)=>{f.r(V),f.d(V,{RTDetrImageProcessor:()=>R});var P=f("./src/base/image_processors_utils.js");class R extends P.ImageProcessor{post_process_object_detection(...se){return(0,P.post_process_object_detection)(...se)}}},"./src/models/sam/image_processing_sam.js":(ke,V,f)=>{f.r(V),f.d(V,{SamImageProcessor:()=>se});var P=f("./src/base/image_processors_utils.js"),R=f("./src/utils/core.js"),Q=f("./src/utils/tensor.js");class se extends P.ImageProcessor{reshape_input_points(E,C,k,A=!1){E=structuredClone(E);let $=(0,R.calculateDimensions)(E);if($.length===3)A||($=[1,...$]),E=[E];else if($.length!==4)throw Error("The input_points must be a 4D tensor of shape `batch_size`, `point_batch_size`, `nb_points_per_image`, `2`.");for(let ae=0;ae<E.length;++ae){let fe=C[ae],ge=k[ae],le=[ge[0]/fe[0],ge[1]/fe[1]];for(let q=0;q<E[ae].length;++q)for(let ie=0;ie<E[ae][q].length;++ie)for(let pe=0;pe<E[ae][q][ie].length;++pe)E[ae][q][ie][pe]*=le[pe%2]}return new Q.Tensor("float32",Float32Array.from(E.flat(1/0)),$)}add_input_labels(E,C){let k=(0,R.calculateDimensions)(E);if(k.length===2)k=[1,...k],E=[E];else if(k.length!==3)throw Error("The input_points must be a 4D tensor of shape `batch_size`, `point_batch_size`, `nb_points_per_image`, `2`.");if(k.some((A,$)=>A!==C.dims[$]))throw Error(`The first ${k.length} dimensions of 'input_points' and 'input_labels' must be the same.`);return new Q.Tensor("int64",E.flat(1/0).map(BigInt),k)}async _call(E,{input_points:C=null,input_labels:k=null,input_boxes:A=null}={}){const $=await super._call(E);if(C&&($.input_points=this.reshape_input_points(C,$.original_sizes,$.reshaped_input_sizes)),k){if(!$.input_points)throw Error("`input_points` must be provided if `input_labels` are provided.");$.input_labels=this.add_input_labels(k,$.input_points)}return A&&($.input_boxes=this.reshape_input_points(A,$.original_sizes,$.reshaped_input_sizes,!0)),$}async post_process_masks(E,C,k,{mask_threshold:A=0,binarize:$=!0,pad_size:ae=null}={}){const fe=[];ae=ae??this.pad_size;const ge=[ae.height,ae.width];for(let le=0;le<C.length;++le){const q=C[le],ie=k[le];let pe=await(0,Q.interpolate_4d)(E[le],{mode:"bilinear",size:ge});if(pe=pe.slice(null,null,[0,ie[0]],[0,ie[1]]),pe=await(0,Q.interpolate_4d)(pe,{mode:"bilinear",size:q}),$){const X=pe.data,W=new Uint8Array(X.length);for(let b=0;b<X.length;++b)X[b]>A&&(W[b]=1);pe=new Q.Tensor("bool",W,pe.dims)}fe.push(pe)}return fe}generate_crop_boxes(E,C,{crop_n_layers:k=0,overlap_ratio:A=512/1500,points_per_crop:$=32,crop_n_points_downscale_factor:ae=1}={}){}}},"./src/models/sam/processing_sam.js":(ke,V,f)=>{f.r(V),f.d(V,{SamProcessor:()=>Q});var P=f("./src/base/processing_utils.js"),R=f("./src/models/auto/image_processing_auto.js");class Q extends P.Processor{async _call(...oe){return await this.image_processor(...oe)}post_process_masks(...oe){return this.image_processor.post_process_masks(...oe)}reshape_input_points(...oe){return this.image_processor.reshape_input_points(...oe)}}Fe(Q,"image_processor_class",R.AutoImageProcessor)},"./src/models/seamless_m4t/feature_extraction_seamless_m4t.js":(ke,V,f)=>{f.r(V),f.d(V,{SeamlessM4TFeatureExtractor:()=>se});var P=f("./src/base/feature_extraction_utils.js"),R=f("./src/utils/tensor.js"),Q=f("./src/utils/audio.js");class se extends P.FeatureExtractor{constructor(E){super(E);const C=this.config.sampling_rate,k=(0,Q.mel_filter_bank)(256,this.config.num_mel_bins,20,Math.floor(C/2),C,null,"kaldi",!0);for(let A=0;A<k.length;++A)k[A].push(0);this.mel_filters=k,this.window=(0,Q.window_function)(400,"povey",{periodic:!1})}async _extract_fbank_features(E,C){return E=E.map(k=>k*32768),(0,Q.spectrogram)(E,this.window,400,160,{fft_length:512,power:2,center:!1,preemphasis:.97,mel_filters:this.mel_filters,log_mel:"log",mel_floor:1192092955078125e-22,remove_dc_offset:!0,max_num_frames:C,transpose:!0})}async _call(E,{padding:C=!0,pad_to_multiple_of:k=2,do_normalize_per_mel_bins:A=!0,return_attention_mask:$=!0}={}){(0,P.validate_audio_inputs)(E,"SeamlessM4TFeatureExtractor");let ae=await this._extract_fbank_features(E,this.config.max_length);if(A){const[W,b]=ae.dims,z=ae.data;for(let L=0;L<b;++L){let de=0;for(let Se=0;Se<W;++Se)de+=z[Se*b+L];const ce=de/W;let Pe=0;for(let Se=0;Se<W;++Se)Pe+=(z[Se*b+L]-ce)**2;Pe/=W-1;const Ee=Math.sqrt(Pe+1e-7);for(let Se=0;Se<W;++Se){const Be=Se*b+L;z[Be]=(z[Be]-ce)/Ee}}}let fe;if(C){const[W,b]=ae.dims,z=ae.data,L=W%k;if(L>0){const de=new Float32Array(b*(W+L));de.set(z),de.fill(this.config.padding_value,z.length);const ce=W+L;ae=new R.Tensor(ae.type,de,[ce,b]),$&&(fe=new R.Tensor("int64",new BigInt64Array(ce),[1,ce]),fe.data.fill(1n,0,W))}}const[ge,le]=ae.dims,q=this.config.stride;if(ge%q!==0)throw new Error(`The number of frames (${ge}) must be a multiple of the stride (${q}).`);const pe=ae.view(1,Math.floor(ge/q),le*q),X={input_features:pe};if($){const W=pe.dims[1],b=new BigInt64Array(W);if(fe){const z=fe.data;for(let L=1,de=0;L<ge;L+=q,++de)b[de]=z[L]}else b.fill(1n);X.attention_mask=new R.Tensor("int64",b,[1,W])}return X}}},"./src/models/segformer/image_processing_segformer.js":(ke,V,f)=>{f.r(V),f.d(V,{SegformerFeatureExtractor:()=>Q,SegformerImageProcessor:()=>R});var P=f("./src/base/image_processors_utils.js");class R extends P.ImageProcessor{post_process_semantic_segmentation(...oe){return(0,P.post_process_semantic_segmentation)(...oe)}}class Q extends R{}},"./src/models/siglip/image_processing_siglip.js":(ke,V,f)=>{f.r(V),f.d(V,{SiglipImageProcessor:()=>R});var P=f("./src/base/image_processors_utils.js");class R extends P.ImageProcessor{}},"./src/models/speecht5/feature_extraction_speecht5.js":(ke,V,f)=>{f.r(V),f.d(V,{SpeechT5FeatureExtractor:()=>R});var P=f("./src/base/feature_extraction_utils.js");class R extends P.FeatureExtractor{}},"./src/models/speecht5/processing_speecht5.js":(ke,V,f)=>{f.r(V),f.d(V,{SpeechT5Processor:()=>se});var P=f("./src/base/processing_utils.js"),R=f("./src/tokenizers.js"),Q=f("./src/models/auto/feature_extraction_auto.js");class se extends P.Processor{async _call(E){return await this.feature_extractor(E)}}Fe(se,"tokenizer_class",R.AutoTokenizer),Fe(se,"feature_extractor_class",Q.AutoFeatureExtractor)},"./src/models/swin2sr/image_processing_swin2sr.js":(ke,V,f)=>{f.r(V),f.d(V,{Swin2SRImageProcessor:()=>R});var P=f("./src/base/image_processors_utils.js");class R extends P.ImageProcessor{pad_image(se,oe,E,C={}){const[k,A,$]=oe;return super.pad_image(se,oe,{width:A+(E-A%E)%E,height:k+(E-k%E)%E},{mode:"symmetric",center:!1,constant_values:-1,...C})}}},"./src/models/vit/image_processing_vit.js":(ke,V,f)=>{f.r(V),f.d(V,{ViTFeatureExtractor:()=>Q,ViTImageProcessor:()=>R});var P=f("./src/base/image_processors_utils.js");class R extends P.ImageProcessor{}class Q extends R{}},"./src/models/vitmatte/image_processing_vitmatte.js":(ke,V,f)=>{f.r(V),f.d(V,{VitMatteImageProcessor:()=>Q});var P=f("./src/base/image_processors_utils.js"),R=f("./src/utils/tensor.js");class Q extends P.ImageProcessor{async _call(oe,E){Array.isArray(oe)||(oe=[oe]),Array.isArray(E)||(E=[E]);const C=await Promise.all(oe.map($=>this.preprocess($))),k=await Promise.all(E.map($=>this.preprocess($,{do_normalize:!1,do_convert_rgb:!1,do_convert_grayscale:!0})));return{pixel_values:(0,R.stack)(C.map(($,ae)=>(0,R.cat)([$.pixel_values,k[ae].pixel_values],0)),0),original_sizes:C.map($=>$.original_size),reshaped_input_sizes:C.map($=>$.reshaped_input_size)}}}},"./src/models/vitpose/image_processing_vitpose.js":(ke,V,f)=>{f.r(V),f.d(V,{VitPoseImageProcessor:()=>R});var P=f("./src/base/image_processors_utils.js");class R extends P.ImageProcessor{post_process_pose_estimation(se,oe,{threshold:E=null}={}){const C=se.tolist(),[k,A,$,ae]=se.dims,fe=[];for(let ge=0;ge<k;++ge){const le=C[ge],q=oe[ge],ie=[];for(let pe=0;pe<q.length;++pe){const X=q[pe],W=[],b=[],z=[],L=X.at(-2)/ae,de=X.at(-1)/$;for(let ce=0;ce<le.length;++ce){let[Pe,Ee]=[0,0],Se=0,Be=-1/0;const Le=le[ce];for(let Me=0;Me<Le.length;++Me){const N=Le[Me];for(let me=0;me<N.length;++me){const ue=N[me];Se+=ue,Be=Math.max(Be,ue),Pe+=(me+.5)*ue,Ee+=Me*ue}}if(E!=null&&Be<E)continue;const He=[L*Pe/Se,de*Ee/Se];W.push(He),z.push(ce),b.push(Be)}ie.push({bbox:X,scores:b,labels:z,keypoints:W})}fe.push(ie)}return fe}}},"./src/models/wav2vec2/feature_extraction_wav2vec2.js":(ke,V,f)=>{f.r(V),f.d(V,{Wav2Vec2FeatureExtractor:()=>Q});var P=f("./src/base/feature_extraction_utils.js"),R=f("./src/utils/tensor.js");class Q extends P.FeatureExtractor{_zero_mean_unit_var_norm(oe){const C=oe.reduce((A,$)=>A+$,0)/oe.length,k=oe.reduce((A,$)=>A+($-C)**2,0)/oe.length;return oe.map(A=>(A-C)/Math.sqrt(k+1e-7))}async _call(oe){(0,P.validate_audio_inputs)(oe,"Wav2Vec2FeatureExtractor"),oe instanceof Float64Array&&(oe=new Float32Array(oe));let E=oe;this.config.do_normalize&&(E=this._zero_mean_unit_var_norm(E));const C=[1,E.length];return{input_values:new R.Tensor("float32",E,C),attention_mask:new R.Tensor("int64",new BigInt64Array(E.length).fill(1n),C)}}}},"./src/models/wav2vec2/processing_wav2vec2.js":(ke,V,f)=>{f.r(V),f.d(V,{Wav2Vec2ProcessorWithLM:()=>Q});var P=f("./src/base/processing_utils.js"),R=f("./src/models/auto/feature_extraction_auto.js");class Q extends P.Processor{async _call(oe){return await this.feature_extractor(oe)}}Fe(Q,"feature_extractor_class",R.AutoFeatureExtractor)},"./src/models/wespeaker/feature_extraction_wespeaker.js":(ke,V,f)=>{f.r(V),f.d(V,{WeSpeakerFeatureExtractor:()=>Q});var P=f("./src/base/feature_extraction_utils.js");f("./src/utils/tensor.js");var R=f("./src/utils/audio.js");class Q extends P.FeatureExtractor{constructor(oe){super(oe);const E=this.config.sampling_rate,C=(0,R.mel_filter_bank)(256,this.config.num_mel_bins,20,Math.floor(E/2),E,null,"kaldi",!0);for(let k=0;k<C.length;++k)C[k].push(0);this.mel_filters=C,this.window=(0,R.window_function)(400,"hamming",{periodic:!1}),this.min_num_frames=this.config.min_num_frames}async _extract_fbank_features(oe){return oe=oe.map(E=>E*32768),(0,R.spectrogram)(oe,this.window,400,160,{fft_length:512,power:2,center:!1,preemphasis:.97,mel_filters:this.mel_filters,log_mel:"log",mel_floor:1192092955078125e-22,remove_dc_offset:!0,transpose:!0,min_num_frames:this.min_num_frames})}async _call(oe){(0,P.validate_audio_inputs)(oe,"WeSpeakerFeatureExtractor");const E=(await this._extract_fbank_features(oe)).unsqueeze_(0);if(this.config.fbank_centering_span===null){const C=E.mean(1).data,k=E.data,[A,$,ae]=E.dims;for(let fe=0;fe<A;++fe){const ge=fe*$*ae,le=fe*ae;for(let q=0;q<$;++q){const ie=ge+q*ae;for(let pe=0;pe<ae;++pe)k[ie+pe]-=C[le+pe]}}}return{input_features:E}}}},"./src/models/whisper/common_whisper.js":(ke,V,f)=>{f.r(V),f.d(V,{WHISPER_LANGUAGE_MAPPING:()=>R,WHISPER_TO_LANGUAGE_CODE_MAPPING:()=>Q,whisper_language_to_code:()=>se});const P=[["en","english"],["zh","chinese"],["de","german"],["es","spanish"],["ru","russian"],["ko","korean"],["fr","french"],["ja","japanese"],["pt","portuguese"],["tr","turkish"],["pl","polish"],["ca","catalan"],["nl","dutch"],["ar","arabic"],["sv","swedish"],["it","italian"],["id","indonesian"],["hi","hindi"],["fi","finnish"],["vi","vietnamese"],["he","hebrew"],["uk","ukrainian"],["el","greek"],["ms","malay"],["cs","czech"],["ro","romanian"],["da","danish"],["hu","hungarian"],["ta","tamil"],["no","norwegian"],["th","thai"],["ur","urdu"],["hr","croatian"],["bg","bulgarian"],["lt","lithuanian"],["la","latin"],["mi","maori"],["ml","malayalam"],["cy","welsh"],["sk","slovak"],["te","telugu"],["fa","persian"],["lv","latvian"],["bn","bengali"],["sr","serbian"],["az","azerbaijani"],["sl","slovenian"],["kn","kannada"],["et","estonian"],["mk","macedonian"],["br","breton"],["eu","basque"],["is","icelandic"],["hy","armenian"],["ne","nepali"],["mn","mongolian"],["bs","bosnian"],["kk","kazakh"],["sq","albanian"],["sw","swahili"],["gl","galician"],["mr","marathi"],["pa","punjabi"],["si","sinhala"],["km","khmer"],["sn","shona"],["yo","yoruba"],["so","somali"],["af","afrikaans"],["oc","occitan"],["ka","georgian"],["be","belarusian"],["tg","tajik"],["sd","sindhi"],["gu","gujarati"],["am","amharic"],["yi","yiddish"],["lo","lao"],["uz","uzbek"],["fo","faroese"],["ht","haitian creole"],["ps","pashto"],["tk","turkmen"],["nn","nynorsk"],["mt","maltese"],["sa","sanskrit"],["lb","luxembourgish"],["my","myanmar"],["bo","tibetan"],["tl","tagalog"],["mg","malagasy"],["as","assamese"],["tt","tatar"],["haw","hawaiian"],["ln","lingala"],["ha","hausa"],["ba","bashkir"],["jw","javanese"],["su","sundanese"]],R=new Map(P),Q=new Map([...P.map(([oe,E])=>[E,oe]),["burmese","my"],["valencian","ca"],["flemish","nl"],["haitian","ht"],["letzeburgesch","lb"],["pushto","ps"],["panjabi","pa"],["moldavian","ro"],["moldovan","ro"],["sinhalese","si"],["castilian","es"]]);function se(oe){oe=oe.toLowerCase();let E=Q.get(oe);if(E===void 0)if(R.has(oe))E=oe;else{const k=oe.length===2?R.keys():R.values();throw new Error(`Language "${oe}" is not supported. Must be one of: ${JSON.stringify(k)}`)}return E}},"./src/models/whisper/feature_extraction_whisper.js":(ke,V,f)=>{f.r(V),f.d(V,{WhisperFeatureExtractor:()=>se});var P=f("./src/base/feature_extraction_utils.js");f("./src/utils/tensor.js");var R=f("./src/utils/audio.js"),Q=f("./src/utils/maths.js");class se extends P.FeatureExtractor{constructor(E){var C;super(E),(C=this.config).mel_filters??(C.mel_filters=(0,R.mel_filter_bank)(Math.floor(1+this.config.n_fft/2),this.config.feature_size,0,8e3,this.config.sampling_rate,"slaney","slaney")),this.window=(0,R.window_function)(this.config.n_fft,"hann")}async _extract_fbank_features(E){const C=await(0,R.spectrogram)(E,this.window,this.config.n_fft,this.config.hop_length,{power:2,mel_filters:this.config.mel_filters,log_mel:"log10",max_num_frames:this.config.nb_max_frames}),k=C.data,A=(0,Q.max)(k)[0];for(let $=0;$<k.length;++$)k[$]=(Math.max(k[$],A-8)+4)/4;return C}async _call(E){(0,P.validate_audio_inputs)(E,"WhisperFeatureExtractor");let C;return E.length>this.config.n_samples?(console.warn("Attempting to extract features for audio longer than 30 seconds. If using a pipeline to extract transcript from a long audio clip, remember to specify `chunk_length_s` and/or `stride_length_s`."),C=E.slice(0,this.config.n_samples)):(C=new Float32Array(this.config.n_samples),C.set(E)),{input_features:(await this._extract_fbank_features(C)).unsqueeze_(0)}}}},"./src/models/whisper/generation_whisper.js":(ke,V,f)=>{f.r(V),f.d(V,{WhisperGenerationConfig:()=>R});var P=f("./src/generation/configuration_utils.js");class R extends P.GenerationConfig{constructor(){super(...arguments);Fe(this,"return_timestamps",null);Fe(this,"return_token_timestamps",null);Fe(this,"num_frames",null);Fe(this,"alignment_heads",null);Fe(this,"task",null);Fe(this,"language",null);Fe(this,"no_timestamps_token_id",null);Fe(this,"prompt_ids",null);Fe(this,"is_multilingual",null);Fe(this,"lang_to_id",null);Fe(this,"task_to_id",null);Fe(this,"max_initial_timestamp_index",1)}}},"./src/models/whisper/processing_whisper.js":(ke,V,f)=>{f.r(V),f.d(V,{WhisperProcessor:()=>se});var P=f("./src/models/auto/feature_extraction_auto.js"),R=f("./src/tokenizers.js"),Q=f("./src/base/processing_utils.js");class se extends Q.Processor{async _call(E){return await this.feature_extractor(E)}}Fe(se,"tokenizer_class",R.AutoTokenizer),Fe(se,"feature_extractor_class",P.AutoFeatureExtractor)},"./src/models/yolos/image_processing_yolos.js":(ke,V,f)=>{f.r(V),f.d(V,{YolosFeatureExtractor:()=>Q,YolosImageProcessor:()=>R});var P=f("./src/base/image_processors_utils.js");class R extends P.ImageProcessor{post_process_object_detection(...oe){return(0,P.post_process_object_detection)(...oe)}}class Q extends R{}},"./src/ops/registry.js":(ke,V,f)=>{f.r(V),f.d(V,{TensorOpRegistry:()=>se});var P=f("./src/backends/onnx.js"),R=f("./src/utils/tensor.js");const Q=async(oe,E,C)=>{const k=await(0,P.createInferenceSession)(new Uint8Array(oe),E);return async A=>{const $=Object.fromEntries(Object.entries(A).map(([fe,ge])=>[fe,ge.ort_tensor])),ae=await k.run($);return Array.isArray(C)?C.map(fe=>new R.Tensor(ae[fe])):new R.Tensor(ae[C])}};class se{static get bilinear_interpolate_4d(){return this._bilinear_interpolate_4d||(this._bilinear_interpolate_4d=Q([8,9,18,0,58,128,1,10,40,10,1,120,10,0,10,0,10,1,115,18,1,121,34,6,82,101,115,105,122,101,42,17,10,4,109,111,100,101,34,6,108,105,110,101,97,114,160,1,3,18,1,114,90,31,10,1,120,18,26,10,24,8,1,18,20,10,3,18,1,98,10,3,18,1,99,10,3,18,1,104,10,3,18,1,119,90,15,10,1,115,18,10,10,8,8,7,18,4,10,2,8,4,98,31,10,1,121,18,26,10,24,8,1,18,20,10,3,18,1,98,10,3,18,1,99,10,3,18,1,104,10,3,18,1,119,66,2,16,20],this.session_options,"y")),this._bilinear_interpolate_4d}static get bicubic_interpolate_4d(){return this._bicubic_interpolate_4d||(this._bicubic_interpolate_4d=Q([8,9,18,0,58,127,10,39,10,1,120,10,0,10,0,10,1,115,18,1,121,34,6,82,101,115,105,122,101,42,16,10,4,109,111,100,101,34,5,99,117,98,105,99,160,1,3,18,1,114,90,31,10,1,120,18,26,10,24,8,1,18,20,10,3,18,1,98,10,3,18,1,99,10,3,18,1,104,10,3,18,1,119,90,15,10,1,115,18,10,10,8,8,7,18,4,10,2,8,4,98,31,10,1,121,18,26,10,24,8,1,18,20,10,3,18,1,98,10,3,18,1,99,10,3,18,1,104,10,3,18,1,119,66,2,16,20],this.session_options,"y")),this._bicubic_interpolate_4d}static get matmul(){return this._matmul||(this._matmul=Q([8,9,18,0,58,55,10,17,10,1,97,10,1,98,18,1,99,34,6,77,97,116,77,117,108,18,1,114,90,9,10,1,97,18,4,10,2,8,1,90,9,10,1,98,18,4,10,2,8,1,98,9,10,1,99,18,4,10,2,8,1,66,2,16,20],this.session_options,"c")),this._matmul}static get stft(){return this._stft||(this._stft=Q([8,7,18,0,58,148,1,10,38,10,1,115,10,1,106,10,1,119,10,1,108,18,1,111,34,4,83,84,70,84,42,15,10,8,111,110,101,115,105,100,101,100,24,1,160,1,2,18,1,115,90,26,10,1,115,18,21,10,19,8,1,18,15,10,3,18,1,98,10,3,18,1,115,10,3,18,1,99,90,11,10,1,106,18,6,10,4,8,7,18,0,90,16,10,1,119,18,11,10,9,8,1,18,5,10,3,18,1,119,90,11,10,1,108,18,6,10,4,8,7,18,0,98,31,10,1,111,18,26,10,24,8,1,18,20,10,3,18,1,98,10,3,18,1,102,10,3,18,1,100,10,3,18,1,99,66,2,16,17],this.session_options,"o")),this._stft}static get rfft(){return this._rfft||(this._rfft=Q([8,9,18,0,58,97,10,33,10,1,120,10,0,10,1,97,18,1,121,34,3,68,70,84,42,15,10,8,111,110,101,115,105,100,101,100,24,1,160,1,2,18,1,100,90,21,10,1,120,18,16,10,14,8,1,18,10,10,3,18,1,115,10,3,18,1,99,90,11,10,1,97,18,6,10,4,8,7,18,0,98,21,10,1,121,18,16,10,14,8,1,18,10,10,3,18,1,115,10,3,18,1,99,66,2,16,20],this.session_options,"y")),this._rfft}static get top_k(){return this._top_k||(this._top_k=Q([8,10,18,0,58,73,10,18,10,1,120,10,1,107,18,1,118,18,1,105,34,4,84,111,112,75,18,1,116,90,9,10,1,120,18,4,10,2,8,1,90,15,10,1,107,18,10,10,8,8,7,18,4,10,2,8,1,98,9,10,1,118,18,4,10,2,8,1,98,9,10,1,105,18,4,10,2,8,7,66,2,16,21],this.session_options,["v","i"])),this._top_k}}Fe(se,"session_options",{})},"./src/pipelines.js":(ke,V,f)=>{f.r(V),f.d(V,{AudioClassificationPipeline:()=>Ee,AutomaticSpeechRecognitionPipeline:()=>Be,DepthEstimationPipeline:()=>qe,DocumentQuestionAnsweringPipeline:()=>ee,FeatureExtractionPipeline:()=>ce,FillMaskPipeline:()=>pe,ImageClassificationPipeline:()=>He,ImageFeatureExtractionPipeline:()=>Pe,ImageSegmentationPipeline:()=>Me,ImageToImagePipeline:()=>je,ImageToTextPipeline:()=>Le,ObjectDetectionPipeline:()=>me,Pipeline:()=>ge,QuestionAnsweringPipeline:()=>ie,SummarizationPipeline:()=>W,Text2TextGenerationPipeline:()=>X,TextClassificationPipeline:()=>le,TextGenerationPipeline:()=>L,TextToAudioPipeline:()=>Te,TokenClassificationPipeline:()=>q,TranslationPipeline:()=>b,ZeroShotAudioClassificationPipeline:()=>Se,ZeroShotClassificationPipeline:()=>de,ZeroShotImageClassificationPipeline:()=>N,ZeroShotObjectDetectionPipeline:()=>ue,pipeline:()=>Ve});var P=f("./src/tokenizers.js"),R=f("./src/models.js"),Q=f("./src/models/auto/processing_auto.js");f("./src/base/processing_utils.js");var se=f("./src/utils/generic.js"),oe=f("./src/utils/core.js"),E=f("./src/utils/maths.js"),C=f("./src/utils/audio.js"),k=f("./src/utils/tensor.js"),A=f("./src/utils/image.js");async function $(We){return Array.isArray(We)||(We=[We]),await Promise.all(We.map(be=>A.RawImage.read(be)))}async function ae(We,be){return Array.isArray(We)||(We=[We]),await Promise.all(We.map(Re=>typeof Re=="string"||Re instanceof URL?(0,C.read_audio)(Re,be):Re instanceof Float64Array?new Float32Array(Re):Re))}function fe(We,be){be&&(We=We.map(Xe=>Xe|0));const[Re,lt,ot,st]=We;return{xmin:Re,ymin:lt,xmax:ot,ymax:st}}class ge extends se.Callable{constructor({task:be,model:Re,tokenizer:lt=null,processor:ot=null}){super(),this.task=be,this.model=Re,this.tokenizer=lt,this.processor=ot}async dispose(){await this.model.dispose()}}class le extends ge{constructor(be){super(be)}async _call(be,{top_k:Re=1}={}){const lt=this.tokenizer(be,{padding:!0,truncation:!0}),ot=await this.model(lt),st=this.model.config.problem_type==="multi_label_classification"?_t=>_t.sigmoid():_t=>new k.Tensor("float32",(0,E.softmax)(_t.data),_t.dims),Xe=this.model.config.id2label,pt=[];for(const _t of ot.logits){const Et=st(_t),wt=await(0,k.topk)(Et,Re),vt=wt[0].tolist(),_e=wt[1].tolist().map((Z,xe)=>({label:Xe?Xe[Z]:`LABEL_${Z}`,score:vt[xe]}));Re===1?pt.push(..._e):pt.push(_e)}return Array.isArray(be)||Re===1?pt:pt[0]}}class q extends ge{constructor(be){super(be)}async _call(be,{ignore_labels:Re=["O"]}={}){const lt=Array.isArray(be),ot=this.tokenizer(lt?be:[be],{padding:!0,truncation:!0}),Xe=(await this.model(ot)).logits,pt=this.model.config.id2label,_t=[];for(let Et=0;Et<Xe.dims[0];++Et){const wt=ot.input_ids[Et],vt=Xe[Et],U=[];for(let _e=0;_e<vt.dims[0];++_e){const Z=vt[_e],xe=(0,E.max)(Z.data)[1],Ne=pt?pt[xe]:`LABEL_${xe}`;if(Re.includes(Ne))continue;const at=this.tokenizer.decode([wt[_e].item()],{skip_special_tokens:!0});if(at==="")continue;const ct=(0,E.softmax)(Z.data);U.push({entity:Ne,score:ct[xe],index:_e,word:at})}_t.push(U)}return lt?_t:_t[0]}}class ie extends ge{constructor(be){super(be)}async _call(be,Re,{top_k:lt=1}={}){const ot=this.tokenizer(be,{text_pair:Re,padding:!0,truncation:!0}),{start_logits:st,end_logits:Xe}=await this.model(ot),pt=ot.input_ids.tolist(),_t=ot.attention_mask.tolist(),Et=this.tokenizer.all_special_ids,wt=[];for(let vt=0;vt<st.dims[0];++vt){const U=pt[vt],_e=U.findIndex(gt=>gt==this.tokenizer.sep_token_id);_t[vt].map((gt,zt)=>gt==1&&(zt===0||zt>_e&&Et.findIndex($t=>$t==U[zt])===-1));const Z=st[vt].tolist(),xe=Xe[vt].tolist();for(let gt=1;gt<Z.length;++gt)(_t[vt]==0||gt<=_e||Et.findIndex(zt=>zt==U[gt])!==-1)&&(Z[gt]=-1/0,xe[gt]=-1/0);const Ne=(0,E.softmax)(Z).map((gt,zt)=>[gt,zt]),at=(0,E.softmax)(xe).map((gt,zt)=>[gt,zt]);Ne[0][0]=0,at[0][0]=0;const ct=(0,oe.product)(Ne,at).filter(gt=>gt[0][1]<=gt[1][1]).map(gt=>[gt[0][1],gt[1][1],gt[0][0]*gt[1][0]]).sort((gt,zt)=>zt[2]-gt[2]);for(let gt=0;gt<Math.min(ct.length,lt);++gt){const[zt,$t,St]=ct[gt],Ft=U.slice(zt,$t+1),gr=this.tokenizer.decode(Ft,{skip_special_tokens:!0});wt.push({answer:gr,score:St})}}return lt===1?wt[0]:wt}}class pe extends ge{constructor(be){super(be)}async _call(be,{top_k:Re=5}={}){const lt=this.tokenizer(be,{padding:!0,truncation:!0}),{logits:ot}=await this.model(lt),st=[],Xe=lt.input_ids.tolist();for(let pt=0;pt<Xe.length;++pt){const _t=Xe[pt],Et=_t.findIndex(Z=>Z==this.tokenizer.mask_token_id);if(Et===-1)throw Error(`Mask token (${this.tokenizer.mask_token}) not found in text.`);const wt=ot[pt][Et],vt=await(0,k.topk)(new k.Tensor("float32",(0,E.softmax)(wt.data),wt.dims),Re),U=vt[0].tolist(),_e=vt[1].tolist();st.push(_e.map((Z,xe)=>{const Ne=_t.slice();return Ne[Et]=Z,{score:U[xe],token:Number(Z),token_str:this.tokenizer.model.vocab[Z],sequence:this.tokenizer.decode(Ne,{skip_special_tokens:!0})}}))}return Array.isArray(be)?st:st[0]}}class X extends ge{constructor(Re){super(Re);Fe(this,"_key","generated_text")}async _call(Re,lt={}){Array.isArray(Re)||(Re=[Re]),this.model.config.prefix&&(Re=Re.map(Et=>this.model.config.prefix+Et));const ot=this.model.config.task_specific_params;ot&&ot[this.task]&&ot[this.task].prefix&&(Re=Re.map(Et=>ot[this.task].prefix+Et));const st=this.tokenizer,Xe={padding:!0,truncation:!0};let pt;this instanceof b&&"_build_translation_inputs"in st?pt=st._build_translation_inputs(Re,Xe,lt):pt=st(Re,Xe);const _t=await this.model.generate({...pt,...lt});return st.batch_decode(_t,{skip_special_tokens:!0}).map(Et=>({[this._key]:Et}))}}class W extends X{constructor(Re){super(Re);Fe(this,"_key","summary_text")}}class b extends X{constructor(Re){super(Re);Fe(this,"_key","translation_text")}}function z(We){return Array.isArray(We)&&We.every(be=>"role"in be&&"content"in be)}class L extends ge{constructor(be){super(be)}async _call(be,Re={}){let lt=!1,ot=!1,st;if(typeof be=="string")st=be=[be];else if(Array.isArray(be)&&be.every(_e=>typeof _e=="string"))lt=!0,st=be;else{if(z(be))be=[be];else if(Array.isArray(be)&&be.every(z))lt=!0;else throw new Error("Input must be a string, an array of strings, a Chat, or an array of Chats");ot=!0,st=be.map(_e=>this.tokenizer.apply_chat_template(_e,{tokenize:!1,add_generation_prompt:!0}))}const Xe=Re.add_special_tokens??!1,pt=ot?!1:Re.return_full_text??!0;this.tokenizer.padding_side="left";const _t=this.tokenizer(st,{add_special_tokens:Xe,padding:!0,truncation:!0}),Et=await this.model.generate({..._t,...Re}),wt=this.tokenizer.batch_decode(Et,{skip_special_tokens:!0});let vt;!pt&&_t.input_ids.dims.at(-1)>0&&(vt=this.tokenizer.batch_decode(_t.input_ids,{skip_special_tokens:!0}).map(_e=>_e.length));const U=Array.from({length:be.length},_e=>[]);for(let _e=0;_e<wt.length;++_e){const Z=Math.floor(_e/Et.dims[0]*be.length);vt&&(wt[_e]=wt[_e].slice(vt[Z])),U[Z].push({generated_text:ot?[...be[Z],{role:"assistant",content:wt[_e]}]:wt[_e]})}return!lt&&U.length===1?U[0]:U}}class de extends ge{constructor(be){super(be),this.label2id=Object.fromEntries(Object.entries(this.model.config.label2id).map(([Re,lt])=>[Re.toLowerCase(),lt])),this.entailment_id=this.label2id.entailment,this.entailment_id===void 0&&(console.warn("Could not find 'entailment' in label2id mapping. Using 2 as entailment_id."),this.entailment_id=2),this.contradiction_id=this.label2id.contradiction??this.label2id.not_entailment,this.contradiction_id===void 0&&(console.warn("Could not find 'contradiction' in label2id mapping. Using 0 as contradiction_id."),this.contradiction_id=0)}async _call(be,Re,{hypothesis_template:lt="This example is {}.",multi_label:ot=!1}={}){const st=Array.isArray(be);st||(be=[be]),Array.isArray(Re)||(Re=[Re]);const Xe=Re.map(Et=>lt.replace("{}",Et)),pt=ot||Re.length===1,_t=[];for(const Et of be){const wt=[];for(const _e of Xe){const Z=this.tokenizer(Et,{text_pair:_e,padding:!0,truncation:!0}),xe=await this.model(Z);pt?wt.push([xe.logits.data[this.contradiction_id],xe.logits.data[this.entailment_id]]):wt.push(xe.logits.data[this.entailment_id])}const U=(pt?wt.map(_e=>(0,E.softmax)(_e)[1]):(0,E.softmax)(wt)).map((_e,Z)=>[_e,Z]).sort((_e,Z)=>Z[0]-_e[0]);_t.push({sequence:Et,labels:U.map(_e=>Re[_e[1]]),scores:U.map(_e=>_e[0])})}return st?_t:_t[0]}}class ce extends ge{constructor(be){super(be)}async _call(be,{pooling:Re="none",normalize:lt=!1,quantize:ot=!1,precision:st="binary"}={}){const Xe=this.tokenizer(be,{padding:!0,truncation:!0}),pt=await this.model(Xe);let _t=pt.last_hidden_state??pt.logits??pt.token_embeddings;if(Re!=="none")if(Re==="mean")_t=(0,k.mean_pooling)(_t,Xe.attention_mask);else if(Re==="cls")_t=_t.slice(null,0);else throw Error(`Pooling method '${Re}' not supported.`);return lt&&(_t=_t.normalize(2,-1)),ot&&(_t=(0,k.quantize_embeddings)(_t,st)),_t}}class Pe extends ge{constructor(be){super(be)}async _call(be,{pool:Re=null}={}){const lt=await $(be),{pixel_values:ot}=await this.processor(lt),st=await this.model({pixel_values:ot});let Xe;if(Re){if(!("pooler_output"in st))throw Error("No pooled output was returned. Make sure the model has a 'pooler' layer when using the 'pool' option.");Xe=st.pooler_output}else Xe=st.last_hidden_state??st.logits??st.image_embeds;return Xe}}class Ee extends ge{constructor(be){super(be)}async _call(be,{top_k:Re=5}={}){const lt=this.processor.feature_extractor.config.sampling_rate,ot=await ae(be,lt),st=this.model.config.id2label,Xe=[];for(const pt of ot){const _t=await this.processor(pt),wt=(await this.model(_t)).logits[0],vt=await(0,k.topk)(new k.Tensor("float32",(0,E.softmax)(wt.data),wt.dims),Re),U=vt[0].tolist(),Z=vt[1].tolist().map((xe,Ne)=>({label:st?st[xe]:`LABEL_${xe}`,score:U[Ne]}));Xe.push(Z)}return Array.isArray(be)?Xe:Xe[0]}}class Se extends ge{constructor(be){super(be)}async _call(be,Re,{hypothesis_template:lt="This is a sound of {}."}={}){const ot=!Array.isArray(be);ot&&(be=[be]);const st=Re.map(wt=>lt.replace("{}",wt)),Xe=this.tokenizer(st,{padding:!0,truncation:!0}),pt=this.processor.feature_extractor.config.sampling_rate,_t=await ae(be,pt),Et=[];for(const wt of _t){const vt=await this.processor(wt),U=await this.model({...Xe,...vt}),_e=(0,E.softmax)(U.logits_per_audio.data);Et.push([..._e].map((Z,xe)=>({score:Z,label:Re[xe]})))}return ot?Et[0]:Et}}class Be extends ge{constructor(be){super(be)}async _call(be,Re={}){switch(this.model.config.model_type){case"whisper":return this._call_whisper(be,Re);case"wav2vec2":case"wav2vec2-bert":case"unispeech":case"unispeech-sat":case"hubert":return this._call_wav2vec2(be,Re);default:throw new Error(`AutomaticSpeechRecognitionPipeline does not support model type '${this.model.config.model_type}'.`)}}async _call_wav2vec2(be,Re){Re.language&&console.warn('`language` parameter is not yet supported for `wav2vec2` models, defaulting to "English".'),Re.task&&console.warn('`task` parameter is not yet supported for `wav2vec2` models, defaulting to "transcribe".');const lt=!Array.isArray(be);lt&&(be=[be]);const ot=this.processor.feature_extractor.config.sampling_rate,st=await ae(be,ot),Xe=[];for(const pt of st){const _t=await this.processor(pt),wt=(await this.model(_t)).logits[0],vt=[];for(const _e of wt)vt.push((0,E.max)(_e.data)[1]);const U=this.tokenizer.decode(vt);Xe.push({text:U})}return lt?Xe[0]:Xe}async _call_whisper(be,Re){const lt=Re.return_timestamps??!1,ot=Re.chunk_length_s??0,st=Re.force_full_sequences??!1;let Xe=Re.stride_length_s??null;const pt={...Re};lt==="word"&&(pt.return_token_timestamps=!0,pt.return_timestamps=!1);const _t=!Array.isArray(be);_t&&(be=[be]);const Et=this.processor.feature_extractor.config.chunk_length/this.model.config.max_source_positions,wt=this.processor.feature_extractor.config.hop_length,vt=this.processor.feature_extractor.config.sampling_rate,U=await ae(be,vt),_e=[];for(const Z of U){let xe=[];if(ot>0){if(Xe===null)Xe=ot/6;else if(ot<=Xe)throw Error("`chunk_length_s` must be larger than `stride_length_s`.");const ct=vt*ot,gt=vt*Xe,zt=ct-2*gt;let $t=0;for(;;){const St=$t+ct,Ft=Z.subarray($t,St),gr=await this.processor(Ft),Cr=$t===0,rn=St>=Z.length;if(xe.push({stride:[Ft.length,Cr?0:gt,rn?0:gt],input_features:gr.input_features,is_last:rn}),rn)break;$t+=zt}}else xe=[{stride:[Z.length,0,0],input_features:(await this.processor(Z)).input_features,is_last:!0}];for(const ct of xe){pt.num_frames=Math.floor(ct.stride[0]/wt);const gt=await this.model.generate({inputs:ct.input_features,...pt});lt==="word"?(ct.tokens=gt.sequences.tolist()[0],ct.token_timestamps=gt.token_timestamps.tolist()[0].map(zt=>(0,E.round)(zt,2))):ct.tokens=gt[0].tolist(),ct.stride=ct.stride.map(zt=>zt/vt)}const[Ne,at]=this.tokenizer._decode_asr(xe,{time_precision:Et,return_timestamps:lt,force_full_sequences:st});_e.push({text:Ne,...at})}return _t?_e[0]:_e}}class Le extends ge{constructor(be){super(be)}async _call(be,Re={}){const lt=Array.isArray(be),ot=await $(be),{pixel_values:st}=await this.processor(ot),Xe=[];for(const pt of st){pt.dims=[1,...pt.dims];const _t=await this.model.generate({inputs:pt,...Re}),Et=this.tokenizer.batch_decode(_t,{skip_special_tokens:!0}).map(wt=>({generated_text:wt.trim()}));Xe.push(Et)}return lt?Xe:Xe[0]}}class He extends ge{constructor(be){super(be)}async _call(be,{top_k:Re=5}={}){const lt=await $(be),{pixel_values:ot}=await this.processor(lt),st=await this.model({pixel_values:ot}),Xe=this.model.config.id2label,pt=[];for(const _t of st.logits){const Et=await(0,k.topk)(new k.Tensor("float32",(0,E.softmax)(_t.data),_t.dims),Re),wt=Et[0].tolist(),U=Et[1].tolist().map((_e,Z)=>({label:Xe?Xe[_e]:`LABEL_${_e}`,score:wt[Z]}));pt.push(U)}return Array.isArray(be)?pt:pt[0]}}class Me extends ge{constructor(be){super(be),this.subtasks_mapping={panoptic:"post_process_panoptic_segmentation",instance:"post_process_instance_segmentation",semantic:"post_process_semantic_segmentation"}}async _call(be,{threshold:Re=.5,mask_threshold:lt=.5,overlap_mask_area_threshold:ot=.8,label_ids_to_fuse:st=null,target_sizes:Xe=null,subtask:pt=null}={}){if(Array.isArray(be)&&be.length!==1)throw Error("Image segmentation pipeline currently only supports a batch size of 1.");const Et=await $(be),wt=Et.map(at=>[at.height,at.width]),{pixel_values:vt,pixel_mask:U}=await this.processor(Et),_e=await this.model({pixel_values:vt,pixel_mask:U});let Z=null;if(pt!==null)Z=this.subtasks_mapping[pt];else for(let[at,ct]of Object.entries(this.subtasks_mapping))if(ct in this.processor.image_processor){Z=this.processor.image_processor[ct].bind(this.processor.image_processor),pt=at;break}const xe=this.model.config.id2label,Ne=[];if(pt==="panoptic"||pt==="instance"){const at=Z(_e,Re,lt,ot,st,Xe??wt)[0],ct=at.segmentation;for(const gt of at.segments_info){const zt=new Uint8ClampedArray(ct.data.length);for(let St=0;St<ct.data.length;++St)ct.data[St]===gt.id&&(zt[St]=255);const $t=new A.RawImage(zt,ct.dims[1],ct.dims[0],1);Ne.push({score:gt.score,label:xe[gt.label_id],mask:$t})}}else if(pt==="semantic"){const{segmentation:at,labels:ct}=Z(_e,Xe??wt)[0];for(const gt of ct){const zt=new Uint8ClampedArray(at.data.length);for(let St=0;St<at.data.length;++St)at.data[St]===gt&&(zt[St]=255);const $t=new A.RawImage(zt,at.dims[1],at.dims[0],1);Ne.push({score:null,label:xe[gt],mask:$t})}}else throw Error(`Subtask ${pt} not supported.`);return Ne}}class N extends ge{constructor(be){super(be)}async _call(be,Re,{hypothesis_template:lt="This is a photo of {}"}={}){const ot=Array.isArray(be),st=await $(be),Xe=Re.map(U=>lt.replace("{}",U)),pt=this.tokenizer(Xe,{padding:this.model.config.model_type==="siglip"?"max_length":!0,truncation:!0}),{pixel_values:_t}=await this.processor(st),Et=await this.model({...pt,pixel_values:_t}),wt=this.model.config.model_type==="siglip"?U=>U.sigmoid().data:U=>(0,E.softmax)(U.data),vt=[];for(const U of Et.logits_per_image){const Z=[...wt(U)].map((xe,Ne)=>({score:xe,label:Re[Ne]}));Z.sort((xe,Ne)=>Ne.score-xe.score),vt.push(Z)}return ot?vt:vt[0]}}class me extends ge{constructor(be){super(be)}async _call(be,{threshold:Re=.9,percentage:lt=!1}={}){const ot=Array.isArray(be);if(ot&&be.length!==1)throw Error("Object detection pipeline currently only supports a batch size of 1.");const st=await $(be),Xe=lt?null:st.map(_e=>[_e.height,_e.width]),{pixel_values:pt,pixel_mask:_t}=await this.processor(st),Et=await this.model({pixel_values:pt,pixel_mask:_t}),wt=this.processor.image_processor.post_process_object_detection(Et,Re,Xe),vt=this.model.config.id2label,U=wt.map(_e=>_e.boxes.map((Z,xe)=>({score:_e.scores[xe],label:vt[_e.classes[xe]],box:fe(Z,!lt)})));return ot?U:U[0]}}class ue extends ge{constructor(be){super(be)}async _call(be,Re,{threshold:lt=.1,top_k:ot=null,percentage:st=!1}={}){const Xe=Array.isArray(be),pt=await $(be),_t=this.tokenizer(Re,{padding:!0,truncation:!0}),Et=await this.processor(pt),wt=[];for(let vt=0;vt<pt.length;++vt){const U=pt[vt],_e=st?null:[[U.height,U.width]],Z=Et.pixel_values[vt].unsqueeze_(0),xe=await this.model({..._t,pixel_values:Z}),Ne=this.processor.image_processor.post_process_object_detection(xe,lt,_e,!0)[0];let at=Ne.boxes.map((ct,gt)=>({score:Ne.scores[gt],label:Re[Ne.classes[gt]],box:fe(ct,!st)})).sort((ct,gt)=>gt.score-ct.score);ot!==null&&(at=at.slice(0,ot)),wt.push(at)}return Xe?wt:wt[0]}}class ee extends ge{constructor(be){super(be)}async _call(be,Re,lt={}){const ot=(await $(be))[0],{pixel_values:st}=await this.processor(ot),Xe=`<s_docvqa><s_question>${Re}</s_question><s_answer>`,pt=this.tokenizer(Xe,{add_special_tokens:!1,padding:!0,truncation:!0}).input_ids,_t=await this.model.generate({inputs:st,max_length:this.model.config.decoder.max_position_embeddings,decoder_input_ids:pt,...lt}),wt=this.tokenizer.batch_decode(_t)[0].match(/<s_answer>(.*?)<\/s_answer>/);let vt=null;return wt&&wt.length>=2&&(vt=wt[1].trim()),[{answer:vt}]}}class Te extends ge{constructor(Re){super(Re);Fe(this,"DEFAULT_VOCODER_ID","Xenova/speecht5_hifigan");this.vocoder=Re.vocoder??null}async _call(Re,{speaker_embeddings:lt=null}={}){return this.processor?this._call_text_to_spectrogram(Re,{speaker_embeddings:lt}):this._call_text_to_waveform(Re)}async _call_text_to_waveform(Re){const lt=this.tokenizer(Re,{padding:!0,truncation:!0}),{waveform:ot}=await this.model(lt),st=this.model.config.sampling_rate;return{audio:ot.data,sampling_rate:st}}async _call_text_to_spectrogram(Re,{speaker_embeddings:lt}){if(this.vocoder||(console.log("No vocoder specified, using default HifiGan vocoder."),this.vocoder=await R.AutoModel.from_pretrained(this.DEFAULT_VOCODER_ID,{dtype:"fp32"})),(typeof lt=="string"||lt instanceof URL)&&(lt=new Float32Array(await(await fetch(lt)).arrayBuffer())),lt instanceof Float32Array)lt=new k.Tensor("float32",lt,[1,lt.length]);else if(!(lt instanceof k.Tensor))throw new Error("Speaker embeddings must be a `Tensor`, `Float32Array`, `string`, or `URL`.");const{input_ids:ot}=this.tokenizer(Re,{padding:!0,truncation:!0}),{waveform:st}=await this.model.generate_speech(ot,lt,{vocoder:this.vocoder}),Xe=this.processor.feature_extractor.config.sampling_rate;return{audio:st.data,sampling_rate:Xe}}}class je extends ge{constructor(be){super(be)}async _call(be){const Re=await $(be),lt=await this.processor(Re),ot=await this.model(lt),st=[];for(const Xe of ot.reconstruction){const pt=Xe.squeeze().clamp_(0,1).mul_(255).round_().to("uint8");st.push(A.RawImage.fromTensor(pt))}return st.length>1?st:st[0]}}class qe extends ge{constructor(be){super(be)}async _call(be){const Re=await $(be),lt=await this.processor(Re),{predicted_depth:ot}=await this.model(lt),st=[];for(let Xe=0;Xe<Re.length;++Xe){const pt=(0,k.interpolate)(ot[Xe],Re[Xe].size.reverse(),"bilinear",!1),_t=pt.mul_(255/(0,E.max)(pt.data)[0]).to("uint8");st.push({predicted_depth:ot[Xe],depth:A.RawImage.fromTensor(_t)})}return st.length>1?st:st[0]}}const tt=Object.freeze({"text-classification":{tokenizer:P.AutoTokenizer,pipeline:le,model:R.AutoModelForSequenceClassification,default:{model:"Xenova/distilbert-base-uncased-finetuned-sst-2-english"},type:"text"},"token-classification":{tokenizer:P.AutoTokenizer,pipeline:q,model:R.AutoModelForTokenClassification,default:{model:"Xenova/bert-base-multilingual-cased-ner-hrl"},type:"text"},"question-answering":{tokenizer:P.AutoTokenizer,pipeline:ie,model:R.AutoModelForQuestionAnswering,default:{model:"Xenova/distilbert-base-cased-distilled-squad"},type:"text"},"fill-mask":{tokenizer:P.AutoTokenizer,pipeline:pe,model:R.AutoModelForMaskedLM,default:{model:"Xenova/bert-base-uncased"},type:"text"},summarization:{tokenizer:P.AutoTokenizer,pipeline:W,model:R.AutoModelForSeq2SeqLM,default:{model:"Xenova/distilbart-cnn-6-6"},type:"text"},translation:{tokenizer:P.AutoTokenizer,pipeline:b,model:R.AutoModelForSeq2SeqLM,default:{model:"Xenova/t5-small"},type:"text"},"text2text-generation":{tokenizer:P.AutoTokenizer,pipeline:X,model:R.AutoModelForSeq2SeqLM,default:{model:"Xenova/flan-t5-small"},type:"text"},"text-generation":{tokenizer:P.AutoTokenizer,pipeline:L,model:R.AutoModelForCausalLM,default:{model:"Xenova/gpt2"},type:"text"},"zero-shot-classification":{tokenizer:P.AutoTokenizer,pipeline:de,model:R.AutoModelForSequenceClassification,default:{model:"Xenova/distilbert-base-uncased-mnli"},type:"text"},"audio-classification":{pipeline:Ee,model:R.AutoModelForAudioClassification,processor:Q.AutoProcessor,default:{model:"Xenova/wav2vec2-base-superb-ks"},type:"audio"},"zero-shot-audio-classification":{tokenizer:P.AutoTokenizer,pipeline:Se,model:R.AutoModel,processor:Q.AutoProcessor,default:{model:"Xenova/clap-htsat-unfused"},type:"multimodal"},"automatic-speech-recognition":{tokenizer:P.AutoTokenizer,pipeline:Be,model:[R.AutoModelForSpeechSeq2Seq,R.AutoModelForCTC],processor:Q.AutoProcessor,default:{model:"Xenova/whisper-tiny.en"},type:"multimodal"},"text-to-audio":{tokenizer:P.AutoTokenizer,pipeline:Te,model:[R.AutoModelForTextToWaveform,R.AutoModelForTextToSpectrogram],processor:[Q.AutoProcessor,null],default:{model:"Xenova/speecht5_tts"},type:"text"},"image-to-text":{tokenizer:P.AutoTokenizer,pipeline:Le,model:R.AutoModelForVision2Seq,processor:Q.AutoProcessor,default:{model:"Xenova/vit-gpt2-image-captioning"},type:"multimodal"},"image-classification":{pipeline:He,model:R.AutoModelForImageClassification,processor:Q.AutoProcessor,default:{model:"Xenova/vit-base-patch16-224"},type:"multimodal"},"image-segmentation":{pipeline:Me,model:[R.AutoModelForImageSegmentation,R.AutoModelForSemanticSegmentation,R.AutoModelForUniversalSegmentation],processor:Q.AutoProcessor,default:{model:"Xenova/detr-resnet-50-panoptic"},type:"multimodal"},"zero-shot-image-classification":{tokenizer:P.AutoTokenizer,pipeline:N,model:R.AutoModel,processor:Q.AutoProcessor,default:{model:"Xenova/clip-vit-base-patch32"},type:"multimodal"},"object-detection":{pipeline:me,model:R.AutoModelForObjectDetection,processor:Q.AutoProcessor,default:{model:"Xenova/detr-resnet-50"},type:"multimodal"},"zero-shot-object-detection":{tokenizer:P.AutoTokenizer,pipeline:ue,model:R.AutoModelForZeroShotObjectDetection,processor:Q.AutoProcessor,default:{model:"Xenova/owlvit-base-patch32"},type:"multimodal"},"document-question-answering":{tokenizer:P.AutoTokenizer,pipeline:ee,model:R.AutoModelForDocumentQuestionAnswering,processor:Q.AutoProcessor,default:{model:"Xenova/donut-base-finetuned-docvqa"},type:"multimodal"},"image-to-image":{pipeline:je,model:R.AutoModelForImageToImage,processor:Q.AutoProcessor,default:{model:"Xenova/swin2SR-classical-sr-x2-64"},type:"image"},"depth-estimation":{pipeline:qe,model:R.AutoModelForDepthEstimation,processor:Q.AutoProcessor,default:{model:"Xenova/dpt-large"},type:"image"},"feature-extraction":{tokenizer:P.AutoTokenizer,pipeline:ce,model:R.AutoModel,default:{model:"Xenova/all-MiniLM-L6-v2"},type:"text"},"image-feature-extraction":{processor:Q.AutoProcessor,pipeline:Pe,model:[R.AutoModelForImageFeatureExtraction,R.AutoModel],default:{model:"Xenova/vit-base-patch16-224-in21k"},type:"image"}}),he=Object.freeze({"sentiment-analysis":"text-classification",ner:"token-classification",asr:"automatic-speech-recognition","text-to-speech":"text-to-audio",embeddings:"feature-extraction"});async function Ve(We,be=null,{progress_callback:Re=null,config:lt=null,cache_dir:ot=null,local_files_only:st=!1,revision:Xe="main",device:pt=null,dtype:_t=null,model_file_name:Et=null,session_options:wt={}}={}){We=he[We]??We;const vt=tt[We.split("_",1)[0]];if(!vt)throw Error(`Unsupported pipeline: ${We}. Must be one of [${Object.keys(tt)}]`);be||(be=vt.default.model,console.log(`No model specified. Using default model: "${be}".`));const U={progress_callback:Re,config:lt,cache_dir:ot,local_files_only:st,revision:Xe,device:pt,dtype:_t,model_file_name:Et,session_options:wt},_e=new Map([["tokenizer",vt.tokenizer],["model",vt.model],["processor",vt.processor]]),Z=await Je(_e,be,U);Z.task=We,(0,oe.dispatchCallback)(Re,{status:"ready",task:We,model:be});const xe=vt.pipeline;return new xe(Z)}async function Je(We,be,Re){const lt=Object.create(null),ot=[];for(const[st,Xe]of We.entries()){if(!Xe)continue;let pt;Array.isArray(Xe)?pt=new Promise(async(_t,Et)=>{var vt,U;let wt;for(const _e of Xe){if(_e===null){_t(null);return}try{_t(await _e.from_pretrained(be,Re));return}catch(Z){if((vt=Z.message)!=null&&vt.includes("Unsupported model type"))wt=Z;else if((U=Z.message)!=null&&U.includes("Could not locate file"))wt=Z;else{Et(Z);return}}}Et(wt)}):pt=Xe.from_pretrained(be,Re),lt[st]=pt,ot.push(pt)}await Promise.all(ot);for(const[st,Xe]of Object.entries(lt))lt[st]=await Xe;return lt}},"./src/tokenizers.js":(ke,V,f)=>{f.r(V),f.d(V,{AlbertTokenizer:()=>Vs,AutoTokenizer:()=>kr,BartTokenizer:()=>ao,BertTokenizer:()=>fs,BlenderbotSmallTokenizer:()=>ga,BlenderbotTokenizer:()=>_a,BloomTokenizer:()=>Ss,CLIPTokenizer:()=>jn,CamembertTokenizer:()=>dt,CodeGenTokenizer:()=>co,CodeLlamaTokenizer:()=>Ei,CohereTokenizer:()=>Ks,ConvBertTokenizer:()=>hs,DebertaTokenizer:()=>ts,DebertaV2Tokenizer:()=>oo,DistilBertTokenizer:()=>Cn,ElectraTokenizer:()=>jt,EsmTokenizer:()=>ma,FalconTokenizer:()=>Ci,GPT2Tokenizer:()=>Ws,GPTNeoXTokenizer:()=>uo,GemmaTokenizer:()=>il,Grok1Tokenizer:()=>Gs,HerbertTokenizer:()=>io,LlamaTokenizer:()=>lo,M2M100Tokenizer:()=>Si,MBart50Tokenizer:()=>rs,MBartTokenizer:()=>Dr,MPNetTokenizer:()=>Pi,MarianTokenizer:()=>Rt,MgpstrTokenizer:()=>ya,MobileBertTokenizer:()=>so,NllbTokenizer:()=>Rn,NougatTokenizer:()=>Fo,PreTrainedTokenizer:()=>Gt,Qwen2Tokenizer:()=>Yr,RoFormerTokenizer:()=>Cs,RobertaTokenizer:()=>zr,SiglipTokenizer:()=>po,SpeechT5Tokenizer:()=>fo,SqueezeBertTokenizer:()=>Io,T5Tokenizer:()=>ln,TokenizerModel:()=>Pe,VitsTokenizer:()=>ho,Wav2Vec2CTCTokenizer:()=>ki,WhisperTokenizer:()=>Ao,XLMRobertaTokenizer:()=>ha,XLMTokenizer:()=>Pt,is_chinese_char:()=>pe});var P=f("./src/utils/generic.js"),R=f("./src/utils/core.js"),Q=f("./src/utils/hub.js"),se=f("./src/utils/maths.js"),oe=f("./src/utils/tensor.js"),E=f("./src/utils/data-structures.js"),C=f("./node_modules/@huggingface/jinja/dist/index.js"),k=f("./src/models/whisper/common_whisper.js");f("./src/utils/constants.js");async function A(Oe,I){const ne=await Promise.all([(0,Q.getModelJSON)(Oe,"tokenizer.json",!0,I),(0,Q.getModelJSON)(Oe,"tokenizer_config.json",!0,I)]);return I.legacy!==null&&(ne[1].legacy=I.legacy),ne}function $(Oe,I){const ne=[];let we=0;for(const Ie of Oe.matchAll(I)){const De=Ie[0];we<Ie.index&&ne.push(Oe.slice(we,Ie.index)),De.length>0&&ne.push(De),we=Ie.index+De.length}return we<Oe.length&&ne.push(Oe.slice(we)),ne}function ae(Oe,I=!0){if(Oe.Regex!==void 0){let ne=Oe.Regex.replace(/\\([#&~])/g,"$1");for(const[we,Ie]of de)ne=ne.replaceAll(we,Ie);return new RegExp(ne,"gu")}else if(Oe.String!==void 0){const ne=(0,R.escapeRegExp)(Oe.String);return new RegExp(I?ne:`(${ne})`,"gu")}else return console.warn("Unknown pattern type:",Oe),null}function fe(Oe){return new Map(Object.entries(Oe))}function ge(Oe){const I=Oe.dims;switch(I.length){case 1:return Oe.tolist();case 2:if(I[0]!==1)throw new Error("Unable to decode tensor with `batch size !== 1`. Use `tokenizer.batch_decode(...)` for batched inputs.");return Oe.tolist()[0];default:throw new Error(`Expected tensor to have 1-2 dimensions, got ${I.length}.`)}}function le(Oe){return Oe.replace(/ \./g,".").replace(/ \?/g,"?").replace(/ \!/g,"!").replace(/ ,/g,",").replace(/ \' /g,"'").replace(/ n\'t/g,"n't").replace(/ \'m/g,"'m").replace(/ \'s/g,"'s").replace(/ \'ve/g,"'ve").replace(/ \'re/g,"'re")}function q(Oe){return Oe.replace(new RegExp("\\p{M}","gu"),"")}function ie(Oe){return q(Oe.toLowerCase())}function pe(Oe){return Oe>=19968&&Oe<=40959||Oe>=13312&&Oe<=19903||Oe>=131072&&Oe<=173791||Oe>=173824&&Oe<=177983||Oe>=177984&&Oe<=178207||Oe>=178208&&Oe<=183983||Oe>=63744&&Oe<=64255||Oe>=194560&&Oe<=195103}function X(Oe,I,ne){const we=[];let Ie=0;for(;Ie<Oe.length;){if(we.push(Oe[Ie]),(I.get(Oe[Ie])??ne)!==ne){++Ie;continue}for(;++Ie<Oe.length&&(I.get(Oe[Ie])??ne)===ne;)I.get(we.at(-1))!==ne&&(we[we.length-1]+=Oe[Ie])}return we}function W(Oe){return Oe.match(/\S+/g)||[]}const b="\\p{P}\\u0021-\\u002F\\u003A-\\u0040\\u005B-\\u0060\\u007B-\\u007E",z=new RegExp(`^[${b}]+$`,"gu"),L=".,!?",de=new Map([["(?i:'s|'t|'re|'ve|'m|'ll|'d)","(?:'([sS]|[tT]|[rR][eE]|[vV][eE]|[mM]|[lL][lL]|[dD]))"],[` ?[^(\\s|[${L}])]+`,` ?[^\\s${L}]+`]]);class ce{constructor(I){this.content=I.content,this.id=I.id,this.single_word=I.single_word??!1,this.lstrip=I.lstrip??!1,this.rstrip=I.rstrip??!1,this.special=I.special??!1,this.normalized=I.normalized??null}}class Pe extends P.Callable{constructor(I){super(),this.config=I,this.vocab=[],this.tokens_to_ids=new Map,this.unk_token_id=void 0,this.unk_token=void 0,this.end_of_word_suffix=void 0,this.fuse_unk=this.config.fuse_unk??!1}static fromConfig(I,...ne){switch(I.type){case"WordPiece":return new Ee(I);case"Unigram":return new Se(I,...ne);case"BPE":return new He(I);default:if(I.vocab)return Array.isArray(I.vocab)?new Se(I,...ne):new Me(I,...ne);throw new Error(`Unknown TokenizerModel type: ${I.type}`)}}_call(I){return I=this.encode(I),this.fuse_unk&&(I=X(I,this.tokens_to_ids,this.unk_token_id)),I}encode(I){throw Error("encode should be implemented in subclass.")}convert_tokens_to_ids(I){return I.map(ne=>this.tokens_to_ids.get(ne)??this.unk_token_id)}convert_ids_to_tokens(I){return I.map(ne=>this.vocab[ne]??this.unk_token)}}class Ee extends Pe{constructor(I){super(I),this.tokens_to_ids=fe(I.vocab),this.unk_token_id=this.tokens_to_ids.get(I.unk_token),this.unk_token=I.unk_token,this.max_input_chars_per_word=I.max_input_chars_per_word??100,this.vocab=new Array(this.tokens_to_ids.size);for(const[ne,we]of this.tokens_to_ids)this.vocab[we]=ne}encode(I){const ne=[];for(const we of I){const Ie=[...we];if(Ie.length>this.max_input_chars_per_word){ne.push(this.unk_token);continue}let De=!1,Ge=0;const mt=[];for(;Ge<Ie.length;){let bt=Ie.length,yt=null;for(;Ge<bt;){let kt=Ie.slice(Ge,bt).join("");if(Ge>0&&(kt=this.config.continuing_subword_prefix+kt),this.tokens_to_ids.has(kt)){yt=kt;break}--bt}if(yt===null){De=!0;break}mt.push(yt),Ge=bt}De?ne.push(this.unk_token):ne.push(...mt)}return ne}}class Se extends Pe{constructor(I,ne){super(I);const we=I.vocab.length;this.vocab=new Array(we),this.scores=new Array(we);for(let Ie=0;Ie<we;++Ie){const De=I.vocab[Ie];this.vocab[Ie]=De[0],this.scores[Ie]=De[1]}this.unk_token_id=I.unk_id,this.unk_token=this.vocab[I.unk_id],this.tokens_to_ids=new Map(this.vocab.map((Ie,De)=>[Ie,De])),this.bos_token=" ",this.bos_token_id=this.tokens_to_ids.get(this.bos_token),this.eos_token=ne.eos_token,this.eos_token_id=this.tokens_to_ids.get(this.eos_token),this.unk_token=this.vocab[this.unk_token_id],this.minScore=(0,se.min)(this.scores)[0],this.unk_score=this.minScore-10,this.scores[this.unk_token_id]=this.unk_score,this.trie=new E.CharTrie,this.trie.extend(this.vocab),this.fuse_unk=!0}populateNodes(I){const ne=I.chars,we=1;let Ie=0;for(;Ie<ne.length;){let De=!1;const Ge=ne.slice(Ie).join(""),mt=this.trie.commonPrefixSearch(Ge);for(const bt of mt){const yt=this.tokens_to_ids.get(bt),kt=this.scores[yt],Zt=(0,R.len)(bt);I.insert(Ie,Zt,kt,yt),!De&&Zt===we&&(De=!0)}De||I.insert(Ie,we,this.unk_score,this.unk_token_id),Ie+=we}}tokenize(I){const ne=new E.TokenLattice(I,this.bos_token_id,this.eos_token_id);return this.populateNodes(ne),ne.tokens()}encode(I){const ne=[];for(const we of I){const Ie=this.tokenize(we);ne.push(...Ie)}return ne}}const Be=(()=>{const Oe=[...Array.from({length:94},(Ie,De)=>De+33),...Array.from({length:12},(Ie,De)=>De+161),...Array.from({length:82},(Ie,De)=>De+174)],I=Oe.slice();let ne=0;for(let Ie=0;Ie<256;++Ie)Oe.includes(Ie)||(Oe.push(Ie),I.push(256+ne),ne+=1);const we=I.map(Ie=>String.fromCharCode(Ie));return Object.fromEntries(Oe.map((Ie,De)=>[Ie,we[De]]))})(),Le=(0,R.reverseDictionary)(Be);class He extends Pe{constructor(I){super(I),this.tokens_to_ids=fe(I.vocab),this.unk_token_id=this.tokens_to_ids.get(I.unk_token),this.unk_token=I.unk_token,this.vocab=new Array(this.tokens_to_ids.size);for(const[we,Ie]of this.tokens_to_ids)this.vocab[Ie]=we;const ne=Array.isArray(I.merges[0]);this.merges=ne?I.merges:I.merges.map(we=>we.split(" ",2)),this.bpe_ranks=new Map(this.merges.map((we,Ie)=>[JSON.stringify(we),Ie])),this.end_of_word_suffix=I.end_of_word_suffix,this.continuing_subword_suffix=I.continuing_subword_suffix??null,this.byte_fallback=this.config.byte_fallback??!1,this.byte_fallback&&(this.text_encoder=new TextEncoder),this.ignore_merges=this.config.ignore_merges??!1,this.cache=new Map}bpe(I){if(I.length===0)return[];const ne=this.cache.get(I);if(ne!==void 0)return ne;const we=Array.from(I);this.end_of_word_suffix&&(we[we.length-1]+=this.end_of_word_suffix);let Ie=[];if(we.length>1){const De=new E.PriorityQueue((bt,yt)=>bt.score<yt.score);let Ge={token:we[0],bias:0,prev:null,next:null},mt=Ge;for(let bt=1;bt<we.length;++bt){const yt={bias:bt/we.length,token:we[bt],prev:mt,next:null};mt.next=yt,this._add_node(De,mt),mt=yt}for(;!De.isEmpty();){const bt=De.pop();if(bt.deleted||!bt.next||bt.next.deleted)continue;if(bt.deleted=!0,bt.next.deleted=!0,bt.prev){const kt={...bt.prev};bt.prev.deleted=!0,bt.prev=kt,kt.prev?kt.prev.next=kt:Ge=kt}const yt={token:bt.token+bt.next.token,bias:bt.bias,prev:bt.prev,next:bt.next.next};yt.prev?(yt.prev.next=yt,this._add_node(De,yt.prev)):Ge=yt,yt.next&&(yt.next.prev=yt,this._add_node(De,yt))}for(let bt=Ge;bt!==null;bt=bt.next)Ie.push(bt.token)}else Ie=we;if(this.continuing_subword_suffix)for(let De=0;De<Ie.length-1;++De)Ie[De]+=this.continuing_subword_suffix;return this.cache.set(I,Ie),Ie}_add_node(I,ne){const we=this.bpe_ranks.get(JSON.stringify([ne.token,ne.next.token]));we!==void 0&&(ne.score=we+ne.bias,I.push(ne))}encode(I){const ne=[];for(const we of I){if(this.ignore_merges&&this.tokens_to_ids.has(we)){ne.push(we);continue}const Ie=this.bpe(we);for(const De of Ie)if(this.tokens_to_ids.has(De))ne.push(De);else if(this.byte_fallback){const Ge=Array.from(this.text_encoder.encode(De)).map(mt=>`<0x${mt.toString(16).toUpperCase().padStart(2,"0")}>`);Ge.every(mt=>this.tokens_to_ids.has(mt))?ne.push(...Ge):ne.push(this.unk_token)}else ne.push(this.unk_token)}return ne}}class Me extends Pe{constructor(I,ne){super(I),this.tokens_to_ids=fe(ne.target_lang?I.vocab[ne.target_lang]:I.vocab),this.bos_token=ne.bos_token,this.bos_token_id=this.tokens_to_ids.get(this.bos_token),this.eos_token=ne.eos_token,this.eos_token_id=this.tokens_to_ids.get(this.eos_token),this.pad_token=ne.pad_token,this.pad_token_id=this.tokens_to_ids.get(this.pad_token),this.unk_token=ne.unk_token,this.unk_token_id=this.tokens_to_ids.get(this.unk_token),this.vocab=new Array(this.tokens_to_ids.size);for(const[we,Ie]of this.tokens_to_ids)this.vocab[Ie]=we}encode(I){return I}}class N extends P.Callable{constructor(I){super(),this.config=I}static fromConfig(I){if(I===null)return null;switch(I.type){case"BertNormalizer":return new Je(I);case"Precompiled":return new Cr(I);case"Sequence":return new Ve(I);case"Replace":return new me(I);case"NFC":return new ue(I);case"NFKC":return new ee(I);case"NFKD":return new Te(I);case"Strip":return new je(I);case"StripAccents":return new qe(I);case"Lowercase":return new tt(I);case"Prepend":return new he(I);default:throw new Error(`Unknown Normalizer type: ${I.type}`)}}normalize(I){throw Error("normalize should be implemented in subclass.")}_call(I){return this.normalize(I)}}class me extends N{normalize(I){const ne=ae(this.config.pattern);return ne===null?I:I.replaceAll(ne,this.config.content)}}class ue extends N{normalize(I){return I=I.normalize("NFC"),I}}class ee extends N{normalize(I){return I=I.normalize("NFKC"),I}}class Te extends N{normalize(I){return I=I.normalize("NFKD"),I}}class je extends N{normalize(I){return this.config.strip_left&&this.config.strip_right?I=I.trim():(this.config.strip_left&&(I=I.trimStart()),this.config.strip_right&&(I=I.trimEnd())),I}}class qe extends N{normalize(I){return I=q(I),I}}class tt extends N{normalize(I){return I=I.toLowerCase(),I}}class he extends N{normalize(I){return I=this.config.prepend+I,I}}class Ve extends N{constructor(I){super(I),this.normalizers=I.normalizers.map(ne=>N.fromConfig(ne))}normalize(I){return this.normalizers.reduce((ne,we)=>we.normalize(ne),I)}}class Je extends N{_tokenize_chinese_chars(I){const ne=[];for(let we=0;we<I.length;++we){const Ie=I[we],De=Ie.charCodeAt(0);pe(De)?(ne.push(" "),ne.push(Ie),ne.push(" ")):ne.push(Ie)}return ne.join("")}stripAccents(I){return I.normalize("NFD").replace(new RegExp("\\p{Mn}","gu"),"")}_is_control(I){switch(I){case"	":case`
`:case"\r":return!1;default:return new RegExp("^\\p{Cc}|\\p{Cf}|\\p{Co}|\\p{Cs}$","u").test(I)}}_clean_text(I){const ne=[];for(const we of I){const Ie=we.charCodeAt(0);Ie===0||Ie===65533||this._is_control(we)||(/^\s$/.test(we)?ne.push(" "):ne.push(we))}return ne.join("")}normalize(I){return this.config.clean_text&&(I=this._clean_text(I)),this.config.handle_chinese_chars&&(I=this._tokenize_chinese_chars(I)),this.config.lowercase?(I=I.toLowerCase(),this.config.strip_accents!==!1&&(I=this.stripAccents(I))):this.config.strip_accents&&(I=this.stripAccents(I)),I}}class We extends P.Callable{static fromConfig(I){if(I===null)return null;switch(I.type){case"BertPreTokenizer":return new be(I);case"Sequence":return new rn(I);case"Whitespace":return new an(I);case"WhitespaceSplit":return new Pn(I);case"Metaspace":return new Ft(I);case"ByteLevel":return new Re(I);case"Split":return new lt(I);case"Punctuation":return new ot(I);case"Digits":return new st(I);case"Replace":return new Ns(I);default:throw new Error(`Unknown PreTokenizer type: ${I.type}`)}}pre_tokenize_text(I,ne){throw Error("pre_tokenize_text should be implemented in subclass.")}pre_tokenize(I,ne){return(Array.isArray(I)?I.map(we=>this.pre_tokenize_text(we,ne)):this.pre_tokenize_text(I,ne)).flat()}_call(I,ne){return this.pre_tokenize(I,ne)}}class be extends We{constructor(I){super(),this.pattern=new RegExp(`[^\\s${b}]+|[${b}]`,"gu")}pre_tokenize_text(I,ne){return I.trim().match(this.pattern)||[]}}class Re extends We{constructor(I){super(),this.config=I,this.add_prefix_space=this.config.add_prefix_space,this.trim_offsets=this.config.trim_offsets,this.use_regex=this.config.use_regex??!0,this.pattern=new RegExp("'s|'t|'re|'ve|'m|'ll|'d| ?\\p{L}+| ?\\p{N}+| ?[^\\s\\p{L}\\p{N}]+|\\s+(?!\\S)|\\s+","gu"),this.byte_encoder=Be,this.text_encoder=new TextEncoder}pre_tokenize_text(I,ne){return this.add_prefix_space&&!I.startsWith(" ")&&(I=" "+I),(this.use_regex?I.match(this.pattern)||[]:[I]).map(Ie=>Array.from(this.text_encoder.encode(Ie),De=>this.byte_encoder[De]).join(""))}}class lt extends We{constructor(I){super(),this.config=I,this.pattern=ae(this.config.pattern,this.config.invert)}pre_tokenize_text(I,ne){var we;return this.pattern===null?[]:this.config.invert?I.match(this.pattern)||[]:((we=this.config.behavior)==null?void 0:we.toLowerCase())==="removed"?I.split(this.pattern).filter(Ie=>Ie):$(I,this.pattern)}}class ot extends We{constructor(I){super(),this.config=I,this.pattern=new RegExp(`[^${b}]+|[${b}]+`,"gu")}pre_tokenize_text(I,ne){return I.match(this.pattern)||[]}}class st extends We{constructor(I){super(),this.config=I;const ne=`[^\\d]+|\\d${this.config.individual_digits?"":"+"}`;this.pattern=new RegExp(ne,"gu")}pre_tokenize_text(I,ne){return I.match(this.pattern)||[]}}class Xe extends P.Callable{constructor(I){super(),this.config=I}static fromConfig(I){if(I===null)return null;switch(I.type){case"TemplateProcessing":return new Et(I);case"ByteLevel":return new wt(I);case"RobertaProcessing":return new _t(I);case"BertProcessing":return new pt(I);case"Sequence":return new vt(I);default:throw new Error(`Unknown PostProcessor type: ${I.type}`)}}post_process(I,...ne){throw Error("post_process should be implemented in subclass.")}_call(I,...ne){return this.post_process(I,...ne)}}class pt extends Xe{constructor(I){super(I),this.cls=I.cls[0],this.sep=I.sep[0]}post_process(I,ne=null,{add_special_tokens:we=!0}={}){we&&(I=(0,R.mergeArrays)([this.cls],I,[this.sep]));let Ie=new Array(I.length).fill(0);if(ne!==null){const De=we&&this instanceof _t?[this.sep]:[],Ge=we?[this.sep]:[];I=(0,R.mergeArrays)(I,De,ne,Ge),Ie=(0,R.mergeArrays)(Ie,new Array(ne.length+De.length+Ge.length).fill(1))}return{tokens:I,token_type_ids:Ie}}}class _t extends pt{}class Et extends Xe{constructor(I){super(I),this.single=I.single,this.pair=I.pair}post_process(I,ne=null,{add_special_tokens:we=!0}={}){const Ie=ne===null?this.single:this.pair;let De=[],Ge=[];for(const mt of Ie)"SpecialToken"in mt?we&&(De.push(mt.SpecialToken.id),Ge.push(mt.SpecialToken.type_id)):"Sequence"in mt&&(mt.Sequence.id==="A"?(De=(0,R.mergeArrays)(De,I),Ge=(0,R.mergeArrays)(Ge,new Array(I.length).fill(mt.Sequence.type_id))):mt.Sequence.id==="B"&&(De=(0,R.mergeArrays)(De,ne),Ge=(0,R.mergeArrays)(Ge,new Array(ne.length).fill(mt.Sequence.type_id))));return{tokens:De,token_type_ids:Ge}}}class wt extends Xe{post_process(I,ne=null){return ne&&(I=(0,R.mergeArrays)(I,ne)),{tokens:I}}}class vt extends Xe{constructor(I){super(I),this.processors=I.processors.map(ne=>Xe.fromConfig(ne))}post_process(I,ne=null,we={}){let Ie;for(const De of this.processors)if(De instanceof wt)I=De.post_process(I).tokens,ne&&(ne=De.post_process(ne).tokens);else{const Ge=De.post_process(I,ne,we);I=Ge.tokens,Ie=Ge.token_type_ids}return{tokens:I,token_type_ids:Ie}}}class U extends P.Callable{constructor(I){super(),this.config=I,this.added_tokens=[],this.end_of_word_suffix=null,this.trim_offsets=I.trim_offsets}static fromConfig(I){if(I===null)return null;switch(I.type){case"WordPiece":return new at(I);case"Metaspace":return new gr(I);case"ByteLevel":return new ct(I);case"Replace":return new _e(I);case"ByteFallback":return new Z(I);case"Fuse":return new xe(I);case"Strip":return new Ne(I);case"Sequence":return new zt(I);case"CTC":return new gt(I);case"BPEDecoder":return new $t(I);default:throw new Error(`Unknown Decoder type: ${I.type}`)}}_call(I){return this.decode(I)}decode(I){return this.decode_chain(I).join("")}decode_chain(I){throw Error("`decode_chain` should be implemented in subclass.")}}class _e extends U{decode_chain(I){const ne=ae(this.config.pattern);return ne===null?I:I.map(we=>we.replaceAll(ne,this.config.content))}}class Z extends U{constructor(I){super(I),this.text_decoder=new TextDecoder}decode_chain(I){const ne=[];let we=[];for(const Ie of I){let De=null;if(Ie.length===6&&Ie.startsWith("<0x")&&Ie.endsWith(">")){const Ge=parseInt(Ie.slice(3,5),16);isNaN(Ge)||(De=Ge)}if(De!==null)we.push(De);else{if(we.length>0){const Ge=this.text_decoder.decode(Uint8Array.from(we));ne.push(Ge),we=[]}ne.push(Ie)}}if(we.length>0){const Ie=this.text_decoder.decode(Uint8Array.from(we));ne.push(Ie),we=[]}return ne}}class xe extends U{decode_chain(I){return[I.join("")]}}class Ne extends U{constructor(I){super(I),this.content=this.config.content,this.start=this.config.start,this.stop=this.config.stop}decode_chain(I){return I.map(ne=>{let we=0;for(let De=0;De<this.start&&ne[De]===this.content;++De){we=De+1;continue}let Ie=ne.length;for(let De=0;De<this.stop;++De){const Ge=ne.length-De-1;if(ne[Ge]===this.content){Ie=Ge;continue}else break}return ne.slice(we,Ie)})}}class at extends U{constructor(I){super(I),this.cleanup=I.cleanup}decode_chain(I){return I.map((ne,we)=>(we!==0&&(ne.startsWith(this.config.prefix)?ne=ne.replace(this.config.prefix,""):ne=" "+ne),this.cleanup&&(ne=le(ne)),ne))}}class ct extends U{constructor(I){super(I),this.byte_decoder=Le,this.text_decoder=new TextDecoder("utf-8",{fatal:!1,ignoreBOM:!0}),this.end_of_word_suffix=null}convert_tokens_to_string(I){const ne=I.join(""),we=new Uint8Array([...ne].map(De=>this.byte_decoder[De]));return this.text_decoder.decode(we)}decode_chain(I){const ne=[];let we=[];for(const Ie of I)this.added_tokens.find(De=>De.content===Ie)!==void 0?(we.length>0&&(ne.push(this.convert_tokens_to_string(we)),we=[]),ne.push(Ie)):we.push(Ie);return we.length>0&&ne.push(this.convert_tokens_to_string(we)),ne}}class gt extends U{constructor(I){super(I),this.pad_token=this.config.pad_token,this.word_delimiter_token=this.config.word_delimiter_token,this.cleanup=this.config.cleanup}convert_tokens_to_string(I){if(I.length===0)return"";const ne=[I[0]];for(let De=1;De<I.length;++De)I[De]!==ne.at(-1)&&ne.push(I[De]);let Ie=ne.filter(De=>De!==this.pad_token).join("");return this.cleanup&&(Ie=le(Ie).replaceAll(this.word_delimiter_token," ").trim()),Ie}decode_chain(I){return[this.convert_tokens_to_string(I)]}}class zt extends U{constructor(I){super(I),this.decoders=I.decoders.map(ne=>U.fromConfig(ne))}decode_chain(I){return this.decoders.reduce((ne,we)=>we.decode_chain(ne),I)}}class $t extends U{constructor(I){super(I),this.suffix=this.config.suffix}decode_chain(I){return I.map((ne,we)=>ne.replaceAll(this.suffix,we===I.length-1?"":" "))}}class St extends U{decode_chain(I){let ne="";for(let we=1;we<I.length;we+=2)ne+=I[we];return[ne]}}class Ft extends We{constructor(I){super(),this.addPrefixSpace=I.add_prefix_space,this.replacement=I.replacement,this.strRep=I.str_rep||this.replacement,this.prepend_scheme=I.prepend_scheme??"always"}pre_tokenize_text(I,{section_index:ne=void 0}={}){let we=I.replaceAll(" ",this.strRep);return this.addPrefixSpace&&!we.startsWith(this.replacement)&&(this.prepend_scheme==="always"||this.prepend_scheme==="first"&&ne===0)&&(we=this.strRep+we),[we]}}class gr extends U{constructor(I){super(I),this.addPrefixSpace=I.add_prefix_space,this.replacement=I.replacement}decode_chain(I){const ne=[];for(let we=0;we<I.length;++we){let Ie=I[we].replaceAll(this.replacement," ");this.addPrefixSpace&&we==0&&Ie.startsWith(" ")&&(Ie=Ie.substring(1)),ne.push(Ie)}return ne}}class Cr extends N{constructor(I){super(I),this.charsmap=I.precompiled_charsmap}normalize(I){return I=I.replace(/[\u0001-\u0008\u000B\u000E-\u001F\u007F\u008F\u009F]/gm,""),I=I.replace(/[\u0009\u000A\u000C\u000D\u00A0\u1680\u2000-\u200F\u2028\u2029\u202F\u205F\u2581\u3000\uFEFF\uFFFD]/gm," "),I.includes("")?I=I.split("").map(we=>we.normalize("NFKC")).join(""):I=I.normalize("NFKC"),I}}class rn extends We{constructor(I){super(),this.tokenizers=I.pretokenizers.map(ne=>We.fromConfig(ne))}pre_tokenize_text(I,ne){return this.tokenizers.reduce((we,Ie)=>Ie.pre_tokenize(we,ne),[I])}}class an extends We{constructor(I){super()}pre_tokenize_text(I,ne){return I.match(/\w+|[^\w\s]+/g)||[]}}class Pn extends We{constructor(I){super()}pre_tokenize_text(I,ne){return W(I)}}class Ns extends We{constructor(I){super(),this.config=I,this.pattern=ae(this.config.pattern),this.content=this.config.content}pre_tokenize_text(I,ne){return this.pattern===null?[I]:[I.replaceAll(this.pattern,this.config.content)]}}const Us=["bos_token","eos_token","unk_token","sep_token","pad_token","cls_token","mask_token"];function Ps(Oe,I,ne,we){for(const Ie of Object.keys(Oe)){const De=I-Oe[Ie].length,Ge=ne(Ie),mt=new Array(De).fill(Ge);Oe[Ie]=we==="right"?(0,R.mergeArrays)(Oe[Ie],mt):(0,R.mergeArrays)(mt,Oe[Ie])}}function Bn(Oe,I){for(const ne of Object.keys(Oe))Oe[ne].length=I}class Gt extends P.Callable{constructor(ne,we){super();Fe(this,"return_token_type_ids",!1);Fe(this,"padding_side","right");this._tokenizer_config=we,this.normalizer=N.fromConfig(ne.normalizer),this.pre_tokenizer=We.fromConfig(ne.pre_tokenizer),this.model=Pe.fromConfig(ne.model,we),this.post_processor=Xe.fromConfig(ne.post_processor),this.decoder=U.fromConfig(ne.decoder),this.special_tokens=[],this.all_special_ids=[],this.added_tokens=[];for(const Ie of ne.added_tokens){const De=new ce(Ie);this.added_tokens.push(De),this.model.tokens_to_ids.set(De.content,De.id),this.model.vocab[De.id]=De.content,De.special&&(this.special_tokens.push(De.content),this.all_special_ids.push(De.id))}if(this.additional_special_tokens=we.additional_special_tokens??[],this.special_tokens.push(...this.additional_special_tokens),this.special_tokens=[...new Set(this.special_tokens)],this.decoder&&(this.decoder.added_tokens=this.added_tokens,this.decoder.end_of_word_suffix=this.model.end_of_word_suffix),this.added_tokens_regex=this.added_tokens.length>0?new RegExp(this.added_tokens.slice().sort((Ie,De)=>De.content.length-Ie.content.length).map(Ie=>`${Ie.lstrip?"\\s*":""}(${(0,R.escapeRegExp)(Ie.content)})${Ie.rstrip?"\\s*":""}`).join("|")):null,this.mask_token=this.getToken("mask_token"),this.mask_token_id=this.model.tokens_to_ids.get(this.mask_token),this.pad_token=this.getToken("pad_token","eos_token"),this.pad_token_id=this.model.tokens_to_ids.get(this.pad_token),this.sep_token=this.getToken("sep_token"),this.sep_token_id=this.model.tokens_to_ids.get(this.sep_token),this.unk_token=this.getToken("unk_token"),this.unk_token_id=this.model.tokens_to_ids.get(this.unk_token),this.model_max_length=we.model_max_length,this.remove_space=we.remove_space,this.clean_up_tokenization_spaces=we.clean_up_tokenization_spaces??!0,this.do_lowercase_and_remove_accent=we.do_lowercase_and_remove_accent??!1,we.padding_side&&(this.padding_side=we.padding_side),this.legacy=!1,this.chat_template=we.chat_template??null,Array.isArray(this.chat_template)){const Ie=Object.create(null);for(const{name:De,template:Ge}of this.chat_template){if(typeof De!="string"||typeof Ge!="string")throw new Error('Chat template must be a list of objects with "name" and "template" properties');Ie[De]=Ge}this.chat_template=Ie}this._compiled_template_cache=new Map}getToken(...ne){for(const we of ne){const Ie=this._tokenizer_config[we];if(Ie)if(typeof Ie=="object"){if(Ie.__type==="AddedToken")return Ie.content;throw Error(`Unknown token: ${Ie}`)}else return Ie}return null}static async from_pretrained(ne,{progress_callback:we=null,config:Ie=null,cache_dir:De=null,local_files_only:Ge=!1,revision:mt="main",legacy:bt=null}={}){const yt=await A(ne,{progress_callback:we,config:Ie,cache_dir:De,local_files_only:Ge,revision:mt,legacy:bt});return new this(...yt)}_call(ne,{text_pair:we=null,add_special_tokens:Ie=!0,padding:De=!1,truncation:Ge=null,max_length:mt=null,return_tensor:bt=!0,return_token_type_ids:yt=null}={}){const kt=Array.isArray(ne);let Zt;if(kt){if(ne.length===0)throw Error("text array must be non-empty");if(we!==null){if(Array.isArray(we)){if(ne.length!==we.length)throw Error("text and text_pair must have the same length")}else throw Error("text_pair must also be an array");Zt=ne.map((ar,Fr)=>this._encode_plus(ar,{text_pair:we[Fr],add_special_tokens:Ie,return_token_type_ids:yt}))}else Zt=ne.map(ar=>this._encode_plus(ar,{add_special_tokens:Ie,return_token_type_ids:yt}))}else{if(ne==null)throw Error("text may not be null or undefined");if(Array.isArray(we))throw Error("When specifying `text_pair`, since `text` is a string, `text_pair` must also be a string (i.e., not an array).");Zt=[this._encode_plus(ne,{text_pair:we,add_special_tokens:Ie,return_token_type_ids:yt})]}if(mt===null?De==="max_length"?mt=this.model_max_length:mt=(0,se.max)(Zt.map(ar=>ar.input_ids.length))[0]:Ge||console.warn("Truncation was not explicitly activated but `max_length` is provided a specific value, please use `truncation=true` to explicitly truncate examples to max length."),mt=Math.min(mt,this.model_max_length??1/0),De||Ge)for(let ar=0;ar<Zt.length;++ar)Zt[ar].input_ids.length!==mt&&(Zt[ar].input_ids.length>mt?Ge&&Bn(Zt[ar],mt):De&&Ps(Zt[ar],mt,Fr=>Fr==="input_ids"?this.pad_token_id:0,this.padding_side));const xr={};if(bt){if(!(De&&Ge)&&Zt.some(Fr=>{var Ht;for(const hr of Object.keys(Fr))if(Fr[hr].length!==((Ht=Zt[0][hr])==null?void 0:Ht.length))return!0;return!1}))throw Error("Unable to create tensor, you should probably activate truncation and/or padding with 'padding=true' and 'truncation=true' to have batched tensors with the same length.");const ar=[Zt.length,Zt[0].input_ids.length];for(const Fr of Object.keys(Zt[0]))xr[Fr]=new oe.Tensor("int64",BigInt64Array.from(Zt.flatMap(Ht=>Ht[Fr]).map(BigInt)),ar)}else{for(const ar of Object.keys(Zt[0]))xr[ar]=Zt.map(Fr=>Fr[ar]);if(!kt)for(const ar of Object.keys(xr))xr[ar]=xr[ar][0]}return xr}_encode_text(ne){return ne===null?null:(this.added_tokens_regex?ne.split(this.added_tokens_regex).filter(De=>De):[ne]).map((De,Ge)=>{if(this.added_tokens.find(bt=>bt.content===De)!==void 0)return De;{if(this.remove_space===!0&&(De=De.trim().split(/\s+/).join(" ")),this.do_lowercase_and_remove_accent&&(De=ie(De)),this.normalizer!==null&&(De=this.normalizer(De)),De.length===0)return[];const bt=this.pre_tokenizer!==null?this.pre_tokenizer(De,{section_index:Ge}):[De];return this.model(bt)}}).flat()}_encode_plus(ne,{text_pair:we=null,add_special_tokens:Ie=!0,return_token_type_ids:De=null}={}){const{tokens:Ge,token_type_ids:mt}=this._tokenize_helper(ne,{pair:we,add_special_tokens:Ie}),bt=this.model.convert_tokens_to_ids(Ge),yt={input_ids:bt,attention_mask:new Array(bt.length).fill(1)};return(De??this.return_token_type_ids)&&mt&&(yt.token_type_ids=mt),yt}_tokenize_helper(ne,{pair:we=null,add_special_tokens:Ie=!1}={}){const De=this._encode_text(ne),Ge=this._encode_text(we);return this.post_processor?this.post_processor(De,Ge,{add_special_tokens:Ie}):{tokens:(0,R.mergeArrays)(De??[],Ge??[])}}tokenize(ne,{pair:we=null,add_special_tokens:Ie=!1}={}){return this._tokenize_helper(ne,{pair:we,add_special_tokens:Ie}).tokens}encode(ne,{text_pair:we=null,add_special_tokens:Ie=!0,return_token_type_ids:De=null}={}){return this._encode_plus(ne,{text_pair:we,add_special_tokens:Ie,return_token_type_ids:De}).input_ids}batch_decode(ne,we={}){return ne instanceof oe.Tensor&&(ne=ne.tolist()),ne.map(Ie=>this.decode(Ie,we))}decode(ne,we={}){if(ne instanceof oe.Tensor&&(ne=ge(ne)),!Array.isArray(ne)||ne.length===0||!(0,R.isIntegralNumber)(ne[0]))throw Error("token_ids must be a non-empty array of integers.");return this.decode_single(ne,we)}decode_single(ne,{skip_special_tokens:we=!1,clean_up_tokenization_spaces:Ie=null}){let De=this.model.convert_ids_to_tokens(ne);we&&(De=De.filter(mt=>!this.special_tokens.includes(mt)));let Ge=this.decoder?this.decoder(De):De.join(" ");return this.decoder&&this.decoder.end_of_word_suffix&&(Ge=Ge.replaceAll(this.decoder.end_of_word_suffix," "),we&&(Ge=Ge.trim())),(Ie??this.clean_up_tokenization_spaces)&&(Ge=le(Ge)),Ge}get_chat_template({chat_template:ne=null,tools:we=null}={}){if(this.chat_template&&typeof this.chat_template=="object"){const Ie=this.chat_template;if(ne!==null&&Object.hasOwn(Ie,ne))ne=Ie[ne];else if(ne===null)if(we!==null&&"tool_use"in Ie)ne=Ie.tool_use;else if("default"in Ie)ne=Ie.default;else throw Error(`This model has multiple chat templates with no default specified! Please either pass a chat template or the name of the template you wish to use to the 'chat_template' argument. Available template names are ${Object.keys(Ie).sort()}.`)}else if(ne===null)if(this.chat_template)ne=this.chat_template;else throw Error("Cannot use apply_chat_template() because tokenizer.chat_template is not set and no template argument was passed! For information about writing templates and setting the tokenizer.chat_template attribute, please see the documentation at https://huggingface.co/docs/transformers/main/en/chat_templating");return ne}apply_chat_template(ne,{tools:we=null,documents:Ie=null,chat_template:De=null,add_generation_prompt:Ge=!1,tokenize:mt=!0,padding:bt=!1,truncation:yt=!1,max_length:kt=null,return_tensor:Zt=!0,return_dict:xr=!1,tokenizer_kwargs:ar={},...Fr}={}){if(De=this.get_chat_template({chat_template:De,tools:we}),typeof De!="string")throw Error(`chat_template must be a string, but got ${typeof De}`);let Ht=this._compiled_template_cache.get(De);Ht===void 0&&(Ht=new C.Template(De),this._compiled_template_cache.set(De,Ht));const hr=Object.create(null);for(const Nr of Us){const Qe=this.getToken(Nr);Qe&&(hr[Nr]=Qe)}const fn=Ht.render({messages:ne,add_generation_prompt:Ge,tools:we,documents:Ie,...hr,...Fr});if(mt){const Nr=this._call(fn,{add_special_tokens:!1,padding:bt,truncation:yt,max_length:kt,return_tensor:Zt,...ar});return xr?Nr:Nr.input_ids}return fn}}class fs extends Gt{constructor(){super(...arguments);Fe(this,"return_token_type_ids",!0)}}class Vs extends Gt{constructor(){super(...arguments);Fe(this,"return_token_type_ids",!0)}}class so extends Gt{constructor(){super(...arguments);Fe(this,"return_token_type_ids",!0)}}class Io extends Gt{constructor(){super(...arguments);Fe(this,"return_token_type_ids",!0)}}class ts extends Gt{constructor(){super(...arguments);Fe(this,"return_token_type_ids",!0)}}class oo extends Gt{constructor(){super(...arguments);Fe(this,"return_token_type_ids",!0)}}class io extends Gt{constructor(){super(...arguments);Fe(this,"return_token_type_ids",!0)}}class hs extends Gt{constructor(){super(...arguments);Fe(this,"return_token_type_ids",!0)}}class Cs extends Gt{constructor(){super(...arguments);Fe(this,"return_token_type_ids",!0)}}class Cn extends Gt{}class dt extends Gt{}class Pt extends Gt{constructor(ne,we){super(ne,we);Fe(this,"return_token_type_ids",!0);console.warn('WARNING: `XLMTokenizer` is not yet supported by Hugging Face\'s "fast" tokenizers library. Therefore, you may experience slightly inaccurate results.')}}class jt extends Gt{constructor(){super(...arguments);Fe(this,"return_token_type_ids",!0)}}class ln extends Gt{}class Ws extends Gt{}class ao extends Gt{}class Dr extends Gt{constructor(I,ne){super(I,ne),this.languageRegex=/^[a-z]{2}_[A-Z]{2}$/,this.language_codes=this.special_tokens.filter(we=>this.languageRegex.test(we)),this.lang_to_token=we=>we}_build_translation_inputs(I,ne,we){return ms(this,I,ne,we)}}class rs extends Dr{}class zr extends Gt{}class Ss extends Gt{}const Sr="";class lo extends Gt{constructor(ne,we){super(ne,we);Fe(this,"padding_side","left");this.legacy=we.legacy??!0,this.legacy||(this.normalizer=null,this.pre_tokenizer=new Ft({replacement:Sr,add_prefix_space:!0,prepend_scheme:"first"}))}_encode_text(ne){if(ne===null)return null;if(this.legacy||ne.length===0)return super._encode_text(ne);let we=super._encode_text(Sr+ne.replaceAll(Sr," "));return we.length>1&&we[0]===Sr&&this.special_tokens.includes(we[1])&&(we=we.slice(1)),we}}class Ei extends Gt{}class ha extends Gt{}class Pi extends Gt{}class Ci extends Gt{}class uo extends Gt{}class ma extends Gt{}class Yr extends Gt{}class il extends Gt{}class Gs extends Gt{}function ms(Oe,I,ne,we){if(!("language_codes"in Oe)||!Array.isArray(Oe.language_codes))throw new Error("Tokenizer must have `language_codes` attribute set and it should be an array of language ids.");if(!("languageRegex"in Oe)||!(Oe.languageRegex instanceof RegExp))throw new Error("Tokenizer must have `languageRegex` attribute set and it should be a regular expression.");if(!("lang_to_token"in Oe)||typeof Oe.lang_to_token!="function")throw new Error("Tokenizer must have `lang_to_token` attribute set and it should be a function.");const Ie=we.src_lang,De=we.tgt_lang;if(!Oe.language_codes.includes(De))throw new Error(`Target language code "${De}" is not valid. Must be one of: {${Oe.language_codes.join(", ")}}`);if(Ie!==void 0){if(!Oe.language_codes.includes(Ie))throw new Error(`Source language code "${Ie}" is not valid. Must be one of: {${Oe.language_codes.join(", ")}}`);for(const Ge of Oe.post_processor.config.single)if("SpecialToken"in Ge&&Oe.languageRegex.test(Ge.SpecialToken.id)){Ge.SpecialToken.id=Oe.lang_to_token(Ie);break}}return we.forced_bos_token_id=Oe.model.convert_tokens_to_ids([Oe.lang_to_token(De)])[0],Oe._call(I,ne)}class Rn extends Gt{constructor(I,ne){super(I,ne),this.languageRegex=/^[a-z]{3}_[A-Z][a-z]{3}$/,this.language_codes=this.special_tokens.filter(we=>this.languageRegex.test(we)),this.lang_to_token=we=>we}_build_translation_inputs(I,ne,we){return ms(this,I,ne,we)}}class Si extends Gt{constructor(I,ne){super(I,ne),this.languageRegex=/^__[a-z]{2,3}__$/,this.language_codes=this.special_tokens.filter(we=>this.languageRegex.test(we)).map(we=>we.slice(2,-2)),this.lang_to_token=we=>`__${we}__`}_build_translation_inputs(I,ne,we){return ms(this,I,ne,we)}}class Ao extends Gt{get timestamp_begin(){return this.model.convert_tokens_to_ids(["<|notimestamps|>"])[0]+1}_decode_asr(I,{return_timestamps:ne=!1,return_language:we=!1,time_precision:Ie=null,force_full_sequences:De=!0}={}){if(Ie===null)throw Error("Must specify time_precision");let Ge=null;const mt=ne==="word";function bt(){return{language:Ge,timestamp:[null,null],text:""}}const yt=[];let kt=bt(),Zt=0;const xr=this.timestamp_begin;let ar=[],Fr=[],Ht=!1,hr=null;const fn=new Set(this.all_special_ids);for(const mr of I){const Mn=mr.tokens,Qn=mt?mr.token_timestamps:null;let Nn=null,qt=xr;if("stride"in mr){const[_r,$r,Tt]=mr.stride;if(Zt-=$r,hr=_r-Tt,$r&&(qt=$r/Ie+xr),Tt)for(let Jt=Mn.length-1;Jt>=0;--Jt){const Jr=Number(Mn[Jt]);if(Jr>=xr){if(Nn!==null&&(Jr-xr)*Ie<hr)break;Nn=Jr}}}let gn=[],Sn=[];for(let _r=0;_r<Mn.length;++_r){const $r=Number(Mn[_r]);if(fn.has($r)){const Tt=this.decode([$r]),Jt=k.WHISPER_LANGUAGE_MAPPING.get(Tt.slice(2,-2));if(Jt!==void 0){if(Ge!==null&&Jt!==Ge&&!ne){ar.push(gn);const Jr=this.findLongestCommonSequence(ar)[0],ns=this.decode(Jr);kt.text=ns,yt.push(kt),ar=[],gn=[],kt=bt()}Ge=kt.language=Jt}}else if($r>=xr){const Tt=($r-xr)*Ie+Zt,Jt=(0,se.round)(Tt,2);if(Nn!==null&&$r>=Nn)Ht=!0;else if(Ht||ar.length>0&&$r<qt)Ht=!1;else if(kt.timestamp[0]===null)kt.timestamp[0]=Jt;else if(Jt!==kt.timestamp[0]){kt.timestamp[1]=Jt,ar.push(gn),mt&&Fr.push(Sn);const[Jr,ns]=this.findLongestCommonSequence(ar,Fr),Hs=this.decode(Jr);kt.text=Hs,mt&&(kt.words=this.collateWordTimestamps(Jr,ns,Ge)),yt.push(kt),ar=[],gn=[],Fr=[],Sn=[],kt=bt()}}else if(gn.push($r),mt){let Tt=(0,se.round)(Qn[_r]+Zt,2),Jt;if(_r+1<Qn.length){Jt=(0,se.round)(Qn[_r+1]+Zt,2);const Jr=this.decode([$r]);z.test(Jr)&&(Jt=(0,se.round)(Math.min(Tt+Ie,Jt),2))}else Jt=null;Sn.push([Tt,Jt])}}if("stride"in mr){const[_r,$r,Tt]=mr.stride;Zt+=_r-Tt}gn.length>0?(ar.push(gn),mt&&Fr.push(Sn)):ar.every(_r=>_r.length===0)&&(kt=bt(),ar=[],gn=[],Fr=[],Sn=[])}if(ar.length>0){if(De&&ne)throw new Error("Whisper did not predict an ending timestamp, which can happen if audio is cut off in the middle of a word. Also make sure WhisperTimeStampLogitsProcessor was used during generation.");const[mr,Mn]=this.findLongestCommonSequence(ar,Fr),Qn=this.decode(mr);kt.text=Qn,mt&&(kt.words=this.collateWordTimestamps(mr,Mn,Ge)),yt.push(kt)}let Nr=Object.create(null);const Qe=yt.map(mr=>mr.text).join("");if(ne||we){for(let mr=0;mr<yt.length;++mr){const Mn=yt[mr];ne||delete Mn.timestamp,we||delete Mn.language}if(mt){const mr=[];for(const Mn of yt)for(const Qn of Mn.words)mr.push(Qn);Nr={chunks:mr}}else Nr={chunks:yt}}return[Qe,Nr]}findLongestCommonSequence(I,ne=null){let we=I[0],Ie=we.length,De=[];const Ge=Array.isArray(ne)&&ne.length>0;let mt=Ge?[]:null,bt=Ge?ne[0]:null;for(let yt=1;yt<I.length;++yt){const kt=I[yt];let Zt=0,xr=[Ie,Ie,0,0];const ar=kt.length;for(let mr=1;mr<Ie+ar;++mr){const Mn=Math.max(0,Ie-mr),Qn=Math.min(Ie,Ie+ar-mr),Nn=we.slice(Mn,Qn),qt=Math.max(0,mr-Ie),gn=Math.min(ar,mr),Sn=kt.slice(qt,gn);if(Nn.length!==Sn.length)throw new Error("There is a bug within whisper `decode_asr` function, please report it. Dropping to prevent bad inference.");let _r;Ge?_r=Nn.filter((Jt,Jr)=>Jt===Sn[Jr]&&bt[Mn+Jr]<=ne[yt][qt+Jr]).length:_r=Nn.filter((Jt,Jr)=>Jt===Sn[Jr]).length;const $r=mr/1e4,Tt=_r/mr+$r;_r>1&&Tt>Zt&&(Zt=Tt,xr=[Mn,Qn,qt,gn])}const[Fr,Ht,hr,fn]=xr,Nr=Math.floor((Ht+Fr)/2),Qe=Math.floor((fn+hr)/2);De.push(...we.slice(0,Nr)),we=kt.slice(Qe),Ie=we.length,Ge&&(mt.push(...bt.slice(0,Nr)),bt=ne[yt].slice(Qe))}return De.push(...we),Ge?(mt.push(...bt),[De,mt]):[De,[]]}collateWordTimestamps(I,ne,we){const[Ie,De,Ge]=this.combineTokensIntoWords(I,we),mt=[];for(let bt=0;bt<Ie.length;++bt){const yt=Ge[bt];mt.push({text:Ie[bt],timestamp:[ne[yt.at(0)][0],ne[yt.at(-1)][1]]})}return mt}combineTokensIntoWords(I,ne,we=`"'([{-`,Ie=`"'.,!?:)]}`){ne=ne??"english";let De,Ge,mt;return["chinese","japanese","thai","lao","myanmar"].includes(ne)?[De,Ge,mt]=this.splitTokensOnUnicode(I):[De,Ge,mt]=this.splitTokensOnSpaces(I),this.mergePunctuations(De,Ge,mt,we,Ie)}decode(I,ne){let we;return ne!=null&&ne.decode_with_timestamps?(I instanceof oe.Tensor&&(I=ge(I)),we=this.decodeWithTimestamps(I,ne)):we=super.decode(I,ne),we}decodeWithTimestamps(I,ne){const we=(ne==null?void 0:ne.time_precision)??.02,Ie=Array.from(this.all_special_ids).at(-1)+1;let De=[[]];for(let Ge of I)if(Ge=Number(Ge),Ge>=Ie){const mt=((Ge-Ie)*we).toFixed(2);De.push(`<|${mt}|>`),De.push([])}else De[De.length-1].push(Ge);return De=De.map(Ge=>typeof Ge=="string"?Ge:super.decode(Ge,ne)),De.join("")}splitTokensOnUnicode(I){const ne=this.decode(I,{decode_with_timestamps:!0}),we="",Ie=[],De=[],Ge=[];let mt=[],bt=[],yt=0;for(let kt=0;kt<I.length;++kt){const Zt=I[kt];mt.push(Zt),bt.push(kt);const xr=this.decode(mt,{decode_with_timestamps:!0});(!xr.includes(we)||ne[yt+xr.indexOf(we)]===we)&&(Ie.push(xr),De.push(mt),Ge.push(bt),mt=[],bt=[],yt+=xr.length)}return[Ie,De,Ge]}splitTokensOnSpaces(I){const[ne,we,Ie]=this.splitTokensOnUnicode(I),De=[],Ge=[],mt=[],bt=new RegExp(`^[${b}]$`,"gu");for(let yt=0;yt<ne.length;++yt){const kt=ne[yt],Zt=we[yt],xr=Ie[yt],ar=Zt[0]>=this.model.tokens_to_ids.get("<|endoftext|>"),Fr=kt.startsWith(" "),Ht=kt.trim(),hr=bt.test(Ht);if(ar||Fr||hr||De.length===0)De.push(kt),Ge.push(Zt),mt.push(xr);else{const fn=De.length-1;De[fn]+=kt,Ge[fn].push(...Zt),mt[fn].push(...xr)}}return[De,Ge,mt]}mergePunctuations(I,ne,we,Ie,De){const Ge=structuredClone(I),mt=structuredClone(ne),bt=structuredClone(we);let yt=Ge.length-2,kt=Ge.length-1;for(;yt>=0;)Ge[yt].startsWith(" ")&&Ie.includes(Ge[yt].trim())?(Ge[kt]=Ge[yt]+Ge[kt],mt[kt]=(0,R.mergeArrays)(mt[yt],mt[kt]),bt[kt]=(0,R.mergeArrays)(bt[yt],bt[kt]),Ge[yt]="",mt[yt]=[],bt[yt]=[]):kt=yt,--yt;for(yt=0,kt=1;kt<Ge.length;)!Ge[yt].endsWith(" ")&&De.includes(Ge[kt])?(Ge[yt]+=Ge[kt],mt[yt]=(0,R.mergeArrays)(mt[yt],mt[kt]),bt[yt]=(0,R.mergeArrays)(bt[yt],bt[kt]),Ge[kt]="",mt[kt]=[],bt[kt]=[]):yt=kt,++kt;return[Ge.filter(Zt=>Zt),mt.filter(Zt=>Zt.length>0),bt.filter(Zt=>Zt.length>0)]}}class co extends Gt{}class jn extends Gt{}class po extends Gt{}class Rt extends Gt{constructor(I,ne){super(I,ne),this.languageRegex=/^(>>\w+<<)\s*/g,this.supported_language_codes=this.model.vocab.filter(we=>this.languageRegex.test(we)),console.warn('WARNING: `MarianTokenizer` is not yet supported by Hugging Face\'s "fast" tokenizers library. Therefore, you may experience slightly inaccurate results.')}_encode_text(I){if(I===null)return null;const[ne,...we]=I.trim().split(this.languageRegex);if(we.length===0)return super._encode_text(ne);if(we.length===2){const[Ie,De]=we;return this.supported_language_codes.includes(Ie)||console.warn(`Unsupported language code "${Ie}" detected, which may lead to unexpected behavior. Should be one of: ${JSON.stringify(this.supported_language_codes)}`),(0,R.mergeArrays)([Ie],super._encode_text(De))}}}class ki extends Gt{}class _a extends Gt{}class ga extends Gt{}class fo extends Gt{}class Fo extends Gt{}class ho extends Gt{constructor(I,ne){super(I,ne),this.decoder=new St({})}}class Ks extends Gt{}class ya extends Gt{}class kr{static async from_pretrained(I,{progress_callback:ne=null,config:we=null,cache_dir:Ie=null,local_files_only:De=!1,revision:Ge="main",legacy:mt=null}={}){var xr;const[bt,yt]=await A(I,{progress_callback:ne,config:we,cache_dir:Ie,local_files_only:De,revision:Ge,legacy:mt}),kt=((xr=yt.tokenizer_class)==null?void 0:xr.replace(/Fast$/,""))??"PreTrainedTokenizer";let Zt=this.TOKENIZER_CLASS_MAPPING[kt];return Zt||(console.warn(`Unknown tokenizer class "${kt}", attempting to construct from base class.`),Zt=Gt),new Zt(bt,yt)}}Fe(kr,"TOKENIZER_CLASS_MAPPING",{T5Tokenizer:ln,DistilBertTokenizer:Cn,CamembertTokenizer:dt,DebertaTokenizer:ts,DebertaV2Tokenizer:oo,BertTokenizer:fs,HerbertTokenizer:io,ConvBertTokenizer:hs,RoFormerTokenizer:Cs,XLMTokenizer:Pt,ElectraTokenizer:jt,MobileBertTokenizer:so,SqueezeBertTokenizer:Io,AlbertTokenizer:Vs,GPT2Tokenizer:Ws,BartTokenizer:ao,MBartTokenizer:Dr,MBart50Tokenizer:rs,RobertaTokenizer:zr,WhisperTokenizer:Ao,CodeGenTokenizer:co,CLIPTokenizer:jn,SiglipTokenizer:po,MarianTokenizer:Rt,BloomTokenizer:Ss,NllbTokenizer:Rn,M2M100Tokenizer:Si,LlamaTokenizer:lo,CodeLlamaTokenizer:Ei,XLMRobertaTokenizer:ha,MPNetTokenizer:Pi,FalconTokenizer:Ci,GPTNeoXTokenizer:uo,EsmTokenizer:ma,Wav2Vec2CTCTokenizer:ki,BlenderbotTokenizer:_a,BlenderbotSmallTokenizer:ga,SpeechT5Tokenizer:fo,NougatTokenizer:Fo,VitsTokenizer:ho,Qwen2Tokenizer:Yr,GemmaTokenizer:il,Grok1Tokenizer:Gs,CohereTokenizer:Ks,MgpstrTokenizer:ya,PreTrainedTokenizer:Gt})},"./src/utils/audio.js":(ke,V,f)=>{f.r(V),f.d(V,{hamming:()=>k,hanning:()=>C,mel_filter_bank:()=>q,read_audio:()=>oe,spectrogram:()=>b,window_function:()=>z});var P=f("./src/utils/hub.js"),R=f("./src/utils/maths.js"),Q=f("./src/utils/core.js"),se=f("./src/utils/tensor.js");async function oe(L,de){if(typeof AudioContext>"u")throw Error("Unable to load audio from path/URL since `AudioContext` is not available in your environment. Instead, audio data should be passed directly to the pipeline/processor. For more information and some example code, see https://huggingface.co/docs/transformers.js/guides/node-audio-processing.");const ce=await(await(0,P.getFile)(L)).arrayBuffer(),Pe=new AudioContext({sampleRate:de});typeof de>"u"&&console.warn(`No sampling rate provided, using default of ${Pe.sampleRate}Hz.`);const Ee=await Pe.decodeAudioData(ce);let Se;if(Ee.numberOfChannels===2){const Be=Math.sqrt(2),Le=Ee.getChannelData(0),He=Ee.getChannelData(1);Se=new Float32Array(Le.length);for(let Me=0;Me<Ee.length;++Me)Se[Me]=Be*(Le[Me]+He[Me])/2}else Se=Ee.getChannelData(0);return Se}function E(L,de){if(L<1)return new Float64Array;if(L===1)return new Float64Array([1]);const ce=1-de,Pe=2*Math.PI/(L-1),Ee=new Float64Array(L);for(let Se=0;Se<L;++Se)Ee[Se]=de-ce*Math.cos(Se*Pe);return Ee}function C(L){return E(L,.5)}function k(L){return E(L,.54)}const A={htk:L=>2595*Math.log10(1+L/700),kaldi:L=>1127*Math.log(1+L/700),slaney:(L,de=1e3,ce=15,Pe=27/Math.log(6.4))=>L>=de?ce+Math.log(L/de)*Pe:3*L/200};function $(L,de="htk"){const ce=A[de];if(!ce)throw new Error('mel_scale should be one of "htk", "slaney" or "kaldi".');return typeof L=="number"?ce(L):L.map(Pe=>ce(Pe))}const ae={htk:L=>700*(10**(L/2595)-1),kaldi:L=>700*(Math.exp(L/1127)-1),slaney:(L,de=1e3,ce=15,Pe=Math.log(6.4)/27)=>L>=ce?de*Math.exp(Pe*(L-ce)):200*L/3};function fe(L,de="htk"){const ce=ae[de];if(!ce)throw new Error('mel_scale should be one of "htk", "slaney" or "kaldi".');return typeof L=="number"?ce(L):L.map(Pe=>ce(Pe))}function ge(L,de){const ce=Float64Array.from({length:de.length-1},(Be,Le)=>de[Le+1]-de[Le]),Pe=Array.from({length:L.length},()=>new Array(de.length));for(let Be=0;Be<L.length;++Be){const Le=Pe[Be];for(let He=0;He<de.length;++He)Le[He]=de[He]-L[Be]}const Ee=de.length-2,Se=Array.from({length:Ee},()=>new Array(L.length));for(let Be=0;Be<L.length;++Be){const Le=Pe[Be];for(let He=0;He<Ee;++He){const Me=-Le[He]/ce[He],N=Le[He+2]/ce[He+1];Se[He][Be]=Math.max(0,Math.min(Me,N))}}return Se}function le(L,de,ce){const Pe=(de-L)/(ce-1);return Float64Array.from({length:ce},(Ee,Se)=>L+Pe*Se)}function q(L,de,ce,Pe,Ee,Se=null,Be="htk",Le=!1){if(Se!==null&&Se!=="slaney")throw new Error('norm must be one of null or "slaney"');const He=$(ce,Be),Me=$(Pe,Be),N=le(He,Me,de+2);let me=fe(N,Be),ue;if(Le){const Te=Ee/(L*2);ue=$(Float64Array.from({length:L},(je,qe)=>qe*Te),Be),me=N}else ue=le(0,Math.floor(Ee/2),L);const ee=ge(ue,me);if(Se!==null&&Se==="slaney")for(let Te=0;Te<de;++Te){const je=ee[Te],qe=2/(me[Te+2]-me[Te]);for(let tt=0;tt<L;++tt)je[tt]*=qe}return ee}function ie(L,de,ce){const Pe=new L.constructor(L.length+de+ce),Ee=L.length-1;for(let Se=0;Se<L.length;++Se)Pe[de+Se]=L[Se];for(let Se=1;Se<=de;++Se)Pe[de-Se]=L[(0,Q.calculateReflectOffset)(Se,Ee)];for(let Se=1;Se<=ce;++Se)Pe[Ee+de+Se]=L[(0,Q.calculateReflectOffset)(Ee-Se,Ee)];return Pe}function pe(L,de,ce,Pe,Ee){if(ce<=0)throw new Error("reference must be greater than zero");if(Pe<=0)throw new Error("min_value must be greater than zero");ce=Math.max(Pe,ce);const Se=Math.log10(ce);for(let Be=0;Be<L.length;++Be)L[Be]=de*Math.log10(Math.max(Pe,L[Be])-Se);if(Ee!==null){if(Ee<=0)throw new Error("db_range must be greater than zero");const Be=(0,R.max)(L)[0]-Ee;for(let Le=0;Le<L.length;++Le)L[Le]=Math.max(L[Le],Be)}return L}function X(L,de=1,ce=1e-5,Pe=null){return pe(L,20,de,ce,Pe)}function W(L,de=1,ce=1e-10,Pe=null){return pe(L,10,de,ce,Pe)}async function b(L,de,ce,Pe,{fft_length:Ee=null,power:Se=1,center:Be=!0,pad_mode:Le="reflect",onesided:He=!0,preemphasis:Me=null,mel_filters:N=null,mel_floor:me=1e-10,log_mel:ue=null,reference:ee=1,min_value:Te=1e-10,db_range:je=null,remove_dc_offset:qe=null,min_num_frames:tt=null,max_num_frames:he=null,do_pad:Ve=!0,transpose:Je=!1}={}){const We=de.length;if(Ee===null&&(Ee=ce),ce>Ee)throw Error(`frame_length (${ce}) may not be larger than fft_length (${Ee})`);if(We!==ce)throw new Error(`Length of the window (${We}) must equal frame_length (${ce})`);if(Pe<=0)throw new Error("hop_length must be greater than zero");if(Se===null&&N!==null)throw new Error("You have provided `mel_filters` but `power` is `None`. Mel spectrogram computation is not yet supported for complex-valued spectrogram. Specify `power` to fix this issue.");if(Be){if(Le!=="reflect")throw new Error(`pad_mode="${Le}" not implemented yet.`);const U=Math.floor((Ee-1)/2)+1;L=ie(L,U,U)}let be=Math.floor(1+Math.floor((L.length-ce)/Pe));tt!==null&&be<tt&&(be=tt);const Re=He?Math.floor(Ee/2)+1:Ee;let lt=be,ot=be;he!==null&&(he>be?Ve&&(ot=he):ot=lt=he);const st=new R.FFT(Ee),Xe=new Float64Array(Ee),pt=new Float64Array(st.outputBufferSize),_t=new Float32Array(Re*ot);for(let U=0;U<lt;++U){const _e=U*Pe,Z=Math.min(L.length-_e,ce);Z!==ce&&Xe.fill(0,0,ce);for(let xe=0;xe<Z;++xe)Xe[xe]=L[_e+xe];if(qe){let xe=0;for(let at=0;at<Z;++at)xe+=Xe[at];const Ne=xe/Z;for(let at=0;at<Z;++at)Xe[at]-=Ne}if(Me!==null){for(let xe=Z-1;xe>=1;--xe)Xe[xe]-=Me*Xe[xe-1];Xe[0]*=1-Me}for(let xe=0;xe<de.length;++xe)Xe[xe]*=de[xe];st.realTransform(pt,Xe);for(let xe=0;xe<Re;++xe){const Ne=xe<<1;_t[xe*ot+U]=pt[Ne]**2+pt[Ne+1]**2}}if(Se!==null&&Se!==2){const U=2/Se;for(let _e=0;_e<_t.length;++_e)_t[_e]**=U}const Et=N.length;let wt=await(0,se.matmul)(new se.Tensor("float32",N.flat(),[Et,Re]),new se.Tensor("float32",_t,[Re,ot]));Je&&(wt=wt.transpose(1,0));const vt=wt.data;for(let U=0;U<vt.length;++U)vt[U]=Math.max(me,vt[U]);if(Se!==null&&ue!==null){const U=Math.min(vt.length,lt*Et);switch(ue){case"log":for(let _e=0;_e<U;++_e)vt[_e]=Math.log(vt[_e]);break;case"log10":for(let _e=0;_e<U;++_e)vt[_e]=Math.log10(vt[_e]);break;case"dB":if(Se===1)X(vt,ee,Te,je);else if(Se===2)W(vt,ee,Te,je);else throw new Error(`Cannot use log_mel option '${ue}' with power ${Se}`);break;default:throw new Error(`log_mel must be one of null, 'log', 'log10' or 'dB'. Got '${ue}'`)}}return wt}function z(L,de,{periodic:ce=!0,frame_length:Pe=null,center:Ee=!0}={}){const Se=ce?L+1:L;let Be;switch(de){case"boxcar":Be=new Float64Array(Se).fill(1);break;case"hann":case"hann_window":Be=C(Se);break;case"hamming":Be=k(Se);break;case"povey":Be=C(Se).map(Le=>Math.pow(Le,.85));break;default:throw new Error(`Unknown window type ${de}.`)}if(ce&&(Be=Be.subarray(0,L)),Pe===null)return Be;if(L>Pe)throw new Error(`Length of the window (${L}) may not be larger than frame_length (${Pe})`);return Be}},"./src/utils/constants.js":(ke,V,f)=>{f.r(V),f.d(V,{CHAT_TEMPLATE_NAME:()=>E,CONFIG_NAME:()=>R,FEATURE_EXTRACTOR_NAME:()=>Q,GENERATION_CONFIG_NAME:()=>C,GITHUB_ISSUE_URL:()=>P,IMAGE_PROCESSOR_NAME:()=>se,PROCESSOR_NAME:()=>oe});const P="https://github.com/huggingface/transformers.js/issues/new/choose",R="config.json",Q="preprocessor_config.json",se=Q,oe="processor_config.json",E="chat_template.json",C="generation_config.json"},"./src/utils/core.js":(ke,V,f)=>{f.r(V),f.d(V,{calculateDimensions:()=>C,calculateReflectOffset:()=>ae,dispatchCallback:()=>P,escapeRegExp:()=>Q,isIntegralNumber:()=>oe,isNullishDimension:()=>E,isTypedArray:()=>se,len:()=>ge,mergeArrays:()=>A,pick:()=>fe,pop:()=>k,product:()=>$,reverseDictionary:()=>R});function P(le,q){le&&le(q)}function R(le){return Object.fromEntries(Object.entries(le).map(([q,ie])=>[ie,q]))}function Q(le){return le.replace(/[.*+?^${}()|[\]\\]/g,"\\$&")}function se(le){var q,ie,pe;return((pe=(ie=(q=le==null?void 0:le.prototype)==null?void 0:q.__proto__)==null?void 0:ie.constructor)==null?void 0:pe.name)==="TypedArray"}function oe(le){return Number.isInteger(le)||typeof le=="bigint"}function E(le){return le==null||le===-1}function C(le){const q=[];let ie=le;for(;Array.isArray(ie);)q.push(ie.length),ie=ie[0];return q}function k(le,q,ie=void 0){const pe=le[q];if(pe!==void 0)return delete le[q],pe;if(ie===void 0)throw Error(`Key ${q} does not exist in object.`);return ie}function A(...le){return Array.prototype.concat.apply([],le)}function $(...le){return le.reduce((q,ie)=>q.flatMap(pe=>ie.map(X=>[pe,X])))}function ae(le,q){return Math.abs((le+q)%(2*q)-q)}function fe(le,q){return Object.assign({},...q.map(ie=>{if(le[ie]!==void 0)return{[ie]:le[ie]}}))}function ge(le){let q=0;for(const ie of le)++q;return q}},"./src/utils/data-structures.js":(ke,V,f)=>{f.r(V),f.d(V,{CharTrie:()=>R,PriorityQueue:()=>P,TokenLattice:()=>se});class P{constructor(C=(A,$)=>A>$,k=1/0){this._heap=[],this._comparator=C,this._maxSize=k}get size(){return this._heap.length}isEmpty(){return this.size===0}peek(){return this._heap[0]}push(...C){return this.extend(C)}extend(C){for(const k of C)if(this.size<this._maxSize)this._heap.push(k),this._siftUp();else{const A=this._smallest();this._comparator(k,this._heap[A])&&(this._heap[A]=k,this._siftUpFrom(A))}return this.size}pop(){const C=this.peek(),k=this.size-1;return k>0&&this._swap(0,k),this._heap.pop(),this._siftDown(),C}replace(C){const k=this.peek();return this._heap[0]=C,this._siftDown(),k}_parent(C){return(C+1>>>1)-1}_left(C){return(C<<1)+1}_right(C){return C+1<<1}_greater(C,k){return this._comparator(this._heap[C],this._heap[k])}_swap(C,k){const A=this._heap[C];this._heap[C]=this._heap[k],this._heap[k]=A}_siftUp(){this._siftUpFrom(this.size-1)}_siftUpFrom(C){for(;C>0&&this._greater(C,this._parent(C));)this._swap(C,this._parent(C)),C=this._parent(C)}_siftDown(){let C=0;for(;this._left(C)<this.size&&this._greater(this._left(C),C)||this._right(C)<this.size&&this._greater(this._right(C),C);){const k=this._right(C)<this.size&&this._greater(this._right(C),this._left(C))?this._right(C):this._left(C);this._swap(C,k),C=k}}_smallest(){return 2**Math.floor(Math.log2(this.size))-1}}class R{constructor(){this.root=Q.default()}extend(C){for(const k of C)this.push(k)}push(C){let k=this.root;for(const A of C){let $=k.children.get(A);$===void 0&&($=Q.default(),k.children.set(A,$)),k=$}k.isLeaf=!0}*commonPrefixSearch(C){let k=this.root;if(k===void 0)return;let A="";for(const $ of C){if(A+=$,k=k.children.get($),k===void 0)return;k.isLeaf&&(yield A)}}}class Q{constructor(C,k){this.isLeaf=C,this.children=k}static default(){return new Q(!1,new Map)}}class se{constructor(C,k,A){this.chars=Array.from(C),this.len=this.chars.length,this.bosTokenId=k,this.eosTokenId=A,this.nodes=[],this.beginNodes=Array.from({length:this.len+1},()=>[]),this.endNodes=Array.from({length:this.len+1},()=>[]);const $=new oe(this.bosTokenId,0,0,0,0),ae=new oe(this.eosTokenId,1,this.len,0,0);this.nodes.push($.clone()),this.nodes.push(ae.clone()),this.beginNodes[this.len].push(ae),this.endNodes[0].push($)}insert(C,k,A,$){const ae=this.nodes.length,fe=new oe($,ae,C,k,A);this.beginNodes[C].push(fe),this.endNodes[C+k].push(fe),this.nodes.push(fe)}viterbi(){const C=this.len;let k=0;for(;k<=C;){if(this.beginNodes[k].length==0)return[];for(let ge of this.beginNodes[k]){ge.prev=null;let le=0,q=null;for(let ie of this.endNodes[k]){const pe=ie.backtraceScore+ge.score;(q===null||pe>le)&&(q=ie.clone(),le=pe)}if(q!==null)ge.prev=q,ge.backtraceScore=le;else return[]}++k}const A=[],ae=this.beginNodes[C][0].prev;if(ae===null)return[];let fe=ae.clone();for(;fe.prev!==null;)A.push(fe.clone()),fe=fe.clone().prev.clone();return A.reverse(),A}piece(C){return this.chars.slice(C.pos,C.pos+C.length).join("")}tokens(){return this.viterbi().map(k=>this.piece(k))}tokenIds(){return this.viterbi().map(k=>k.tokenId)}}class oe{constructor(C,k,A,$,ae){this.tokenId=C,this.nodeId=k,this.pos=A,this.length=$,this.score=ae,this.prev=null,this.backtraceScore=0}clone(){const C=new oe(this.tokenId,this.nodeId,this.pos,this.length,this.score);return C.prev=this.prev,C.backtraceScore=this.backtraceScore,C}}},"./src/utils/devices.js":(ke,V,f)=>{f.r(V),f.d(V,{DEVICE_TYPES:()=>P});const P=Object.freeze({auto:"auto",gpu:"gpu",cpu:"cpu",wasm:"wasm",webgpu:"webgpu",cuda:"cuda",dml:"dml",webnn:"webnn","webnn-npu":"webnn-npu","webnn-gpu":"webnn-gpu","webnn-cpu":"webnn-cpu"})},"./src/utils/dtypes.js":(ke,V,f)=>{f.r(V),f.d(V,{DATA_TYPES:()=>se,DEFAULT_DEVICE_DTYPE_MAPPING:()=>oe,DEFAULT_DTYPE_SUFFIX_MAPPING:()=>E,isWebGpuFp16Supported:()=>Q});var P=f("./src/env.js"),R=f("./src/utils/devices.js");const Q=function(){let C;return async function(){if(C===void 0)if(!P.apis.IS_WEBGPU_AVAILABLE)C=!1;else try{C=(await navigator.gpu.requestAdapter()).features.has("shader-f16")}catch{C=!1}return C}}(),se=Object.freeze({fp32:"fp32",fp16:"fp16",q8:"q8",int8:"int8",uint8:"uint8",q4:"q4",bnb4:"bnb4",q4f16:"q4f16"}),oe=Object.freeze({[R.DEVICE_TYPES.wasm]:se.q8}),E=Object.freeze({[se.fp32]:"",[se.fp16]:"_fp16",[se.int8]:"_int8",[se.uint8]:"_uint8",[se.q8]:"_quantized",[se.q4]:"_q4",[se.q4f16]:"_q4f16",[se.bnb4]:"_bnb4"})},"./src/utils/generic.js":(ke,V,f)=>{f.r(V),f.d(V,{Callable:()=>P});const P=class{constructor(){let R=function(...Q){return R._call(...Q)};return Object.setPrototypeOf(R,new.target.prototype)}_call(...R){throw Error("Must implement _call method in subclass")}}},"./src/utils/hub.js":(ke,V,f)=>{f.r(V),f.d(V,{getFile:()=>k,getModelFile:()=>ge,getModelJSON:()=>le});var P=f("?7a2c"),R=f("?a42a"),Q=f("./src/env.js"),se=f("./src/utils/core.js");const oe={txt:"text/plain",html:"text/html",css:"text/css",js:"text/javascript",json:"application/json",png:"image/png",jpg:"image/jpeg",jpeg:"image/jpeg",gif:"image/gif"};class E{constructor(X){if(this.filePath=X,this.headers=new Headers,this.exists=P.existsSync(X),this.exists){this.status=200,this.statusText="OK";let W=P.statSync(X);this.headers.set("content-length",W.size.toString()),this.updateContentType();let b=this;this.body=new ReadableStream({start(z){b.arrayBuffer().then(L=>{z.enqueue(new Uint8Array(L)),z.close()})}})}else this.status=404,this.statusText="Not Found",this.body=null}updateContentType(){const X=this.filePath.toString().split(".").pop().toLowerCase();this.headers.set("content-type",oe[X]??"application/octet-stream")}clone(){let X=new E(this.filePath);return X.exists=this.exists,X.status=this.status,X.statusText=this.statusText,X.headers=new Headers(this.headers),X}async arrayBuffer(){return(await P.promises.readFile(this.filePath)).buffer}async blob(){const X=await P.promises.readFile(this.filePath);return new Blob([X],{type:this.headers.get("content-type")})}async text(){return await P.promises.readFile(this.filePath,"utf8")}async json(){return JSON.parse(await this.text())}}function C(pe,X=null,W=null){let b;try{b=new URL(pe)}catch{return!1}return!(X&&!X.includes(b.protocol)||W&&!W.includes(b.hostname))}async function k(pe){var X;if(Q.env.useFS&&!C(pe,["http:","https:","blob:"]))return new E(pe);if(typeof process<"u"&&((X=process==null?void 0:process.release)==null?void 0:X.name)==="node"){const W=!!(yu!=null&&yu.TESTING_REMOTELY),b=Q.env.version,z=new Headers;if(z.set("User-Agent",`transformers.js/${b}; is_ci/${W};`),C(pe,["http:","https:"],["huggingface.co","hf.co"])){const de=(yu==null?void 0:yu.HF_TOKEN)??(yu==null?void 0:yu.HF_ACCESS_TOKEN);de&&z.set("Authorization",`Bearer ${de}`)}return fetch(pe,{headers:z})}else return fetch(pe)}const A={400:"Bad request error occurred while trying to load file",401:"Unauthorized access to file",403:"Forbidden access to file",404:"Could not locate file",408:"Request timeout error occurred while trying to load file",500:"Internal server error error occurred while trying to load file",502:"Bad gateway error occurred while trying to load file",503:"Service unavailable error occurred while trying to load file",504:"Gateway timeout error occurred while trying to load file"};function $(pe,X,W){if(!W)return null;const b=A[pe]??`Error (${pe}) occurred while trying to load file`;throw Error(`${b}: "${X}".`)}class ae{constructor(X){this.path=X}async match(X){let W=R.join(this.path,X),b=new E(W);if(b.exists)return b}async put(X,W){const b=Buffer.from(await W.arrayBuffer());let z=R.join(this.path,X);try{await P.promises.mkdir(R.dirname(z),{recursive:!0}),await P.promises.writeFile(z,b)}catch(L){console.warn("An error occurred while writing the file to cache:",L)}}}async function fe(pe,...X){for(let W of X)try{let b=await pe.match(W);if(b)return b}catch{continue}}async function ge(pe,X,W=!0,b={}){if(!Q.env.allowLocalModels){if(b.local_files_only)throw Error("Invalid configuration detected: local models are disabled (`env.allowLocalModels=false`) but you have requested to only use local models (`local_files_only=true`).");if(!Q.env.allowRemoteModels)throw Error("Invalid configuration detected: both local and remote models are disabled. Fix by setting `env.allowLocalModels` or `env.allowRemoteModels` to `true`.")}(0,se.dispatchCallback)(b.progress_callback,{status:"initiate",name:pe,file:X});let z;if(!z&&Q.env.useBrowserCache){if(typeof caches>"u")throw Error("Browser cache is not available in this environment.");try{z=await caches.open("transformers-cache")}catch(ue){console.warn("An error occurred while opening the browser cache:",ue)}}if(!z&&Q.env.useFSCache&&(z=new ae(b.cache_dir??Q.env.cacheDir)),!z&&Q.env.useCustomCache){if(!Q.env.customCache)throw Error("`env.useCustomCache=true`, but `env.customCache` is not defined.");if(!Q.env.customCache.match||!Q.env.customCache.put)throw new Error("`env.customCache` must be an object which implements the `match` and `put` functions of the Web Cache API. For more information, see https://developer.mozilla.org/en-US/docs/Web/API/Cache");z=Q.env.customCache}const L=b.revision??"main";let de=ie(pe,X),ce=ie(Q.env.localModelPath,de),Pe=ie(Q.env.remoteHost,Q.env.remotePathTemplate.replaceAll("{model}",pe).replaceAll("{revision}",encodeURIComponent(L)),X),Ee=L==="main"?de:ie(pe,L,X),Se,Be=z instanceof ae?Ee:Pe,Le=!1,He;z&&(He=await fe(z,ce,Be));const Me=He!==void 0;if(He===void 0){if(Q.env.allowLocalModels)if(C(de,["http:","https:"])){if(b.local_files_only)throw new Error(`\`local_files_only=true\`, but attempted to load a remote file from: ${de}.`);if(!Q.env.allowRemoteModels)throw new Error(`\`env.allowRemoteModels=false\`, but attempted to load a remote file from: ${de}.`)}else try{He=await k(ce),Se=ce}catch(ee){console.warn(`Unable to load from local path "${ce}": "${ee}"`)}if(He===void 0||He.status===404){if(b.local_files_only||!Q.env.allowRemoteModels){if(W)throw Error(`\`local_files_only=true\` or \`env.allowRemoteModels=false\` and file was not found locally at "${ce}".`);return null}if(He=await k(Pe),He.status!==200)return $(He.status,Pe,W);Se=Be}Le=z&&typeof Response<"u"&&He instanceof Response&&He.status===200}(0,se.dispatchCallback)(b.progress_callback,{status:"download",name:pe,file:X});const N={status:"progress",name:pe,file:X};let me;return b.progress_callback?Me&&typeof navigator<"u"&&/firefox/i.test(navigator.userAgent)?(me=new Uint8Array(await He.arrayBuffer()),(0,se.dispatchCallback)(b.progress_callback,{...N,progress:100,loaded:me.length,total:me.length})):me=await q(He,ue=>{(0,se.dispatchCallback)(b.progress_callback,{...N,...ue})}):me=new Uint8Array(await He.arrayBuffer()),Le&&Se&&await z.match(Se)===void 0&&await z.put(Se,new Response(me,{headers:He.headers})).catch(ue=>{console.warn(`Unable to add response to browser cache: ${ue}.`)}),(0,se.dispatchCallback)(b.progress_callback,{status:"done",name:pe,file:X}),me}async function le(pe,X,W=!0,b={}){let z=await ge(pe,X,W,b);if(z===null)return{};let de=new TextDecoder("utf-8").decode(z);return JSON.parse(de)}async function q(pe,X){const W=pe.headers.get("Content-Length");W===null&&console.warn("Unable to determine content-length from response headers. Will expand buffer when needed.");let b=parseInt(W??"0"),z=new Uint8Array(b),L=0;const de=pe.body.getReader();async function ce(){const{done:Pe,value:Ee}=await de.read();if(Pe)return;let Se=L+Ee.length;if(Se>b){b=Se;let Le=new Uint8Array(b);Le.set(z),z=Le}z.set(Ee,L),L=Se;const Be=L/b*100;return X({progress:Be,loaded:L,total:b}),ce()}return await ce(),z}function ie(...pe){return pe=pe.map((X,W)=>(W&&(X=X.replace(new RegExp("^/"),"")),W!==pe.length-1&&(X=X.replace(new RegExp("/$"),"")),X)),pe.join("/")}},"./src/utils/image.js":(ke,V,f)=>{f.r(V),f.d(V,{RawImage:()=>ge});var P=f("./src/utils/core.js"),R=f("./src/utils/hub.js"),Q=f("./src/env.js"),se=f("./src/utils/tensor.js"),oe=f("?2b25");const E=typeof self<"u",C=E&&self.constructor.name==="DedicatedWorkerGlobalScope";let k,A,$;if(E)k=(le,q)=>{if(!self.OffscreenCanvas)throw new Error("OffscreenCanvas not supported by this browser.");return new self.OffscreenCanvas(le,q)},$=self.createImageBitmap,A=self.ImageData;else if(oe)$=async le=>{const ie=(await le.metadata()).channels,{data:pe,info:X}=await le.rotate().raw().toBuffer({resolveWithObject:!0}),W=new ge(new Uint8ClampedArray(pe),X.width,X.height,X.channels);return ie!==void 0&&ie!==X.channels&&W.convert(ie),W};else throw new Error("Unable to load image processing library.");const ae={0:"nearest",1:"lanczos",2:"bilinear",3:"bicubic",4:"box",5:"hamming"},fe=new Map([["png","image/png"],["jpg","image/jpeg"],["jpeg","image/jpeg"],["gif","image/gif"]]);class ge{constructor(q,ie,pe,X){this.data=q,this.width=ie,this.height=pe,this.channels=X}get size(){return[this.width,this.height]}static async read(q){if(q instanceof ge)return q;if(typeof q=="string"||q instanceof URL)return await this.fromURL(q);throw new Error(`Unsupported input type: ${typeof q}`)}static fromCanvas(q){if(!E)throw new Error("fromCanvas() is only supported in browser environments.");const pe=q.getContext("2d").getImageData(0,0,q.width,q.height).data;return new ge(pe,q.width,q.height,4)}static async fromURL(q){const ie=await(0,R.getFile)(q);if(ie.status!==200)throw new Error(`Unable to read image from "${q}" (${ie.status} ${ie.statusText})`);const pe=await ie.blob();return this.fromBlob(pe)}static async fromBlob(q){if(E){const ie=await $(q),pe=k(ie.width,ie.height).getContext("2d");return pe.drawImage(ie,0,0),new this(pe.getImageData(0,0,ie.width,ie.height).data,ie.width,ie.height,4)}else{const ie=oe(await q.arrayBuffer());return await $(ie)}}static fromTensor(q,ie="CHW"){if(q.dims.length!==3)throw new Error(`Tensor should have 3 dimensions, but has ${q.dims.length} dimensions.`);if(ie==="CHW")q=q.transpose(1,2,0);else if(ie!=="HWC")throw new Error(`Unsupported channel format: ${ie}`);if(!(q.data instanceof Uint8ClampedArray||q.data instanceof Uint8Array))throw new Error(`Unsupported tensor type: ${q.type}`);switch(q.dims[2]){case 1:case 2:case 3:case 4:return new ge(q.data,q.dims[1],q.dims[0],q.dims[2]);default:throw new Error(`Unsupported number of channels: ${q.dims[2]}`)}}grayscale(){if(this.channels===1)return this;const q=new Uint8ClampedArray(this.width*this.height*1);switch(this.channels){case 3:case 4:for(let ie=0,pe=0;ie<this.data.length;ie+=this.channels){const X=this.data[ie],W=this.data[ie+1],b=this.data[ie+2];q[pe++]=Math.round(.2989*X+.587*W+.114*b)}break;default:throw new Error(`Conversion failed due to unsupported number of channels: ${this.channels}`)}return this._update(q,this.width,this.height,1)}rgb(){if(this.channels===3)return this;const q=new Uint8ClampedArray(this.width*this.height*3);switch(this.channels){case 1:for(let ie=0,pe=0;ie<this.data.length;++ie)q[pe++]=this.data[ie],q[pe++]=this.data[ie],q[pe++]=this.data[ie];break;case 4:for(let ie=0,pe=0;ie<this.data.length;ie+=4)q[pe++]=this.data[ie],q[pe++]=this.data[ie+1],q[pe++]=this.data[ie+2];break;default:throw new Error(`Conversion failed due to unsupported number of channels: ${this.channels}`)}return this._update(q,this.width,this.height,3)}rgba(){if(this.channels===4)return this;const q=new Uint8ClampedArray(this.width*this.height*4);switch(this.channels){case 1:for(let ie=0,pe=0;ie<this.data.length;++ie)q[pe++]=this.data[ie],q[pe++]=this.data[ie],q[pe++]=this.data[ie],q[pe++]=255;break;case 3:for(let ie=0,pe=0;ie<this.data.length;ie+=3)q[pe++]=this.data[ie],q[pe++]=this.data[ie+1],q[pe++]=this.data[ie+2],q[pe++]=255;break;default:throw new Error(`Conversion failed due to unsupported number of channels: ${this.channels}`)}return this._update(q,this.width,this.height,4)}async resize(q,ie,{resample:pe=2}={}){if(this.width===q&&this.height===ie)return this;let X=ae[pe]??pe;const W=(0,P.isNullishDimension)(q),b=(0,P.isNullishDimension)(ie);if(W&&b)return this;if(W?q=ie/this.height*this.width:b&&(ie=q/this.width*this.height),E){const z=this.channels,L=this.toCanvas(),de=k(q,ie).getContext("2d");return de.drawImage(L,0,0,q,ie),new ge(de.getImageData(0,0,q,ie).data,q,ie,4).convert(z)}else{let z=this.toSharp();switch(X){case"box":case"hamming":(X==="box"||X==="hamming")&&(console.warn(`Resampling method ${X} is not yet supported. Using bilinear instead.`),X="bilinear");case"nearest":case"bilinear":case"bicubic":z=z.affine([q/this.width,0,0,ie/this.height],{interpolator:X});break;case"lanczos":z=z.resize({width:q,height:ie,fit:"fill",kernel:"lanczos3"});break;default:throw new Error(`Resampling method ${X} is not supported.`)}return await $(z)}}async pad([q,ie,pe,X]){if(q=Math.max(q,0),ie=Math.max(ie,0),pe=Math.max(pe,0),X=Math.max(X,0),q===0&&ie===0&&pe===0&&X===0)return this;if(E){const W=this.channels,b=this.toCanvas(),z=this.width+q+ie,L=this.height+pe+X,de=k(z,L).getContext("2d");return de.drawImage(b,0,0,this.width,this.height,q,pe,this.width,this.height),new ge(de.getImageData(0,0,z,L).data,z,L,4).convert(W)}else{const W=this.toSharp().extend({left:q,right:ie,top:pe,bottom:X});return await $(W)}}async crop([q,ie,pe,X]){if(q=Math.max(q,0),ie=Math.max(ie,0),pe=Math.min(pe,this.width-1),X=Math.min(X,this.height-1),q===0&&ie===0&&pe===this.width-1&&X===this.height-1)return this;const W=pe-q+1,b=X-ie+1;if(E){const z=this.channels,L=this.toCanvas(),de=k(W,b).getContext("2d");return de.drawImage(L,q,ie,W,b,0,0,W,b),new ge(de.getImageData(0,0,W,b).data,W,b,4).convert(z)}else{const z=this.toSharp().extract({left:q,top:ie,width:W,height:b});return await $(z)}}async center_crop(q,ie){if(this.width===q&&this.height===ie)return this;const pe=(this.width-q)/2,X=(this.height-ie)/2;if(E){const W=this.channels,b=this.toCanvas(),z=k(q,ie).getContext("2d");let L=0,de=0,ce=0,Pe=0;return pe>=0?L=pe:ce=-pe,X>=0?de=X:Pe=-X,z.drawImage(b,L,de,q,ie,ce,Pe,q,ie),new ge(z.getImageData(0,0,q,ie).data,q,ie,4).convert(W)}else{let W=this.toSharp();if(pe>=0&&X>=0)W=W.extract({left:Math.floor(pe),top:Math.floor(X),width:q,height:ie});else if(pe<=0&&X<=0){const b=Math.floor(-X),z=Math.floor(-pe);W=W.extend({top:b,left:z,right:q-this.width-z,bottom:ie-this.height-b})}else{let b=[0,0],z=0;X<0?(b[0]=Math.floor(-X),b[1]=ie-this.height-b[0]):z=Math.floor(X);let L=[0,0],de=0;pe<0?(L[0]=Math.floor(-pe),L[1]=q-this.width-L[0]):de=Math.floor(pe),W=W.extend({top:b[0],bottom:b[1],left:L[0],right:L[1]}).extract({left:de,top:z,width:q,height:ie})}return await $(W)}}async toBlob(q="image/png",ie=1){if(!E)throw new Error("toBlob() is only supported in browser environments.");return await this.toCanvas().convertToBlob({type:q,quality:ie})}toTensor(q="CHW"){let ie=new se.Tensor("uint8",new Uint8Array(this.data),[this.height,this.width,this.channels]);if(q!=="HWC")if(q==="CHW")ie=ie.permute(2,0,1);else throw new Error(`Unsupported channel format: ${q}`);return ie}toCanvas(){if(!E)throw new Error("toCanvas() is only supported in browser environments.");const q=this.clone().rgba(),ie=k(q.width,q.height),pe=new A(q.data,q.width,q.height);return ie.getContext("2d").putImageData(pe,0,0),ie}split(){const{data:q,width:ie,height:pe,channels:X}=this,W=q.constructor,b=q.length/X,z=Array.from({length:X},()=>new W(b));for(let L=0;L<b;++L){const de=X*L;for(let ce=0;ce<X;++ce)z[ce][L]=q[de+ce]}return z.map(L=>new ge(L,ie,pe,1))}_update(q,ie,pe,X=null){return this.data=q,this.width=ie,this.height=pe,X!==null&&(this.channels=X),this}clone(){return new ge(this.data.slice(),this.width,this.height,this.channels)}convert(q){if(this.channels===q)return this;switch(q){case 1:this.grayscale();break;case 3:this.rgb();break;case 4:this.rgba();break;default:throw new Error(`Conversion failed due to unsupported number of channels: ${this.channels}`)}return this}async save(q){if(E){if(C)throw new Error("Unable to save an image from a Web Worker.");const ie=q.split(".").pop().toLowerCase(),pe=fe.get(ie)??"image/png",X=await this.toBlob(pe),W=URL.createObjectURL(X),b=document.createElement("a");b.href=W,b.download=q,b.click(),b.remove()}else{if(Q.env.useFS)return await this.toSharp().toFile(q);throw new Error("Unable to save the image because filesystem is disabled in this environment.")}}toSharp(){if(E)throw new Error("toSharp() is only supported in server-side environments.");return oe(this.data,{raw:{width:this.width,height:this.height,channels:this.channels}})}}},"./src/utils/maths.js":(ke,V,f)=>{f.r(V),f.d(V,{FFT:()=>ge,bankers_round:()=>ie,cos_sim:()=>E,dot:()=>oe,dynamic_time_warping:()=>pe,interpolate_data:()=>P,log_softmax:()=>se,magnitude:()=>C,max:()=>A,medianFilter:()=>le,min:()=>k,permute_data:()=>R,round:()=>q,softmax:()=>Q});function P(X,[W,b,z],[L,de],ce="bilinear",Pe=!1){const Ee=de/z,Se=L/b,Be=new X.constructor(L*de*W),Le=b*z,He=L*de;for(let Me=0;Me<L;++Me)for(let N=0;N<de;++N){const me=Me*de+N,ue=(N+.5)/Ee-.5,ee=(Me+.5)/Se-.5;let Te=Math.floor(ue),je=Math.floor(ee);const qe=Math.min(Te+1,z-1),tt=Math.min(je+1,b-1);Te=Math.max(Te,0),je=Math.max(je,0);const he=ue-Te,Ve=ee-je,Je=(1-he)*(1-Ve),We=he*(1-Ve),be=(1-he)*Ve,Re=he*Ve,lt=je*z,ot=tt*z,st=lt+Te,Xe=lt+qe,pt=ot+Te,_t=ot+qe;for(let Et=0;Et<W;++Et){const wt=Et*Le;Be[Et*He+me]=Je*X[wt+st]+We*X[wt+Xe]+be*X[wt+pt]+Re*X[wt+_t]}}return Be}function R(X,W,b){const z=new Array(b.length),L=new Array(b.length);for(let Pe=b.length-1,Ee=1;Pe>=0;--Pe)L[Pe]=Ee,z[Pe]=W[b[Pe]],Ee*=z[Pe];const de=b.map((Pe,Ee)=>L[b.indexOf(Ee)]),ce=new X.constructor(X.length);for(let Pe=0;Pe<X.length;++Pe){let Ee=0;for(let Se=W.length-1,Be=Pe;Se>=0;--Se)Ee+=Be%W[Se]*de[Se],Be=Math.floor(Be/W[Se]);ce[Ee]=X[Pe]}return[ce,z]}function Q(X){const W=A(X)[0],b=X.map(de=>Math.exp(de-W)),z=b.reduce((de,ce)=>de+ce,0);return b.map(de=>de/z)}function se(X){const W=A(X)[0];let b=0;for(let de=0;de<X.length;++de)b+=Math.exp(X[de]-W);const z=Math.log(b);return X.map(de=>de-W-z)}function oe(X,W){let b=0;for(let z=0;z<X.length;++z)b+=X[z]*W[z];return b}function E(X,W){const b=oe(X,W),z=C(X),L=C(W);return b/(z*L)}function C(X){return Math.sqrt(X.reduce((W,b)=>W+b*b,0))}function k(X){if(X.length===0)throw Error("Array must not be empty");let W=X[0],b=0;for(let z=1;z<X.length;++z)X[z]<W&&(W=X[z],b=z);return[W,b]}function A(X){if(X.length===0)throw Error("Array must not be empty");let W=X[0],b=0;for(let z=1;z<X.length;++z)X[z]>W&&(W=X[z],b=z);return[Number(W),b]}function $(X){return X>0&&(X&X-1)===0}class ae{constructor(W){if(this.size=W|0,this.size<=1||!$(this.size))throw new Error("FFT size must be a power of two larger than 1");this._csize=W<<1,this.table=new Float64Array(this.size*2);for(let z=0;z<this.table.length;z+=2){const L=Math.PI*z/this.size;this.table[z]=Math.cos(L),this.table[z+1]=-Math.sin(L)}let b=0;for(let z=1;this.size>z;z<<=1)++b;this._width=b%2===0?b-1:b,this._bitrev=new Int32Array(1<<this._width);for(let z=0;z<this._bitrev.length;++z){this._bitrev[z]=0;for(let L=0;L<this._width;L+=2){const de=this._width-L-2;this._bitrev[z]|=(z>>>L&3)<<de}}}createComplexArray(){return new Float64Array(this._csize)}fromComplexArray(W,b){const z=b||new Array(W.length>>>1);for(let L=0;L<W.length;L+=2)z[L>>>1]=W[L];return z}toComplexArray(W,b){const z=b||this.createComplexArray();for(let L=0;L<z.length;L+=2)z[L]=W[L>>>1],z[L+1]=0;return z}transform(W,b){if(W===b)throw new Error("Input and output buffers must be different");this._transform4(W,b,1)}realTransform(W,b){if(W===b)throw new Error("Input and output buffers must be different");this._realTransform4(W,b,1)}inverseTransform(W,b){if(W===b)throw new Error("Input and output buffers must be different");this._transform4(W,b,-1);for(let z=0;z<W.length;++z)W[z]/=this.size}_transform4(W,b,z){const L=this._csize;let ce=1<<this._width,Pe=L/ce<<1,Ee,Se;const Be=this._bitrev;if(Pe===4)for(Ee=0,Se=0;Ee<L;Ee+=Pe,++Se){const He=Be[Se];this._singleTransform2(b,W,Ee,He,ce)}else for(Ee=0,Se=0;Ee<L;Ee+=Pe,++Se){const He=Be[Se];this._singleTransform4(b,W,Ee,He,ce,z)}const Le=this.table;for(ce>>=2;ce>=2;ce>>=2){Pe=L/ce<<1;const He=Pe>>>2;for(Ee=0;Ee<L;Ee+=Pe){const Me=Ee+He-1;for(let N=Ee,me=0;N<Me;N+=2,me+=ce){const ue=N,ee=ue+He,Te=ee+He,je=Te+He,qe=W[ue],tt=W[ue+1],he=W[ee],Ve=W[ee+1],Je=W[Te],We=W[Te+1],be=W[je],Re=W[je+1],lt=Le[me],ot=z*Le[me+1],st=he*lt-Ve*ot,Xe=he*ot+Ve*lt,pt=Le[2*me],_t=z*Le[2*me+1],Et=Je*pt-We*_t,wt=Je*_t+We*pt,vt=Le[3*me],U=z*Le[3*me+1],_e=be*vt-Re*U,Z=be*U+Re*vt,xe=qe+Et,Ne=tt+wt,at=qe-Et,ct=tt-wt,gt=st+_e,zt=Xe+Z,$t=z*(st-_e),St=z*(Xe-Z);W[ue]=xe+gt,W[ue+1]=Ne+zt,W[ee]=at+St,W[ee+1]=ct-$t,W[Te]=xe-gt,W[Te+1]=Ne-zt,W[je]=at-St,W[je+1]=ct+$t}}}}_singleTransform2(W,b,z,L,de){const ce=W[L],Pe=W[L+1],Ee=W[L+de],Se=W[L+de+1];b[z]=ce+Ee,b[z+1]=Pe+Se,b[z+2]=ce-Ee,b[z+3]=Pe-Se}_singleTransform4(W,b,z,L,de,ce){const Pe=de*2,Ee=de*3,Se=W[L],Be=W[L+1],Le=W[L+de],He=W[L+de+1],Me=W[L+Pe],N=W[L+Pe+1],me=W[L+Ee],ue=W[L+Ee+1],ee=Se+Me,Te=Be+N,je=Se-Me,qe=Be-N,tt=Le+me,he=He+ue,Ve=ce*(Le-me),Je=ce*(He-ue);b[z]=ee+tt,b[z+1]=Te+he,b[z+2]=je+Je,b[z+3]=qe-Ve,b[z+4]=ee-tt,b[z+5]=Te-he,b[z+6]=je-Je,b[z+7]=qe+Ve}_realTransform4(W,b,z){const L=this._csize;let ce=1<<this._width,Pe=L/ce<<1,Ee,Se;const Be=this._bitrev;if(Pe===4)for(Ee=0,Se=0;Ee<L;Ee+=Pe,++Se){const Me=Be[Se];this._singleRealTransform2(b,W,Ee,Me>>>1,ce>>>1)}else for(Ee=0,Se=0;Ee<L;Ee+=Pe,++Se){const Me=Be[Se];this._singleRealTransform4(b,W,Ee,Me>>>1,ce>>>1,z)}const Le=this.table;for(ce>>=2;ce>=2;ce>>=2){Pe=L/ce<<1;const Me=Pe>>>1,N=Me>>>1,me=N>>>1;for(Ee=0;Ee<L;Ee+=Pe)for(let ue=0,ee=0;ue<=me;ue+=2,ee+=ce){const Te=Ee+ue,je=Te+N,qe=je+N,tt=qe+N,he=W[Te],Ve=W[Te+1],Je=W[je],We=W[je+1],be=W[qe],Re=W[qe+1],lt=W[tt],ot=W[tt+1],st=he,Xe=Ve,pt=Le[ee],_t=z*Le[ee+1],Et=Je*pt-We*_t,wt=Je*_t+We*pt,vt=Le[2*ee],U=z*Le[2*ee+1],_e=be*vt-Re*U,Z=be*U+Re*vt,xe=Le[3*ee],Ne=z*Le[3*ee+1],at=lt*xe-ot*Ne,ct=lt*Ne+ot*xe,gt=st+_e,zt=Xe+Z,$t=st-_e,St=Xe-Z,Ft=Et+at,gr=wt+ct,Cr=z*(Et-at),rn=z*(wt-ct);if(W[Te]=gt+Ft,W[Te+1]=zt+gr,W[je]=$t+rn,W[je+1]=St-Cr,ue===0){W[qe]=gt-Ft,W[qe+1]=zt-gr;continue}if(ue===me)continue;const an=Ee+N-ue,Pn=Ee+Me-ue;W[an]=$t-z*rn,W[an+1]=-St-z*Cr,W[Pn]=gt-z*Ft,W[Pn+1]=-zt+z*gr}}const He=L>>>1;for(let Me=2;Me<He;Me+=2)W[L-Me]=W[Me],W[L-Me+1]=-W[Me+1]}_singleRealTransform2(W,b,z,L,de){const ce=W[L],Pe=W[L+de];b[z]=ce+Pe,b[z+1]=0,b[z+2]=ce-Pe,b[z+3]=0}_singleRealTransform4(W,b,z,L,de,ce){const Pe=de*2,Ee=de*3,Se=W[L],Be=W[L+de],Le=W[L+Pe],He=W[L+Ee],Me=Se+Le,N=Se-Le,me=Be+He,ue=ce*(Be-He);b[z]=Me+me,b[z+1]=0,b[z+2]=N,b[z+3]=-ue,b[z+4]=Me-me,b[z+5]=0,b[z+6]=N,b[z+7]=ue}}class fe{constructor(W){const b=2*(W-1),z=2*(2*W-1),L=2**Math.ceil(Math.log2(z));this.bufferSize=L,this._a=b;const de=new Float64Array(z),ce=new Float64Array(L);this._chirpBuffer=new Float64Array(L),this._buffer1=new Float64Array(L),this._buffer2=new Float64Array(L),this._outBuffer1=new Float64Array(L),this._outBuffer2=new Float64Array(L);const Pe=-2*Math.PI/W,Ee=Math.cos(Pe),Se=Math.sin(Pe);for(let Be=0;Be<z>>1;++Be){const Le=(Be+1-W)**2/2,He=Math.sqrt(Ee**2+Se**2)**Le,Me=Le*Math.atan2(Se,Ee),N=2*Be;de[N]=He*Math.cos(Me),de[N+1]=He*Math.sin(Me),ce[N]=de[N],ce[N+1]=-de[N+1]}this._slicedChirpBuffer=de.subarray(b,z),this._f=new ae(L>>1),this._f.transform(this._chirpBuffer,ce)}_transform(W,b,z){const L=this._buffer1,de=this._buffer2,ce=this._outBuffer1,Pe=this._outBuffer2,Ee=this._chirpBuffer,Se=this._slicedChirpBuffer,Be=this._a;if(z)for(let Le=0;Le<Se.length;Le+=2){const He=Le+1,Me=Le>>1,N=b[Me];L[Le]=N*Se[Le],L[He]=N*Se[He]}else for(let Le=0;Le<Se.length;Le+=2){const He=Le+1;L[Le]=b[Le]*Se[Le]-b[He]*Se[He],L[He]=b[Le]*Se[He]+b[He]*Se[Le]}this._f.transform(ce,L);for(let Le=0;Le<Ee.length;Le+=2){const He=Le+1;de[Le]=ce[Le]*Ee[Le]-ce[He]*Ee[He],de[He]=ce[Le]*Ee[He]+ce[He]*Ee[Le]}this._f.inverseTransform(Pe,de);for(let Le=0;Le<Pe.length;Le+=2){const He=Pe[Le+Be],Me=Pe[Le+Be+1],N=Se[Le],me=Se[Le+1];W[Le]=He*N-Me*me,W[Le+1]=He*me+Me*N}}transform(W,b){this._transform(W,b,!1)}realTransform(W,b){this._transform(W,b,!0)}}class ge{constructor(W){this.fft_length=W,this.isPowerOfTwo=$(W),this.isPowerOfTwo?(this.fft=new ae(W),this.outputBufferSize=2*W):(this.fft=new fe(W),this.outputBufferSize=this.fft.bufferSize)}realTransform(W,b){this.fft.realTransform(W,b)}transform(W,b){this.fft.transform(W,b)}}function le(X,W){if(W%2===0||W<=0)throw new Error("Window size must be a positive odd number");const b=new X.constructor(X.length),z=new X.constructor(W),L=Math.floor(W/2);for(let de=0;de<X.length;++de){let ce=0;for(let Pe=-L;Pe<=L;++Pe){let Ee=de+Pe;Ee<0?Ee=Math.abs(Ee):Ee>=X.length&&(Ee=2*(X.length-1)-Ee),z[ce++]=X[Ee]}z.sort(),b[de]=z[L]}return b}function q(X,W){const b=Math.pow(10,W);return Math.round(X*b)/b}function ie(X){const W=Math.round(X);return Math.abs(X)%1===.5?W%2===0?W:W-1:W}function pe(X){const W=X.length,b=X[0].length,z=[W+1,b+1],L=Array.from({length:z[0]},()=>Array(z[1]).fill(1/0));L[0][0]=0;const de=Array.from({length:z[0]},()=>Array(z[1]).fill(-1));for(let Be=1;Be<z[1];++Be)for(let Le=1;Le<z[0];++Le){const He=L[Le-1][Be-1],Me=L[Le-1][Be],N=L[Le][Be-1];let me,ue;He<Me&&He<N?(me=He,ue=0):Me<He&&Me<N?(me=Me,ue=1):(me=N,ue=2),L[Le][Be]=X[Le-1][Be-1]+me,de[Le][Be]=ue}for(let Be=0;Be<z[1];++Be)de[0][Be]=2;for(let Be=0;Be<z[0];++Be)de[Be][0]=1;let ce=W,Pe=b,Ee=[],Se=[];for(;ce>0||Pe>0;)switch(Ee.push(ce-1),Se.push(Pe-1),de[ce][Pe]){case 0:--ce,--Pe;break;case 1:--ce;break;case 2:--Pe;break;default:throw new Error(`Internal error in dynamic time warping. Unexpected trace[${ce}, ${Pe}]. Please file a bug report.`)}return Ee.reverse(),Se.reverse(),[Ee,Se]}},"./src/utils/tensor.js":(ke,V,f)=>{f.r(V),f.d(V,{Tensor:()=>oe,cat:()=>X,full:()=>ce,full_like:()=>Pe,interpolate:()=>k,interpolate_4d:()=>A,layer_norm:()=>le,matmul:()=>$,mean:()=>z,mean_pooling:()=>ge,ones:()=>Ee,ones_like:()=>Se,permute:()=>C,quantize_embeddings:()=>He,rfft:()=>ae,stack:()=>W,std_mean:()=>b,topk:()=>fe,zeros:()=>Be,zeros_like:()=>Le});var P=f("./src/utils/maths.js"),R=f("./src/backends/onnx.js"),Q=f("./src/ops/registry.js");const se=Object.freeze({float32:Float32Array,float16:Uint16Array,float64:Float64Array,string:Array,int8:Int8Array,uint8:Uint8Array,int16:Int16Array,uint16:Uint16Array,int32:Int32Array,uint32:Uint32Array,int64:BigInt64Array,uint64:BigUint64Array,bool:Uint8Array});class oe{constructor(...N){Fe(this,"ort_tensor");return(0,R.isONNXTensor)(N[0])?this.ort_tensor=N[0]:this.ort_tensor=new R.Tensor(N[0],N[1],N[2]),new Proxy(this,{get:(me,ue)=>{if(typeof ue=="string"){let ee=Number(ue);if(Number.isInteger(ee))return me._getitem(ee)}return me[ue]},set:(me,ue,ee)=>me[ue]=ee})}get dims(){return this.ort_tensor.dims}set dims(N){this.ort_tensor.dims=N}get type(){return this.ort_tensor.type}get data(){return this.ort_tensor.data}get size(){return this.ort_tensor.size}get location(){return this.ort_tensor.location}dispose(){this.ort_tensor.dispose()}*[Symbol.iterator](){const[N,...me]=this.dims;if(me.length>0){const ue=me.reduce((ee,Te)=>ee*Te);for(let ee=0;ee<N;++ee)yield this._subarray(ee,ue,me)}else yield*this.data}_getitem(N){const[me,...ue]=this.dims;if(N=pe(N,me),ue.length>0){const ee=ue.reduce((Te,je)=>Te*je);return this._subarray(N,ee,ue)}else return new oe(this.type,[this.data[N]],ue)}indexOf(N){const me=this.data;for(let ue=0;ue<me.length;++ue)if(me[ue]==N)return ue;return-1}_subarray(N,me,ue){const ee=N*me,Te=(N+1)*me,je="subarray"in this.data?this.data.subarray(ee,Te):this.data.slice(ee,Te);return new oe(this.type,je,ue)}item(){const N=this.data;if(N.length!==1)throw new Error(`a Tensor with ${N.length} elements cannot be converted to Scalar`);return N[0]}tolist(){return E(this.data,this.dims)}sigmoid(){return this.clone().sigmoid_()}sigmoid_(){const N=this.data;for(let me=0;me<N.length;++me)N[me]=1/(1+Math.exp(-N[me]));return this}map(N){return this.clone().map_(N)}map_(N){const me=this.data;for(let ue=0;ue<me.length;++ue)me[ue]=N(me[ue],ue,me);return this}mul(N){return this.clone().mul_(N)}mul_(N){const me=this.data;for(let ue=0;ue<me.length;++ue)me[ue]*=N;return this}div(N){return this.clone().div_(N)}div_(N){const me=this.data;for(let ue=0;ue<me.length;++ue)me[ue]/=N;return this}add(N){return this.clone().add_(N)}add_(N){const me=this.data;for(let ue=0;ue<me.length;++ue)me[ue]+=N;return this}sub(N){return this.clone().sub_(N)}sub_(N){const me=this.data;for(let ue=0;ue<me.length;++ue)me[ue]-=N;return this}clone(){return new oe(this.type,this.data.slice(),this.dims.slice())}slice(...N){const me=[],ue=[];for(let he=0;he<this.dims.length;++he){let Ve=N[he];if(Ve==null)ue.push([0,this.dims[he]]),me.push(this.dims[he]);else if(typeof Ve=="number")Ve=pe(Ve,this.dims[he],he),ue.push([Ve,Ve+1]);else if(Array.isArray(Ve)&&Ve.length===2){let[Je,We]=Ve;if(Je=Je===null?0:pe(Je,this.dims[he],he,!1),We=We===null?this.dims[he]:pe(We,this.dims[he],he,!1),Je>We)throw new Error(`Invalid slice: ${Ve}`);const be=[Math.max(Je,0),Math.min(We,this.dims[he])];ue.push(be),me.push(be[1]-be[0])}else throw new Error(`Invalid slice: ${Ve}`)}const ee=ue.map(([he,Ve])=>Ve-he),Te=ee.reduce((he,Ve)=>he*Ve),je=this.data,qe=new je.constructor(Te),tt=this.stride();for(let he=0;he<Te;++he){let Ve=0;for(let Je=ee.length-1,We=he;Je>=0;--Je){const be=ee[Je];Ve+=(We%be+ue[Je][0])*tt[Je],We=Math.floor(We/be)}qe[he]=je[Ve]}return new oe(this.type,qe,me)}permute(...N){return C(this,N)}transpose(...N){return this.permute(...N)}sum(N=null,me=!1){return this.norm(1,N,me)}norm(N="fro",me=null,ue=!1){if(N==="fro")N=2;else if(typeof N=="string")throw Error(`Unsupported norm: ${N}`);const ee=this.data;if(me===null){let qe=ee.reduce((tt,he)=>tt+he**N,0)**(1/N);return new oe(this.type,[qe],[])}me=pe(me,this.dims.length);const Te=this.dims.slice();Te[me]=1;const je=new ee.constructor(ee.length/this.dims[me]);for(let qe=0;qe<ee.length;++qe){let tt=0;for(let he=this.dims.length-1,Ve=qe,Je=1;he>=0;--he){const We=this.dims[he];if(he!==me){const be=Ve%We;tt+=be*Je,Je*=Te[he]}Ve=Math.floor(Ve/We)}je[tt]+=ee[qe]**N}if(N!==1)for(let qe=0;qe<je.length;++qe)je[qe]=je[qe]**(1/N);return ue||Te.splice(me,1),new oe(this.type,je,Te)}normalize_(N=2,me=1){me=pe(me,this.dims.length);const ue=this.norm(N,me,!0),ee=this.data,Te=ue.data;for(let je=0;je<ee.length;++je){let qe=0;for(let tt=this.dims.length-1,he=je,Ve=1;tt>=0;--tt){const Je=this.dims[tt];if(tt!==me){const We=he%Je;qe+=We*Ve,Ve*=this.dims[tt]}he=Math.floor(he/Je)}ee[je]/=Te[qe]}return this}normalize(N=2,me=1){return this.clone().normalize_(N,me)}stride(){return L(this.dims)}squeeze(N=null){return new oe(this.type,this.data,q(this.dims,N))}squeeze_(N=null){return this.dims=q(this.dims,N),this}unsqueeze(N=null){return new oe(this.type,this.data,ie(this.dims,N))}unsqueeze_(N=null){return this.dims=ie(this.dims,N),this}flatten_(N=0,me=-1){me=(me+this.dims.length)%this.dims.length;let ue=this.dims.slice(0,N),ee=this.dims.slice(N,me+1),Te=this.dims.slice(me+1);return this.dims=[...ue,ee.reduce((je,qe)=>je*qe,1),...Te],this}flatten(N=0,me=-1){return this.clone().flatten_(N,me)}view(...N){let me=-1;for(let ee=0;ee<N.length;++ee)if(N[ee]===-1){if(me!==-1)throw new Error("Only one dimension can be inferred");me=ee}const ue=this.data;if(me!==-1){const ee=N.reduce((Te,je,qe)=>qe!==me?Te*je:Te,1);N[me]=ue.length/ee}return new oe(this.type,ue,N)}neg_(){const N=this.data;for(let me=0;me<N.length;++me)N[me]=-N[me];return this}neg(){return this.clone().neg_()}clamp_(N,me){const ue=this.data;for(let ee=0;ee<ue.length;++ee)ue[ee]=Math.min(Math.max(ue[ee],N),me);return this}clamp(N,me){return this.clone().clamp_(N,me)}round_(){const N=this.data;for(let me=0;me<N.length;++me)N[me]=Math.round(N[me]);return this}round(){return this.clone().round_()}mean(N=null,me=!1){return z(this,N,me)}to(N){if(this.type===N)return this;if(!se.hasOwnProperty(N))throw new Error(`Unsupported type: ${N}`);return new oe(N,se[N].from(this.data),this.dims)}}function E(Me,N){const me=Me.length,ue=N.reduce((Te,je)=>Te*je);if(me!==ue)throw Error(`cannot reshape array of size ${me} into shape (${N})`);let ee=Me;for(let Te=N.length-1;Te>=0;Te--)ee=ee.reduce((je,qe)=>{let tt=je[je.length-1];return tt.length<N[Te]?tt.push(qe):je.push([qe]),je},[[]]);return ee[0]}function C(Me,N){const[me,ue]=(0,P.permute_data)(Me.data,Me.dims,N);return new oe(Me.type,me,ue)}function k(Me,[N,me],ue="bilinear",ee=!1){const Te=Me.dims.at(-3)??1,je=Me.dims.at(-2),qe=Me.dims.at(-1);let tt=(0,P.interpolate_data)(Me.data,[Te,je,qe],[N,me],ue,ee);return new oe(Me.type,tt,[Te,N,me])}async function A(Me,{size:N=null,mode:me="bilinear"}={}){if(Me.dims.length!==4)throw new Error("`interpolate_4d` currently only supports 4D input.");if(!N)throw new Error("`interpolate_4d` requires a `size` argument.");let ue;if(N.length===2)ue=[...Me.dims.slice(0,2),...N];else if(N.length===3)ue=[Me.dims[0],...N];else if(N.length===4)ue=N;else throw new Error("`size` must be of length 2, 3, or 4.");let ee;if(me==="bilinear")ee=await Q.TensorOpRegistry.bilinear_interpolate_4d;else if(me==="bicubic")ee=await Q.TensorOpRegistry.bicubic_interpolate_4d;else throw new Error(`Unsupported mode: ${me}`);const Te=new oe("int64",new BigInt64Array(ue.map(BigInt)),[ue.length]);return await ee({x:Me,s:Te})}async function $(Me,N){return await(await Q.TensorOpRegistry.matmul)({a:Me,b:N})}async function ae(Me,N){return await(await Q.TensorOpRegistry.rfft)({x:Me,a:N})}async function fe(Me,N){const me=await Q.TensorOpRegistry.top_k;return N===null?N=Me.dims.at(-1):N=Math.min(N,Me.dims.at(-1)),await me({x:Me,k:new oe("int64",[BigInt(N)],[1])})}function ge(Me,N){const me=Me.data,ue=N.data,ee=[Me.dims[0],Me.dims[2]],Te=new me.constructor(ee[0]*ee[1]),[je,qe,tt]=Me.dims;let he=0;for(let Ve=0;Ve<je;++Ve){const Je=Ve*tt*qe;for(let We=0;We<tt;++We){let be=0,Re=0;const lt=Ve*qe,ot=Je+We;for(let Xe=0;Xe<qe;++Xe){const pt=Number(ue[lt+Xe]);Re+=pt,be+=me[ot+Xe*tt]*pt}const st=be/Re;Te[he++]=st}}return new oe(Me.type,Te,ee)}function le(Me,N,{eps:me=1e-5}={}){if(Me.dims.length!==2)throw new Error("`layer_norm` currently only supports 2D input.");const[ue,ee]=Me.dims;if(N.length!==1&&N[0]!==ee)throw new Error("`normalized_shape` must be a 1D array with shape `[input.dims[1]]`.");const[Te,je]=b(Me,1,0,!0),qe=Te.data,tt=je.data,he=Me.data,Ve=new he.constructor(he.length);for(let Je=0;Je<ue;++Je){const We=Je*ee;for(let be=0;be<ee;++be){const Re=We+be;Ve[Re]=(he[Re]-tt[Je])/(qe[Je]+me)}}return new oe(Me.type,Ve,Me.dims)}function q(Me,N){return Me=Me.slice(),N===null?Me=Me.filter(me=>me!==1):typeof N=="number"?Me[N]===1&&Me.splice(N,1):Array.isArray(N)&&(Me=Me.filter((me,ue)=>me!==1||!N.includes(ue))),Me}function ie(Me,N){return N=pe(N,Me.length+1),Me=Me.slice(),Me.splice(N,0,1),Me}function pe(Me,N,me=null,ue=!0){if(ue&&(Me<-N||Me>=N))throw new Error(`IndexError: index ${Me} is out of bounds for dimension${me===null?"":" "+me} with size ${N}`);return Me<0&&(Me=(Me%N+N)%N),Me}function X(Me,N=0){N=pe(N,Me[0].dims.length);const me=Me[0].dims.slice();me[N]=Me.reduce((je,qe)=>je+qe.dims[N],0);const ue=me.reduce((je,qe)=>je*qe,1),ee=new Me[0].data.constructor(ue),Te=Me[0].type;if(N===0){let je=0;for(const qe of Me){const tt=qe.data;ee.set(tt,je),je+=tt.length}}else{let je=0;for(let qe=0;qe<Me.length;++qe){const{data:tt,dims:he}=Me[qe];for(let Ve=0;Ve<tt.length;++Ve){let Je=0;for(let We=he.length-1,be=Ve,Re=1;We>=0;--We){const lt=he[We];let ot=be%lt;We===N&&(ot+=je),Je+=ot*Re,Re*=me[We],be=Math.floor(be/lt)}ee[Je]=tt[Ve]}je+=he[N]}}return new oe(Te,ee,me)}function W(Me,N=0){return X(Me.map(me=>me.unsqueeze(N)),N)}function b(Me,N=null,me=1,ue=!1){const ee=Me.data,Te=Me.dims;if(N===null){const We=ee.reduce((ot,st)=>ot+st,0)/ee.length,be=Math.sqrt(ee.reduce((ot,st)=>ot+(st-We)**2,0)/(ee.length-me)),Re=new oe(Me.type,[We],[]);return[new oe(Me.type,[be],[]),Re]}N=pe(N,Te.length);const je=z(Me,N,ue),qe=je.data,tt=Te.slice();tt[N]=1;const he=new ee.constructor(ee.length/Te[N]);for(let Je=0;Je<ee.length;++Je){let We=0;for(let be=Te.length-1,Re=Je,lt=1;be>=0;--be){const ot=Te[be];if(be!==N){const st=Re%ot;We+=st*lt,lt*=tt[be]}Re=Math.floor(Re/ot)}he[We]+=(ee[Je]-qe[We])**2}for(let Je=0;Je<he.length;++Je)he[Je]=Math.sqrt(he[Je]/(Te[N]-me));return ue||tt.splice(N,1),[new oe(Me.type,he,tt),je]}function z(Me,N=null,me=!1){const ue=Me.data;if(N===null){const qe=ue.reduce((tt,he)=>tt+he,0);return new oe(Me.type,[qe/ue.length],[])}const ee=Me.dims;N=pe(N,ee.length);const Te=ee.slice();Te[N]=1;const je=new ue.constructor(ue.length/ee[N]);for(let qe=0;qe<ue.length;++qe){let tt=0;for(let he=ee.length-1,Ve=qe,Je=1;he>=0;--he){const We=ee[he];if(he!==N){const be=Ve%We;tt+=be*Je,Je*=Te[he]}Ve=Math.floor(Ve/We)}je[tt]+=ue[qe]}if(ee[N]!==1)for(let qe=0;qe<je.length;++qe)je[qe]=je[qe]/ee[N];return me||Te.splice(N,1),new oe(Me.type,je,Te)}function L(Me){const N=new Array(Me.length);for(let me=Me.length-1,ue=1;me>=0;--me)N[me]=ue,ue*=Me[me];return N}function de(Me,N,me,ue){const ee=Me.reduce((Te,je)=>Te*je,1);return new oe(me,new ue(ee).fill(N),Me)}function ce(Me,N){let me,ue;if(typeof N=="number")me="float32",ue=Float32Array;else if(typeof N=="bigint")me="int64",ue=BigInt64Array;else throw new Error(`Unsupported data type: ${typeof N}`);return de(Me,N,me,ue)}function Pe(Me,N){return ce(Me.dims,N)}function Ee(Me){return de(Me,1n,"int64",BigInt64Array)}function Se(Me){return Ee(Me.dims)}function Be(Me){return de(Me,0n,"int64",BigInt64Array)}function Le(Me){return Be(Me.dims)}function He(Me,N){if(Me.dims.length!==2)throw new Error("The tensor must have 2 dimensions");if(Me.dims.at(-1)%8!==0)throw new Error("The last dimension of the tensor must be a multiple of 8");if(!["binary","ubinary"].includes(N))throw new Error("The precision must be either 'binary' or 'ubinary'");const me=N==="binary",ue=me?"int8":"uint8",ee=me?Int8Array:Uint8Array,Te=Me.data,je=new ee(Te.length/8);for(let qe=0;qe<Te.length;++qe){const tt=Te[qe]>0?1:0,he=Math.floor(qe/8),Ve=qe%8;je[he]|=tt<<7-Ve,me&&Ve===0&&(je[he]-=128)}return new oe(ue,je,[Me.dims[0],Me.dims[1]/8])}}},_m={};function Lr(ke){var V=_m[ke];if(V!==void 0)return V.exports;var f=_m[ke]={exports:{}};return wm[ke](f,f.exports,Lr),f.exports}Lr.m=wm;(()=>{var ke=Object.getPrototypeOf?f=>Object.getPrototypeOf(f):f=>f.__proto__,V;Lr.t=function(f,P){if(P&1&&(f=this(f)),P&8||typeof f=="object"&&f&&(P&4&&f.__esModule||P&16&&typeof f.then=="function"))return f;var R=Object.create(null);Lr.r(R);var Q={};V=V||[null,ke({}),ke([]),ke(ke)];for(var se=P&2&&f;typeof se=="object"&&!~V.indexOf(se);se=ke(se))Object.getOwnPropertyNames(se).forEach(oe=>Q[oe]=()=>f[oe]);return Q.default=()=>f,Lr.d(R,Q),R}})();Lr.d=(ke,V)=>{for(var f in V)Lr.o(V,f)&&!Lr.o(ke,f)&&Object.defineProperty(ke,f,{enumerable:!0,get:V[f]})};Lr.o=(ke,V)=>Object.prototype.hasOwnProperty.call(ke,V);Lr.r=ke=>{typeof Symbol<"u"&&Symbol.toStringTag&&Object.defineProperty(ke,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(ke,"__esModule",{value:!0})};(()=>{var ke;if(typeof import.meta.url=="string"&&(ke=import.meta.url),!ke)throw new Error("Automatic publicPath is not supported in this browser");ke=ke.replace(/#.*$/,"").replace(/\?.*$/,"").replace(/\/[^\/]+$/,"/"),Lr.p=ke})();Lr.b=new URL("./",import.meta.url);var g={};/*!*****************************!*\
  !*** ./src/transformers.js ***!
  \*****************************/Lr.r(g);Lr.d(g,{ASTFeatureExtractor:()=>wu.ASTFeatureExtractor,ASTForAudioClassification:()=>F.ASTForAudioClassification,ASTModel:()=>F.ASTModel,ASTPreTrainedModel:()=>F.ASTPreTrainedModel,AlbertForMaskedLM:()=>F.AlbertForMaskedLM,AlbertForQuestionAnswering:()=>F.AlbertForQuestionAnswering,AlbertForSequenceClassification:()=>F.AlbertForSequenceClassification,AlbertModel:()=>F.AlbertModel,AlbertPreTrainedModel:()=>F.AlbertPreTrainedModel,AlbertTokenizer:()=>ur.AlbertTokenizer,AudioClassificationPipeline:()=>pn.AudioClassificationPipeline,AutoConfig:()=>Df.AutoConfig,AutoFeatureExtractor:()=>ng.AutoFeatureExtractor,AutoImageProcessor:()=>og.AutoImageProcessor,AutoModel:()=>F.AutoModel,AutoModelForAudioClassification:()=>F.AutoModelForAudioClassification,AutoModelForAudioFrameClassification:()=>F.AutoModelForAudioFrameClassification,AutoModelForCTC:()=>F.AutoModelForCTC,AutoModelForCausalLM:()=>F.AutoModelForCausalLM,AutoModelForDepthEstimation:()=>F.AutoModelForDepthEstimation,AutoModelForDocumentQuestionAnswering:()=>F.AutoModelForDocumentQuestionAnswering,AutoModelForImageClassification:()=>F.AutoModelForImageClassification,AutoModelForImageFeatureExtraction:()=>F.AutoModelForImageFeatureExtraction,AutoModelForImageMatting:()=>F.AutoModelForImageMatting,AutoModelForImageSegmentation:()=>F.AutoModelForImageSegmentation,AutoModelForImageToImage:()=>F.AutoModelForImageToImage,AutoModelForMaskGeneration:()=>F.AutoModelForMaskGeneration,AutoModelForMaskedLM:()=>F.AutoModelForMaskedLM,AutoModelForNormalEstimation:()=>F.AutoModelForNormalEstimation,AutoModelForObjectDetection:()=>F.AutoModelForObjectDetection,AutoModelForPoseEstimation:()=>F.AutoModelForPoseEstimation,AutoModelForQuestionAnswering:()=>F.AutoModelForQuestionAnswering,AutoModelForSemanticSegmentation:()=>F.AutoModelForSemanticSegmentation,AutoModelForSeq2SeqLM:()=>F.AutoModelForSeq2SeqLM,AutoModelForSequenceClassification:()=>F.AutoModelForSequenceClassification,AutoModelForSpeechSeq2Seq:()=>F.AutoModelForSpeechSeq2Seq,AutoModelForTextToSpectrogram:()=>F.AutoModelForTextToSpectrogram,AutoModelForTextToWaveform:()=>F.AutoModelForTextToWaveform,AutoModelForTokenClassification:()=>F.AutoModelForTokenClassification,AutoModelForUniversalSegmentation:()=>F.AutoModelForUniversalSegmentation,AutoModelForVision2Seq:()=>F.AutoModelForVision2Seq,AutoModelForXVector:()=>F.AutoModelForXVector,AutoModelForZeroShotObjectDetection:()=>F.AutoModelForZeroShotObjectDetection,AutoProcessor:()=>ag.AutoProcessor,AutoTokenizer:()=>ur.AutoTokenizer,AutomaticSpeechRecognitionPipeline:()=>pn.AutomaticSpeechRecognitionPipeline,BartForConditionalGeneration:()=>F.BartForConditionalGeneration,BartForSequenceClassification:()=>F.BartForSequenceClassification,BartModel:()=>F.BartModel,BartPretrainedModel:()=>F.BartPretrainedModel,BartTokenizer:()=>ur.BartTokenizer,BaseModelOutput:()=>F.BaseModelOutput,BaseStreamer:()=>zf.BaseStreamer,BeitFeatureExtractor:()=>ir.BeitFeatureExtractor,BeitForImageClassification:()=>F.BeitForImageClassification,BeitModel:()=>F.BeitModel,BeitPreTrainedModel:()=>F.BeitPreTrainedModel,BertForMaskedLM:()=>F.BertForMaskedLM,BertForQuestionAnswering:()=>F.BertForQuestionAnswering,BertForSequenceClassification:()=>F.BertForSequenceClassification,BertForTokenClassification:()=>F.BertForTokenClassification,BertModel:()=>F.BertModel,BertPreTrainedModel:()=>F.BertPreTrainedModel,BertTokenizer:()=>ur.BertTokenizer,BitImageProcessor:()=>ir.BitImageProcessor,BlenderbotForConditionalGeneration:()=>F.BlenderbotForConditionalGeneration,BlenderbotModel:()=>F.BlenderbotModel,BlenderbotPreTrainedModel:()=>F.BlenderbotPreTrainedModel,BlenderbotSmallForConditionalGeneration:()=>F.BlenderbotSmallForConditionalGeneration,BlenderbotSmallModel:()=>F.BlenderbotSmallModel,BlenderbotSmallPreTrainedModel:()=>F.BlenderbotSmallPreTrainedModel,BlenderbotSmallTokenizer:()=>ur.BlenderbotSmallTokenizer,BlenderbotTokenizer:()=>ur.BlenderbotTokenizer,BloomForCausalLM:()=>F.BloomForCausalLM,BloomModel:()=>F.BloomModel,BloomPreTrainedModel:()=>F.BloomPreTrainedModel,BloomTokenizer:()=>ur.BloomTokenizer,CLIPFeatureExtractor:()=>ir.CLIPFeatureExtractor,CLIPImageProcessor:()=>ir.CLIPImageProcessor,CLIPModel:()=>F.CLIPModel,CLIPPreTrainedModel:()=>F.CLIPPreTrainedModel,CLIPSegForImageSegmentation:()=>F.CLIPSegForImageSegmentation,CLIPSegModel:()=>F.CLIPSegModel,CLIPSegPreTrainedModel:()=>F.CLIPSegPreTrainedModel,CLIPTextModel:()=>F.CLIPTextModel,CLIPTextModelWithProjection:()=>F.CLIPTextModelWithProjection,CLIPTokenizer:()=>ur.CLIPTokenizer,CLIPVisionModel:()=>F.CLIPVisionModel,CLIPVisionModelWithProjection:()=>F.CLIPVisionModelWithProjection,CamembertForMaskedLM:()=>F.CamembertForMaskedLM,CamembertForQuestionAnswering:()=>F.CamembertForQuestionAnswering,CamembertForSequenceClassification:()=>F.CamembertForSequenceClassification,CamembertForTokenClassification:()=>F.CamembertForTokenClassification,CamembertModel:()=>F.CamembertModel,CamembertPreTrainedModel:()=>F.CamembertPreTrainedModel,CamembertTokenizer:()=>ur.CamembertTokenizer,CausalLMOutput:()=>F.CausalLMOutput,CausalLMOutputWithPast:()=>F.CausalLMOutputWithPast,ChineseCLIPFeatureExtractor:()=>ir.ChineseCLIPFeatureExtractor,ChineseCLIPModel:()=>F.ChineseCLIPModel,ChineseCLIPPreTrainedModel:()=>F.ChineseCLIPPreTrainedModel,ClapAudioModelWithProjection:()=>F.ClapAudioModelWithProjection,ClapFeatureExtractor:()=>wu.ClapFeatureExtractor,ClapModel:()=>F.ClapModel,ClapPreTrainedModel:()=>F.ClapPreTrainedModel,ClapTextModelWithProjection:()=>F.ClapTextModelWithProjection,ClassifierFreeGuidanceLogitsProcessor:()=>js.ClassifierFreeGuidanceLogitsProcessor,CodeGenForCausalLM:()=>F.CodeGenForCausalLM,CodeGenModel:()=>F.CodeGenModel,CodeGenPreTrainedModel:()=>F.CodeGenPreTrainedModel,CodeGenTokenizer:()=>ur.CodeGenTokenizer,CodeLlamaTokenizer:()=>ur.CodeLlamaTokenizer,CohereForCausalLM:()=>F.CohereForCausalLM,CohereModel:()=>F.CohereModel,CoherePreTrainedModel:()=>F.CoherePreTrainedModel,CohereTokenizer:()=>ur.CohereTokenizer,ConvBertForMaskedLM:()=>F.ConvBertForMaskedLM,ConvBertForQuestionAnswering:()=>F.ConvBertForQuestionAnswering,ConvBertForSequenceClassification:()=>F.ConvBertForSequenceClassification,ConvBertForTokenClassification:()=>F.ConvBertForTokenClassification,ConvBertModel:()=>F.ConvBertModel,ConvBertPreTrainedModel:()=>F.ConvBertPreTrainedModel,ConvBertTokenizer:()=>ur.ConvBertTokenizer,ConvNextFeatureExtractor:()=>ir.ConvNextFeatureExtractor,ConvNextForImageClassification:()=>F.ConvNextForImageClassification,ConvNextImageProcessor:()=>ir.ConvNextImageProcessor,ConvNextModel:()=>F.ConvNextModel,ConvNextPreTrainedModel:()=>F.ConvNextPreTrainedModel,ConvNextV2ForImageClassification:()=>F.ConvNextV2ForImageClassification,ConvNextV2Model:()=>F.ConvNextV2Model,ConvNextV2PreTrainedModel:()=>F.ConvNextV2PreTrainedModel,DPTFeatureExtractor:()=>ir.DPTFeatureExtractor,DPTForDepthEstimation:()=>F.DPTForDepthEstimation,DPTImageProcessor:()=>ir.DPTImageProcessor,DPTModel:()=>F.DPTModel,DPTPreTrainedModel:()=>F.DPTPreTrainedModel,DebertaForMaskedLM:()=>F.DebertaForMaskedLM,DebertaForQuestionAnswering:()=>F.DebertaForQuestionAnswering,DebertaForSequenceClassification:()=>F.DebertaForSequenceClassification,DebertaForTokenClassification:()=>F.DebertaForTokenClassification,DebertaModel:()=>F.DebertaModel,DebertaPreTrainedModel:()=>F.DebertaPreTrainedModel,DebertaTokenizer:()=>ur.DebertaTokenizer,DebertaV2ForMaskedLM:()=>F.DebertaV2ForMaskedLM,DebertaV2ForQuestionAnswering:()=>F.DebertaV2ForQuestionAnswering,DebertaV2ForSequenceClassification:()=>F.DebertaV2ForSequenceClassification,DebertaV2ForTokenClassification:()=>F.DebertaV2ForTokenClassification,DebertaV2Model:()=>F.DebertaV2Model,DebertaV2PreTrainedModel:()=>F.DebertaV2PreTrainedModel,DebertaV2Tokenizer:()=>ur.DebertaV2Tokenizer,DecisionTransformerModel:()=>F.DecisionTransformerModel,DecisionTransformerPreTrainedModel:()=>F.DecisionTransformerPreTrainedModel,DeiTFeatureExtractor:()=>ir.DeiTFeatureExtractor,DeiTForImageClassification:()=>F.DeiTForImageClassification,DeiTImageProcessor:()=>ir.DeiTImageProcessor,DeiTModel:()=>F.DeiTModel,DeiTPreTrainedModel:()=>F.DeiTPreTrainedModel,DepthAnythingForDepthEstimation:()=>F.DepthAnythingForDepthEstimation,DepthAnythingPreTrainedModel:()=>F.DepthAnythingPreTrainedModel,DepthEstimationPipeline:()=>pn.DepthEstimationPipeline,DepthProForDepthEstimation:()=>F.DepthProForDepthEstimation,DepthProPreTrainedModel:()=>F.DepthProPreTrainedModel,DetrFeatureExtractor:()=>ir.DetrFeatureExtractor,DetrForObjectDetection:()=>F.DetrForObjectDetection,DetrForSegmentation:()=>F.DetrForSegmentation,DetrImageProcessor:()=>ir.DetrImageProcessor,DetrModel:()=>F.DetrModel,DetrObjectDetectionOutput:()=>F.DetrObjectDetectionOutput,DetrPreTrainedModel:()=>F.DetrPreTrainedModel,DetrSegmentationOutput:()=>F.DetrSegmentationOutput,Dinov2ForImageClassification:()=>F.Dinov2ForImageClassification,Dinov2Model:()=>F.Dinov2Model,Dinov2PreTrainedModel:()=>F.Dinov2PreTrainedModel,DistilBertForMaskedLM:()=>F.DistilBertForMaskedLM,DistilBertForQuestionAnswering:()=>F.DistilBertForQuestionAnswering,DistilBertForSequenceClassification:()=>F.DistilBertForSequenceClassification,DistilBertForTokenClassification:()=>F.DistilBertForTokenClassification,DistilBertModel:()=>F.DistilBertModel,DistilBertPreTrainedModel:()=>F.DistilBertPreTrainedModel,DistilBertTokenizer:()=>ur.DistilBertTokenizer,DocumentQuestionAnsweringPipeline:()=>pn.DocumentQuestionAnsweringPipeline,DonutFeatureExtractor:()=>ir.DonutFeatureExtractor,DonutImageProcessor:()=>ir.DonutImageProcessor,DonutSwinModel:()=>F.DonutSwinModel,DonutSwinPreTrainedModel:()=>F.DonutSwinPreTrainedModel,EfficientNetForImageClassification:()=>F.EfficientNetForImageClassification,EfficientNetImageProcessor:()=>ir.EfficientNetImageProcessor,EfficientNetModel:()=>F.EfficientNetModel,EfficientNetPreTrainedModel:()=>F.EfficientNetPreTrainedModel,ElectraForMaskedLM:()=>F.ElectraForMaskedLM,ElectraForQuestionAnswering:()=>F.ElectraForQuestionAnswering,ElectraForSequenceClassification:()=>F.ElectraForSequenceClassification,ElectraForTokenClassification:()=>F.ElectraForTokenClassification,ElectraModel:()=>F.ElectraModel,ElectraPreTrainedModel:()=>F.ElectraPreTrainedModel,ElectraTokenizer:()=>ur.ElectraTokenizer,EosTokenCriteria:()=>zp.EosTokenCriteria,EsmForMaskedLM:()=>F.EsmForMaskedLM,EsmForSequenceClassification:()=>F.EsmForSequenceClassification,EsmForTokenClassification:()=>F.EsmForTokenClassification,EsmModel:()=>F.EsmModel,EsmPreTrainedModel:()=>F.EsmPreTrainedModel,EsmTokenizer:()=>ur.EsmTokenizer,FFT:()=>$o.FFT,FalconForCausalLM:()=>F.FalconForCausalLM,FalconModel:()=>F.FalconModel,FalconPreTrainedModel:()=>F.FalconPreTrainedModel,FalconTokenizer:()=>ur.FalconTokenizer,FastViTForImageClassification:()=>F.FastViTForImageClassification,FastViTModel:()=>F.FastViTModel,FastViTPreTrainedModel:()=>F.FastViTPreTrainedModel,FeatureExtractionPipeline:()=>pn.FeatureExtractionPipeline,FeatureExtractor:()=>rg.FeatureExtractor,FillMaskPipeline:()=>pn.FillMaskPipeline,Florence2ForConditionalGeneration:()=>F.Florence2ForConditionalGeneration,Florence2PreTrainedModel:()=>F.Florence2PreTrainedModel,Florence2Processor:()=>pa.Florence2Processor,ForcedBOSTokenLogitsProcessor:()=>js.ForcedBOSTokenLogitsProcessor,ForcedEOSTokenLogitsProcessor:()=>js.ForcedEOSTokenLogitsProcessor,GLPNFeatureExtractor:()=>ir.GLPNFeatureExtractor,GLPNForDepthEstimation:()=>F.GLPNForDepthEstimation,GLPNModel:()=>F.GLPNModel,GLPNPreTrainedModel:()=>F.GLPNPreTrainedModel,GPT2LMHeadModel:()=>F.GPT2LMHeadModel,GPT2Model:()=>F.GPT2Model,GPT2PreTrainedModel:()=>F.GPT2PreTrainedModel,GPT2Tokenizer:()=>ur.GPT2Tokenizer,GPTBigCodeForCausalLM:()=>F.GPTBigCodeForCausalLM,GPTBigCodeModel:()=>F.GPTBigCodeModel,GPTBigCodePreTrainedModel:()=>F.GPTBigCodePreTrainedModel,GPTJForCausalLM:()=>F.GPTJForCausalLM,GPTJModel:()=>F.GPTJModel,GPTJPreTrainedModel:()=>F.GPTJPreTrainedModel,GPTNeoForCausalLM:()=>F.GPTNeoForCausalLM,GPTNeoModel:()=>F.GPTNeoModel,GPTNeoPreTrainedModel:()=>F.GPTNeoPreTrainedModel,GPTNeoXForCausalLM:()=>F.GPTNeoXForCausalLM,GPTNeoXModel:()=>F.GPTNeoXModel,GPTNeoXPreTrainedModel:()=>F.GPTNeoXPreTrainedModel,GPTNeoXTokenizer:()=>ur.GPTNeoXTokenizer,Gemma2ForCausalLM:()=>F.Gemma2ForCausalLM,Gemma2Model:()=>F.Gemma2Model,Gemma2PreTrainedModel:()=>F.Gemma2PreTrainedModel,GemmaForCausalLM:()=>F.GemmaForCausalLM,GemmaModel:()=>F.GemmaModel,GemmaPreTrainedModel:()=>F.GemmaPreTrainedModel,GemmaTokenizer:()=>ur.GemmaTokenizer,GraniteForCausalLM:()=>F.GraniteForCausalLM,GraniteModel:()=>F.GraniteModel,GranitePreTrainedModel:()=>F.GranitePreTrainedModel,Grok1Tokenizer:()=>ur.Grok1Tokenizer,GroupViTModel:()=>F.GroupViTModel,GroupViTPreTrainedModel:()=>F.GroupViTPreTrainedModel,HerbertTokenizer:()=>ur.HerbertTokenizer,HieraForImageClassification:()=>F.HieraForImageClassification,HieraModel:()=>F.HieraModel,HieraPreTrainedModel:()=>F.HieraPreTrainedModel,HubertForCTC:()=>F.HubertForCTC,HubertForSequenceClassification:()=>F.HubertForSequenceClassification,HubertModel:()=>F.HubertModel,HubertPreTrainedModel:()=>F.HubertPreTrainedModel,ImageClassificationPipeline:()=>pn.ImageClassificationPipeline,ImageFeatureExtractionPipeline:()=>pn.ImageFeatureExtractionPipeline,ImageFeatureExtractor:()=>wu.ImageFeatureExtractor,ImageMattingOutput:()=>F.ImageMattingOutput,ImageProcessor:()=>sg.ImageProcessor,ImageSegmentationPipeline:()=>pn.ImageSegmentationPipeline,ImageToImagePipeline:()=>pn.ImageToImagePipeline,ImageToTextPipeline:()=>pn.ImageToTextPipeline,InterruptableStoppingCriteria:()=>zp.InterruptableStoppingCriteria,JAISLMHeadModel:()=>F.JAISLMHeadModel,JAISModel:()=>F.JAISModel,JAISPreTrainedModel:()=>F.JAISPreTrainedModel,JinaCLIPImageProcessor:()=>ir.JinaCLIPImageProcessor,JinaCLIPModel:()=>F.JinaCLIPModel,JinaCLIPPreTrainedModel:()=>F.JinaCLIPPreTrainedModel,JinaCLIPProcessor:()=>pa.JinaCLIPProcessor,JinaCLIPTextModel:()=>F.JinaCLIPTextModel,JinaCLIPVisionModel:()=>F.JinaCLIPVisionModel,LlamaForCausalLM:()=>F.LlamaForCausalLM,LlamaModel:()=>F.LlamaModel,LlamaPreTrainedModel:()=>F.LlamaPreTrainedModel,LlamaTokenizer:()=>ur.LlamaTokenizer,LlavaForConditionalGeneration:()=>F.LlavaForConditionalGeneration,LlavaOnevisionForConditionalGeneration:()=>F.LlavaOnevisionForConditionalGeneration,LlavaOnevisionImageProcessor:()=>ir.LlavaOnevisionImageProcessor,LlavaPreTrainedModel:()=>F.LlavaPreTrainedModel,LogitsProcessor:()=>js.LogitsProcessor,LogitsProcessorList:()=>js.LogitsProcessorList,LogitsWarper:()=>js.LogitsWarper,LongT5ForConditionalGeneration:()=>F.LongT5ForConditionalGeneration,LongT5Model:()=>F.LongT5Model,LongT5PreTrainedModel:()=>F.LongT5PreTrainedModel,M2M100ForConditionalGeneration:()=>F.M2M100ForConditionalGeneration,M2M100Model:()=>F.M2M100Model,M2M100PreTrainedModel:()=>F.M2M100PreTrainedModel,M2M100Tokenizer:()=>ur.M2M100Tokenizer,MBart50Tokenizer:()=>ur.MBart50Tokenizer,MBartForCausalLM:()=>F.MBartForCausalLM,MBartForConditionalGeneration:()=>F.MBartForConditionalGeneration,MBartForSequenceClassification:()=>F.MBartForSequenceClassification,MBartModel:()=>F.MBartModel,MBartPreTrainedModel:()=>F.MBartPreTrainedModel,MBartTokenizer:()=>ur.MBartTokenizer,MPNetForMaskedLM:()=>F.MPNetForMaskedLM,MPNetForQuestionAnswering:()=>F.MPNetForQuestionAnswering,MPNetForSequenceClassification:()=>F.MPNetForSequenceClassification,MPNetForTokenClassification:()=>F.MPNetForTokenClassification,MPNetModel:()=>F.MPNetModel,MPNetPreTrainedModel:()=>F.MPNetPreTrainedModel,MPNetTokenizer:()=>ur.MPNetTokenizer,MT5ForConditionalGeneration:()=>F.MT5ForConditionalGeneration,MT5Model:()=>F.MT5Model,MT5PreTrainedModel:()=>F.MT5PreTrainedModel,MarianMTModel:()=>F.MarianMTModel,MarianModel:()=>F.MarianModel,MarianPreTrainedModel:()=>F.MarianPreTrainedModel,MarianTokenizer:()=>ur.MarianTokenizer,Mask2FormerImageProcessor:()=>ir.Mask2FormerImageProcessor,MaskFormerFeatureExtractor:()=>ir.MaskFormerFeatureExtractor,MaskFormerForInstanceSegmentation:()=>F.MaskFormerForInstanceSegmentation,MaskFormerImageProcessor:()=>ir.MaskFormerImageProcessor,MaskFormerModel:()=>F.MaskFormerModel,MaskFormerPreTrainedModel:()=>F.MaskFormerPreTrainedModel,MaskedLMOutput:()=>F.MaskedLMOutput,MaxLengthCriteria:()=>zp.MaxLengthCriteria,MgpstrForSceneTextRecognition:()=>F.MgpstrForSceneTextRecognition,MgpstrModelOutput:()=>F.MgpstrModelOutput,MgpstrPreTrainedModel:()=>F.MgpstrPreTrainedModel,MgpstrProcessor:()=>pa.MgpstrProcessor,MgpstrTokenizer:()=>ur.MgpstrTokenizer,MinLengthLogitsProcessor:()=>js.MinLengthLogitsProcessor,MinNewTokensLengthLogitsProcessor:()=>js.MinNewTokensLengthLogitsProcessor,MistralForCausalLM:()=>F.MistralForCausalLM,MistralModel:()=>F.MistralModel,MistralPreTrainedModel:()=>F.MistralPreTrainedModel,MobileBertForMaskedLM:()=>F.MobileBertForMaskedLM,MobileBertForQuestionAnswering:()=>F.MobileBertForQuestionAnswering,MobileBertForSequenceClassification:()=>F.MobileBertForSequenceClassification,MobileBertModel:()=>F.MobileBertModel,MobileBertPreTrainedModel:()=>F.MobileBertPreTrainedModel,MobileBertTokenizer:()=>ur.MobileBertTokenizer,MobileLLMForCausalLM:()=>F.MobileLLMForCausalLM,MobileLLMModel:()=>F.MobileLLMModel,MobileLLMPreTrainedModel:()=>F.MobileLLMPreTrainedModel,MobileNetV1FeatureExtractor:()=>ir.MobileNetV1FeatureExtractor,MobileNetV1ForImageClassification:()=>F.MobileNetV1ForImageClassification,MobileNetV1ImageProcessor:()=>ir.MobileNetV1ImageProcessor,MobileNetV1Model:()=>F.MobileNetV1Model,MobileNetV1PreTrainedModel:()=>F.MobileNetV1PreTrainedModel,MobileNetV2FeatureExtractor:()=>ir.MobileNetV2FeatureExtractor,MobileNetV2ForImageClassification:()=>F.MobileNetV2ForImageClassification,MobileNetV2ImageProcessor:()=>ir.MobileNetV2ImageProcessor,MobileNetV2Model:()=>F.MobileNetV2Model,MobileNetV2PreTrainedModel:()=>F.MobileNetV2PreTrainedModel,MobileNetV3FeatureExtractor:()=>ir.MobileNetV3FeatureExtractor,MobileNetV3ForImageClassification:()=>F.MobileNetV3ForImageClassification,MobileNetV3ImageProcessor:()=>ir.MobileNetV3ImageProcessor,MobileNetV3Model:()=>F.MobileNetV3Model,MobileNetV3PreTrainedModel:()=>F.MobileNetV3PreTrainedModel,MobileNetV4FeatureExtractor:()=>ir.MobileNetV4FeatureExtractor,MobileNetV4ForImageClassification:()=>F.MobileNetV4ForImageClassification,MobileNetV4ImageProcessor:()=>ir.MobileNetV4ImageProcessor,MobileNetV4Model:()=>F.MobileNetV4Model,MobileNetV4PreTrainedModel:()=>F.MobileNetV4PreTrainedModel,MobileViTFeatureExtractor:()=>ir.MobileViTFeatureExtractor,MobileViTForImageClassification:()=>F.MobileViTForImageClassification,MobileViTImageProcessor:()=>ir.MobileViTImageProcessor,MobileViTModel:()=>F.MobileViTModel,MobileViTPreTrainedModel:()=>F.MobileViTPreTrainedModel,MobileViTV2ForImageClassification:()=>F.MobileViTV2ForImageClassification,MobileViTV2Model:()=>F.MobileViTV2Model,MobileViTV2PreTrainedModel:()=>F.MobileViTV2PreTrainedModel,ModelOutput:()=>F.ModelOutput,Moondream1ForConditionalGeneration:()=>F.Moondream1ForConditionalGeneration,MptForCausalLM:()=>F.MptForCausalLM,MptModel:()=>F.MptModel,MptPreTrainedModel:()=>F.MptPreTrainedModel,MultiModalityCausalLM:()=>F.MultiModalityCausalLM,MultiModalityPreTrainedModel:()=>F.MultiModalityPreTrainedModel,MusicgenForCausalLM:()=>F.MusicgenForCausalLM,MusicgenForConditionalGeneration:()=>F.MusicgenForConditionalGeneration,MusicgenModel:()=>F.MusicgenModel,MusicgenPreTrainedModel:()=>F.MusicgenPreTrainedModel,NllbTokenizer:()=>ur.NllbTokenizer,NoBadWordsLogitsProcessor:()=>js.NoBadWordsLogitsProcessor,NoRepeatNGramLogitsProcessor:()=>js.NoRepeatNGramLogitsProcessor,NomicBertModel:()=>F.NomicBertModel,NomicBertPreTrainedModel:()=>F.NomicBertPreTrainedModel,NougatImageProcessor:()=>ir.NougatImageProcessor,NougatTokenizer:()=>ur.NougatTokenizer,OPTForCausalLM:()=>F.OPTForCausalLM,OPTModel:()=>F.OPTModel,OPTPreTrainedModel:()=>F.OPTPreTrainedModel,ObjectDetectionPipeline:()=>pn.ObjectDetectionPipeline,OlmoForCausalLM:()=>F.OlmoForCausalLM,OlmoModel:()=>F.OlmoModel,OlmoPreTrainedModel:()=>F.OlmoPreTrainedModel,OpenELMForCausalLM:()=>F.OpenELMForCausalLM,OpenELMModel:()=>F.OpenELMModel,OpenELMPreTrainedModel:()=>F.OpenELMPreTrainedModel,OwlViTFeatureExtractor:()=>ir.OwlViTFeatureExtractor,OwlViTForObjectDetection:()=>F.OwlViTForObjectDetection,OwlViTImageProcessor:()=>ir.OwlViTImageProcessor,OwlViTModel:()=>F.OwlViTModel,OwlViTPreTrainedModel:()=>F.OwlViTPreTrainedModel,OwlViTProcessor:()=>pa.OwlViTProcessor,Owlv2ForObjectDetection:()=>F.Owlv2ForObjectDetection,Owlv2ImageProcessor:()=>ir.Owlv2ImageProcessor,Owlv2Model:()=>F.Owlv2Model,Owlv2PreTrainedModel:()=>F.Owlv2PreTrainedModel,PatchTSMixerForPrediction:()=>F.PatchTSMixerForPrediction,PatchTSMixerModel:()=>F.PatchTSMixerModel,PatchTSMixerPreTrainedModel:()=>F.PatchTSMixerPreTrainedModel,PatchTSTForPrediction:()=>F.PatchTSTForPrediction,PatchTSTModel:()=>F.PatchTSTModel,PatchTSTPreTrainedModel:()=>F.PatchTSTPreTrainedModel,Phi3ForCausalLM:()=>F.Phi3ForCausalLM,Phi3Model:()=>F.Phi3Model,Phi3PreTrainedModel:()=>F.Phi3PreTrainedModel,PhiForCausalLM:()=>F.PhiForCausalLM,PhiModel:()=>F.PhiModel,PhiPreTrainedModel:()=>F.PhiPreTrainedModel,Pipeline:()=>pn.Pipeline,PreTrainedModel:()=>F.PreTrainedModel,PreTrainedTokenizer:()=>ur.PreTrainedTokenizer,PretrainedConfig:()=>Df.PretrainedConfig,PretrainedMixin:()=>F.PretrainedMixin,Processor:()=>ig.Processor,PvtForImageClassification:()=>F.PvtForImageClassification,PvtImageProcessor:()=>ir.PvtImageProcessor,PvtModel:()=>F.PvtModel,PvtPreTrainedModel:()=>F.PvtPreTrainedModel,PyAnnoteFeatureExtractor:()=>wu.PyAnnoteFeatureExtractor,PyAnnoteForAudioFrameClassification:()=>F.PyAnnoteForAudioFrameClassification,PyAnnoteModel:()=>F.PyAnnoteModel,PyAnnotePreTrainedModel:()=>F.PyAnnotePreTrainedModel,PyAnnoteProcessor:()=>pa.PyAnnoteProcessor,QuestionAnsweringModelOutput:()=>F.QuestionAnsweringModelOutput,QuestionAnsweringPipeline:()=>pn.QuestionAnsweringPipeline,Qwen2ForCausalLM:()=>F.Qwen2ForCausalLM,Qwen2Model:()=>F.Qwen2Model,Qwen2PreTrainedModel:()=>F.Qwen2PreTrainedModel,Qwen2Tokenizer:()=>ur.Qwen2Tokenizer,Qwen2VLForConditionalGeneration:()=>F.Qwen2VLForConditionalGeneration,Qwen2VLImageProcessor:()=>ir.Qwen2VLImageProcessor,Qwen2VLPreTrainedModel:()=>F.Qwen2VLPreTrainedModel,Qwen2VLProcessor:()=>pa.Qwen2VLProcessor,RTDetrForObjectDetection:()=>F.RTDetrForObjectDetection,RTDetrImageProcessor:()=>ir.RTDetrImageProcessor,RTDetrModel:()=>F.RTDetrModel,RTDetrObjectDetectionOutput:()=>F.RTDetrObjectDetectionOutput,RTDetrPreTrainedModel:()=>F.RTDetrPreTrainedModel,RawImage:()=>tg.RawImage,RepetitionPenaltyLogitsProcessor:()=>js.RepetitionPenaltyLogitsProcessor,ResNetForImageClassification:()=>F.ResNetForImageClassification,ResNetModel:()=>F.ResNetModel,ResNetPreTrainedModel:()=>F.ResNetPreTrainedModel,RoFormerForMaskedLM:()=>F.RoFormerForMaskedLM,RoFormerForQuestionAnswering:()=>F.RoFormerForQuestionAnswering,RoFormerForSequenceClassification:()=>F.RoFormerForSequenceClassification,RoFormerForTokenClassification:()=>F.RoFormerForTokenClassification,RoFormerModel:()=>F.RoFormerModel,RoFormerPreTrainedModel:()=>F.RoFormerPreTrainedModel,RoFormerTokenizer:()=>ur.RoFormerTokenizer,RobertaForMaskedLM:()=>F.RobertaForMaskedLM,RobertaForQuestionAnswering:()=>F.RobertaForQuestionAnswering,RobertaForSequenceClassification:()=>F.RobertaForSequenceClassification,RobertaForTokenClassification:()=>F.RobertaForTokenClassification,RobertaModel:()=>F.RobertaModel,RobertaPreTrainedModel:()=>F.RobertaPreTrainedModel,RobertaTokenizer:()=>ur.RobertaTokenizer,SamImageProcessor:()=>ir.SamImageProcessor,SamImageSegmentationOutput:()=>F.SamImageSegmentationOutput,SamModel:()=>F.SamModel,SamPreTrainedModel:()=>F.SamPreTrainedModel,SamProcessor:()=>pa.SamProcessor,SapiensForDepthEstimation:()=>F.SapiensForDepthEstimation,SapiensForNormalEstimation:()=>F.SapiensForNormalEstimation,SapiensForSemanticSegmentation:()=>F.SapiensForSemanticSegmentation,SapiensPreTrainedModel:()=>F.SapiensPreTrainedModel,SeamlessM4TFeatureExtractor:()=>wu.SeamlessM4TFeatureExtractor,SegformerFeatureExtractor:()=>ir.SegformerFeatureExtractor,SegformerForImageClassification:()=>F.SegformerForImageClassification,SegformerForSemanticSegmentation:()=>F.SegformerForSemanticSegmentation,SegformerImageProcessor:()=>ir.SegformerImageProcessor,SegformerModel:()=>F.SegformerModel,SegformerPreTrainedModel:()=>F.SegformerPreTrainedModel,Seq2SeqLMOutput:()=>F.Seq2SeqLMOutput,SequenceClassifierOutput:()=>F.SequenceClassifierOutput,SiglipImageProcessor:()=>ir.SiglipImageProcessor,SiglipModel:()=>F.SiglipModel,SiglipPreTrainedModel:()=>F.SiglipPreTrainedModel,SiglipTextModel:()=>F.SiglipTextModel,SiglipTokenizer:()=>ur.SiglipTokenizer,SiglipVisionModel:()=>F.SiglipVisionModel,SpeechT5FeatureExtractor:()=>wu.SpeechT5FeatureExtractor,SpeechT5ForSpeechToText:()=>F.SpeechT5ForSpeechToText,SpeechT5ForTextToSpeech:()=>F.SpeechT5ForTextToSpeech,SpeechT5HifiGan:()=>F.SpeechT5HifiGan,SpeechT5Model:()=>F.SpeechT5Model,SpeechT5PreTrainedModel:()=>F.SpeechT5PreTrainedModel,SpeechT5Processor:()=>pa.SpeechT5Processor,SpeechT5Tokenizer:()=>ur.SpeechT5Tokenizer,SqueezeBertForMaskedLM:()=>F.SqueezeBertForMaskedLM,SqueezeBertForQuestionAnswering:()=>F.SqueezeBertForQuestionAnswering,SqueezeBertForSequenceClassification:()=>F.SqueezeBertForSequenceClassification,SqueezeBertModel:()=>F.SqueezeBertModel,SqueezeBertPreTrainedModel:()=>F.SqueezeBertPreTrainedModel,SqueezeBertTokenizer:()=>ur.SqueezeBertTokenizer,StableLmForCausalLM:()=>F.StableLmForCausalLM,StableLmModel:()=>F.StableLmModel,StableLmPreTrainedModel:()=>F.StableLmPreTrainedModel,Starcoder2ForCausalLM:()=>F.Starcoder2ForCausalLM,Starcoder2Model:()=>F.Starcoder2Model,Starcoder2PreTrainedModel:()=>F.Starcoder2PreTrainedModel,StoppingCriteria:()=>zp.StoppingCriteria,StoppingCriteriaList:()=>zp.StoppingCriteriaList,SummarizationPipeline:()=>pn.SummarizationPipeline,SuppressTokensAtBeginLogitsProcessor:()=>js.SuppressTokensAtBeginLogitsProcessor,Swin2SRForImageSuperResolution:()=>F.Swin2SRForImageSuperResolution,Swin2SRImageProcessor:()=>ir.Swin2SRImageProcessor,Swin2SRModel:()=>F.Swin2SRModel,Swin2SRPreTrainedModel:()=>F.Swin2SRPreTrainedModel,SwinForImageClassification:()=>F.SwinForImageClassification,SwinModel:()=>F.SwinModel,SwinPreTrainedModel:()=>F.SwinPreTrainedModel,T5ForConditionalGeneration:()=>F.T5ForConditionalGeneration,T5Model:()=>F.T5Model,T5PreTrainedModel:()=>F.T5PreTrainedModel,T5Tokenizer:()=>ur.T5Tokenizer,TableTransformerForObjectDetection:()=>F.TableTransformerForObjectDetection,TableTransformerModel:()=>F.TableTransformerModel,TableTransformerObjectDetectionOutput:()=>F.TableTransformerObjectDetectionOutput,TableTransformerPreTrainedModel:()=>F.TableTransformerPreTrainedModel,TemperatureLogitsWarper:()=>js.TemperatureLogitsWarper,Tensor:()=>qn.Tensor,Text2TextGenerationPipeline:()=>pn.Text2TextGenerationPipeline,TextClassificationPipeline:()=>pn.TextClassificationPipeline,TextGenerationPipeline:()=>pn.TextGenerationPipeline,TextStreamer:()=>zf.TextStreamer,TextToAudioPipeline:()=>pn.TextToAudioPipeline,TokenClassificationPipeline:()=>pn.TokenClassificationPipeline,TokenClassifierOutput:()=>F.TokenClassifierOutput,TokenizerModel:()=>ur.TokenizerModel,TopKLogitsWarper:()=>js.TopKLogitsWarper,TopPLogitsWarper:()=>js.TopPLogitsWarper,TrOCRForCausalLM:()=>F.TrOCRForCausalLM,TrOCRPreTrainedModel:()=>F.TrOCRPreTrainedModel,TranslationPipeline:()=>pn.TranslationPipeline,UniSpeechForCTC:()=>F.UniSpeechForCTC,UniSpeechForSequenceClassification:()=>F.UniSpeechForSequenceClassification,UniSpeechModel:()=>F.UniSpeechModel,UniSpeechPreTrainedModel:()=>F.UniSpeechPreTrainedModel,UniSpeechSatForAudioFrameClassification:()=>F.UniSpeechSatForAudioFrameClassification,UniSpeechSatForCTC:()=>F.UniSpeechSatForCTC,UniSpeechSatForSequenceClassification:()=>F.UniSpeechSatForSequenceClassification,UniSpeechSatModel:()=>F.UniSpeechSatModel,UniSpeechSatPreTrainedModel:()=>F.UniSpeechSatPreTrainedModel,VLChatProcessor:()=>pa.VLChatProcessor,VLMImageProcessor:()=>ir.VLMImageProcessor,ViTFeatureExtractor:()=>ir.ViTFeatureExtractor,ViTForImageClassification:()=>F.ViTForImageClassification,ViTImageProcessor:()=>ir.ViTImageProcessor,ViTMAEModel:()=>F.ViTMAEModel,ViTMAEPreTrainedModel:()=>F.ViTMAEPreTrainedModel,ViTMSNForImageClassification:()=>F.ViTMSNForImageClassification,ViTMSNModel:()=>F.ViTMSNModel,ViTMSNPreTrainedModel:()=>F.ViTMSNPreTrainedModel,ViTModel:()=>F.ViTModel,ViTPreTrainedModel:()=>F.ViTPreTrainedModel,VisionEncoderDecoderModel:()=>F.VisionEncoderDecoderModel,VitMatteForImageMatting:()=>F.VitMatteForImageMatting,VitMatteImageProcessor:()=>ir.VitMatteImageProcessor,VitMattePreTrainedModel:()=>F.VitMattePreTrainedModel,VitPoseForPoseEstimation:()=>F.VitPoseForPoseEstimation,VitPoseImageProcessor:()=>ir.VitPoseImageProcessor,VitPosePreTrainedModel:()=>F.VitPosePreTrainedModel,VitsModel:()=>F.VitsModel,VitsModelOutput:()=>F.VitsModelOutput,VitsPreTrainedModel:()=>F.VitsPreTrainedModel,VitsTokenizer:()=>ur.VitsTokenizer,Wav2Vec2BertForCTC:()=>F.Wav2Vec2BertForCTC,Wav2Vec2BertForSequenceClassification:()=>F.Wav2Vec2BertForSequenceClassification,Wav2Vec2BertModel:()=>F.Wav2Vec2BertModel,Wav2Vec2BertPreTrainedModel:()=>F.Wav2Vec2BertPreTrainedModel,Wav2Vec2CTCTokenizer:()=>ur.Wav2Vec2CTCTokenizer,Wav2Vec2FeatureExtractor:()=>wu.Wav2Vec2FeatureExtractor,Wav2Vec2ForAudioFrameClassification:()=>F.Wav2Vec2ForAudioFrameClassification,Wav2Vec2ForCTC:()=>F.Wav2Vec2ForCTC,Wav2Vec2ForSequenceClassification:()=>F.Wav2Vec2ForSequenceClassification,Wav2Vec2Model:()=>F.Wav2Vec2Model,Wav2Vec2PreTrainedModel:()=>F.Wav2Vec2PreTrainedModel,Wav2Vec2ProcessorWithLM:()=>pa.Wav2Vec2ProcessorWithLM,WavLMForAudioFrameClassification:()=>F.WavLMForAudioFrameClassification,WavLMForCTC:()=>F.WavLMForCTC,WavLMForSequenceClassification:()=>F.WavLMForSequenceClassification,WavLMForXVector:()=>F.WavLMForXVector,WavLMModel:()=>F.WavLMModel,WavLMPreTrainedModel:()=>F.WavLMPreTrainedModel,WeSpeakerFeatureExtractor:()=>wu.WeSpeakerFeatureExtractor,WeSpeakerResNetModel:()=>F.WeSpeakerResNetModel,WeSpeakerResNetPreTrainedModel:()=>F.WeSpeakerResNetPreTrainedModel,WhisperFeatureExtractor:()=>wu.WhisperFeatureExtractor,WhisperForConditionalGeneration:()=>F.WhisperForConditionalGeneration,WhisperModel:()=>F.WhisperModel,WhisperPreTrainedModel:()=>F.WhisperPreTrainedModel,WhisperProcessor:()=>pa.WhisperProcessor,WhisperTextStreamer:()=>zf.WhisperTextStreamer,WhisperTimeStampLogitsProcessor:()=>js.WhisperTimeStampLogitsProcessor,WhisperTokenizer:()=>ur.WhisperTokenizer,XLMForQuestionAnswering:()=>F.XLMForQuestionAnswering,XLMForSequenceClassification:()=>F.XLMForSequenceClassification,XLMForTokenClassification:()=>F.XLMForTokenClassification,XLMModel:()=>F.XLMModel,XLMPreTrainedModel:()=>F.XLMPreTrainedModel,XLMRobertaForMaskedLM:()=>F.XLMRobertaForMaskedLM,XLMRobertaForQuestionAnswering:()=>F.XLMRobertaForQuestionAnswering,XLMRobertaForSequenceClassification:()=>F.XLMRobertaForSequenceClassification,XLMRobertaForTokenClassification:()=>F.XLMRobertaForTokenClassification,XLMRobertaModel:()=>F.XLMRobertaModel,XLMRobertaPreTrainedModel:()=>F.XLMRobertaPreTrainedModel,XLMRobertaTokenizer:()=>ur.XLMRobertaTokenizer,XLMTokenizer:()=>ur.XLMTokenizer,XLMWithLMHeadModel:()=>F.XLMWithLMHeadModel,XVectorOutput:()=>F.XVectorOutput,YolosFeatureExtractor:()=>ir.YolosFeatureExtractor,YolosForObjectDetection:()=>F.YolosForObjectDetection,YolosImageProcessor:()=>ir.YolosImageProcessor,YolosModel:()=>F.YolosModel,YolosObjectDetectionOutput:()=>F.YolosObjectDetectionOutput,YolosPreTrainedModel:()=>F.YolosPreTrainedModel,ZeroShotAudioClassificationPipeline:()=>pn.ZeroShotAudioClassificationPipeline,ZeroShotClassificationPipeline:()=>pn.ZeroShotClassificationPipeline,ZeroShotImageClassificationPipeline:()=>pn.ZeroShotImageClassificationPipeline,ZeroShotObjectDetectionPipeline:()=>pn.ZeroShotObjectDetectionPipeline,bankers_round:()=>$o.bankers_round,cat:()=>qn.cat,cos_sim:()=>$o.cos_sim,dot:()=>$o.dot,dynamic_time_warping:()=>$o.dynamic_time_warping,env:()=>eg.env,full:()=>qn.full,full_like:()=>qn.full_like,getKeyValueShapes:()=>Df.getKeyValueShapes,hamming:()=>Sp.hamming,hanning:()=>Sp.hanning,interpolate:()=>qn.interpolate,interpolate_4d:()=>qn.interpolate_4d,interpolate_data:()=>$o.interpolate_data,is_chinese_char:()=>ur.is_chinese_char,layer_norm:()=>qn.layer_norm,log_softmax:()=>$o.log_softmax,magnitude:()=>$o.magnitude,matmul:()=>qn.matmul,max:()=>$o.max,mean:()=>qn.mean,mean_pooling:()=>qn.mean_pooling,medianFilter:()=>$o.medianFilter,mel_filter_bank:()=>Sp.mel_filter_bank,min:()=>$o.min,ones:()=>qn.ones,ones_like:()=>qn.ones_like,permute:()=>qn.permute,permute_data:()=>$o.permute_data,pipeline:()=>pn.pipeline,quantize_embeddings:()=>qn.quantize_embeddings,read_audio:()=>Sp.read_audio,rfft:()=>qn.rfft,round:()=>$o.round,softmax:()=>$o.softmax,spectrogram:()=>Sp.spectrogram,stack:()=>qn.stack,std_mean:()=>qn.std_mean,topk:()=>qn.topk,window_function:()=>Sp.window_function,zeros:()=>qn.zeros,zeros_like:()=>qn.zeros_like});var eg=Lr("./src/env.js"),pn=Lr("./src/pipelines.js"),F=Lr("./src/models.js"),ur=Lr("./src/tokenizers.js"),Df=Lr("./src/configs.js"),Sp=Lr("./src/utils/audio.js"),tg=Lr("./src/utils/image.js"),qn=Lr("./src/utils/tensor.js"),$o=Lr("./src/utils/maths.js"),rg=Lr("./src/base/feature_extraction_utils.js"),wu=Lr("./src/models/feature_extractors.js"),ng=Lr("./src/models/auto/feature_extraction_auto.js"),sg=Lr("./src/base/image_processors_utils.js"),ir=Lr("./src/models/image_processors.js"),og=Lr("./src/models/auto/image_processing_auto.js"),ig=Lr("./src/base/processing_utils.js"),pa=Lr("./src/models/processors.js"),ag=Lr("./src/models/auto/processing_auto.js"),zf=Lr("./src/generation/streamers.js"),zp=Lr("./src/generation/stopping_criteria.js"),js=Lr("./src/generation/logits_process.js");g.ASTFeatureExtractor;g.ASTForAudioClassification;g.ASTModel;g.ASTPreTrainedModel;g.AlbertForMaskedLM;g.AlbertForQuestionAnswering;g.AlbertForSequenceClassification;g.AlbertModel;g.AlbertPreTrainedModel;g.AlbertTokenizer;g.AudioClassificationPipeline;g.AutoConfig;g.AutoFeatureExtractor;g.AutoImageProcessor;g.AutoModel;g.AutoModelForAudioClassification;g.AutoModelForAudioFrameClassification;g.AutoModelForCTC;g.AutoModelForCausalLM;g.AutoModelForDepthEstimation;g.AutoModelForDocumentQuestionAnswering;g.AutoModelForImageClassification;g.AutoModelForImageFeatureExtraction;g.AutoModelForImageMatting;g.AutoModelForImageSegmentation;g.AutoModelForImageToImage;g.AutoModelForMaskGeneration;g.AutoModelForMaskedLM;g.AutoModelForNormalEstimation;g.AutoModelForObjectDetection;g.AutoModelForPoseEstimation;g.AutoModelForQuestionAnswering;g.AutoModelForSemanticSegmentation;g.AutoModelForSeq2SeqLM;g.AutoModelForSequenceClassification;g.AutoModelForSpeechSeq2Seq;g.AutoModelForTextToSpectrogram;g.AutoModelForTextToWaveform;g.AutoModelForTokenClassification;g.AutoModelForUniversalSegmentation;g.AutoModelForVision2Seq;g.AutoModelForXVector;g.AutoModelForZeroShotObjectDetection;var lg=g.AutoProcessor;g.AutoTokenizer;g.AutomaticSpeechRecognitionPipeline;g.BartForConditionalGeneration;g.BartForSequenceClassification;g.BartModel;g.BartPretrainedModel;g.BartTokenizer;g.BaseModelOutput;g.BaseStreamer;g.BeitFeatureExtractor;g.BeitForImageClassification;g.BeitModel;g.BeitPreTrainedModel;g.BertForMaskedLM;g.BertForQuestionAnswering;g.BertForSequenceClassification;g.BertForTokenClassification;g.BertModel;g.BertPreTrainedModel;g.BertTokenizer;g.BitImageProcessor;g.BlenderbotForConditionalGeneration;g.BlenderbotModel;g.BlenderbotPreTrainedModel;g.BlenderbotSmallForConditionalGeneration;g.BlenderbotSmallModel;g.BlenderbotSmallPreTrainedModel;g.BlenderbotSmallTokenizer;g.BlenderbotTokenizer;g.BloomForCausalLM;g.BloomModel;g.BloomPreTrainedModel;g.BloomTokenizer;g.CLIPFeatureExtractor;g.CLIPImageProcessor;g.CLIPModel;g.CLIPPreTrainedModel;g.CLIPSegForImageSegmentation;g.CLIPSegModel;g.CLIPSegPreTrainedModel;g.CLIPTextModel;g.CLIPTextModelWithProjection;g.CLIPTokenizer;var ug=g.CLIPVisionModel;g.CLIPVisionModelWithProjection;g.CamembertForMaskedLM;g.CamembertForQuestionAnswering;g.CamembertForSequenceClassification;g.CamembertForTokenClassification;g.CamembertModel;g.CamembertPreTrainedModel;g.CamembertTokenizer;g.CausalLMOutput;g.CausalLMOutputWithPast;g.ChineseCLIPFeatureExtractor;g.ChineseCLIPModel;g.ChineseCLIPPreTrainedModel;g.ClapAudioModelWithProjection;g.ClapFeatureExtractor;g.ClapModel;g.ClapPreTrainedModel;g.ClapTextModelWithProjection;g.ClassifierFreeGuidanceLogitsProcessor;g.CodeGenForCausalLM;g.CodeGenModel;g.CodeGenPreTrainedModel;g.CodeGenTokenizer;g.CodeLlamaTokenizer;g.CohereForCausalLM;g.CohereModel;g.CoherePreTrainedModel;g.CohereTokenizer;g.ConvBertForMaskedLM;g.ConvBertForQuestionAnswering;g.ConvBertForSequenceClassification;g.ConvBertForTokenClassification;g.ConvBertModel;g.ConvBertPreTrainedModel;g.ConvBertTokenizer;g.ConvNextFeatureExtractor;g.ConvNextForImageClassification;g.ConvNextImageProcessor;g.ConvNextModel;g.ConvNextPreTrainedModel;g.ConvNextV2ForImageClassification;g.ConvNextV2Model;g.ConvNextV2PreTrainedModel;g.DPTFeatureExtractor;g.DPTForDepthEstimation;g.DPTImageProcessor;g.DPTModel;g.DPTPreTrainedModel;g.DebertaForMaskedLM;g.DebertaForQuestionAnswering;g.DebertaForSequenceClassification;g.DebertaForTokenClassification;g.DebertaModel;g.DebertaPreTrainedModel;g.DebertaTokenizer;g.DebertaV2ForMaskedLM;g.DebertaV2ForQuestionAnswering;g.DebertaV2ForSequenceClassification;g.DebertaV2ForTokenClassification;g.DebertaV2Model;g.DebertaV2PreTrainedModel;g.DebertaV2Tokenizer;g.DecisionTransformerModel;g.DecisionTransformerPreTrainedModel;g.DeiTFeatureExtractor;g.DeiTForImageClassification;g.DeiTImageProcessor;g.DeiTModel;g.DeiTPreTrainedModel;g.DepthAnythingForDepthEstimation;g.DepthAnythingPreTrainedModel;g.DepthEstimationPipeline;g.DepthProForDepthEstimation;g.DepthProPreTrainedModel;g.DetrFeatureExtractor;g.DetrForObjectDetection;g.DetrForSegmentation;g.DetrImageProcessor;g.DetrModel;g.DetrObjectDetectionOutput;g.DetrPreTrainedModel;g.DetrSegmentationOutput;g.Dinov2ForImageClassification;g.Dinov2Model;g.Dinov2PreTrainedModel;g.DistilBertForMaskedLM;g.DistilBertForQuestionAnswering;g.DistilBertForSequenceClassification;g.DistilBertForTokenClassification;g.DistilBertModel;g.DistilBertPreTrainedModel;g.DistilBertTokenizer;g.DocumentQuestionAnsweringPipeline;g.DonutFeatureExtractor;g.DonutImageProcessor;g.DonutSwinModel;g.DonutSwinPreTrainedModel;g.EfficientNetForImageClassification;g.EfficientNetImageProcessor;g.EfficientNetModel;g.EfficientNetPreTrainedModel;g.ElectraForMaskedLM;g.ElectraForQuestionAnswering;g.ElectraForSequenceClassification;g.ElectraForTokenClassification;g.ElectraModel;g.ElectraPreTrainedModel;g.ElectraTokenizer;g.EosTokenCriteria;g.EsmForMaskedLM;g.EsmForSequenceClassification;g.EsmForTokenClassification;g.EsmModel;g.EsmPreTrainedModel;g.EsmTokenizer;g.FFT;g.FalconForCausalLM;g.FalconModel;g.FalconPreTrainedModel;g.FalconTokenizer;g.FastViTForImageClassification;g.FastViTModel;g.FastViTPreTrainedModel;g.FeatureExtractionPipeline;g.FeatureExtractor;g.FillMaskPipeline;g.Florence2ForConditionalGeneration;g.Florence2PreTrainedModel;g.Florence2Processor;g.ForcedBOSTokenLogitsProcessor;g.ForcedEOSTokenLogitsProcessor;g.GLPNFeatureExtractor;g.GLPNForDepthEstimation;g.GLPNModel;g.GLPNPreTrainedModel;g.GPT2LMHeadModel;g.GPT2Model;g.GPT2PreTrainedModel;g.GPT2Tokenizer;g.GPTBigCodeForCausalLM;g.GPTBigCodeModel;g.GPTBigCodePreTrainedModel;g.GPTJForCausalLM;g.GPTJModel;g.GPTJPreTrainedModel;g.GPTNeoForCausalLM;g.GPTNeoModel;g.GPTNeoPreTrainedModel;g.GPTNeoXForCausalLM;g.GPTNeoXModel;g.GPTNeoXPreTrainedModel;g.GPTNeoXTokenizer;g.Gemma2ForCausalLM;g.Gemma2Model;g.Gemma2PreTrainedModel;g.GemmaForCausalLM;g.GemmaModel;g.GemmaPreTrainedModel;g.GemmaTokenizer;g.GraniteForCausalLM;g.GraniteModel;g.GranitePreTrainedModel;g.Grok1Tokenizer;g.GroupViTModel;g.GroupViTPreTrainedModel;g.HerbertTokenizer;g.HieraForImageClassification;g.HieraModel;g.HieraPreTrainedModel;g.HubertForCTC;g.HubertForSequenceClassification;g.HubertModel;g.HubertPreTrainedModel;g.ImageClassificationPipeline;g.ImageFeatureExtractionPipeline;g.ImageFeatureExtractor;g.ImageMattingOutput;g.ImageProcessor;g.ImageSegmentationPipeline;g.ImageToImagePipeline;g.ImageToTextPipeline;g.InterruptableStoppingCriteria;g.JAISLMHeadModel;g.JAISModel;g.JAISPreTrainedModel;g.JinaCLIPImageProcessor;g.JinaCLIPModel;g.JinaCLIPPreTrainedModel;g.JinaCLIPProcessor;g.JinaCLIPTextModel;g.JinaCLIPVisionModel;g.LlamaForCausalLM;g.LlamaModel;g.LlamaPreTrainedModel;g.LlamaTokenizer;g.LlavaForConditionalGeneration;g.LlavaOnevisionForConditionalGeneration;g.LlavaOnevisionImageProcessor;g.LlavaPreTrainedModel;g.LogitsProcessor;g.LogitsProcessorList;g.LogitsWarper;g.LongT5ForConditionalGeneration;g.LongT5Model;g.LongT5PreTrainedModel;g.M2M100ForConditionalGeneration;g.M2M100Model;g.M2M100PreTrainedModel;g.M2M100Tokenizer;g.MBart50Tokenizer;g.MBartForCausalLM;g.MBartForConditionalGeneration;g.MBartForSequenceClassification;g.MBartModel;g.MBartPreTrainedModel;g.MBartTokenizer;g.MPNetForMaskedLM;g.MPNetForQuestionAnswering;g.MPNetForSequenceClassification;g.MPNetForTokenClassification;g.MPNetModel;g.MPNetPreTrainedModel;g.MPNetTokenizer;g.MT5ForConditionalGeneration;g.MT5Model;g.MT5PreTrainedModel;g.MarianMTModel;g.MarianModel;g.MarianPreTrainedModel;g.MarianTokenizer;g.Mask2FormerImageProcessor;g.MaskFormerFeatureExtractor;g.MaskFormerForInstanceSegmentation;g.MaskFormerImageProcessor;g.MaskFormerModel;g.MaskFormerPreTrainedModel;g.MaskedLMOutput;g.MaxLengthCriteria;g.MgpstrForSceneTextRecognition;g.MgpstrModelOutput;g.MgpstrPreTrainedModel;g.MgpstrProcessor;g.MgpstrTokenizer;g.MinLengthLogitsProcessor;g.MinNewTokensLengthLogitsProcessor;g.MistralForCausalLM;g.MistralModel;g.MistralPreTrainedModel;g.MobileBertForMaskedLM;g.MobileBertForQuestionAnswering;g.MobileBertForSequenceClassification;g.MobileBertModel;g.MobileBertPreTrainedModel;g.MobileBertTokenizer;g.MobileLLMForCausalLM;g.MobileLLMModel;g.MobileLLMPreTrainedModel;g.MobileNetV1FeatureExtractor;g.MobileNetV1ForImageClassification;g.MobileNetV1ImageProcessor;g.MobileNetV1Model;g.MobileNetV1PreTrainedModel;g.MobileNetV2FeatureExtractor;g.MobileNetV2ForImageClassification;g.MobileNetV2ImageProcessor;g.MobileNetV2Model;g.MobileNetV2PreTrainedModel;g.MobileNetV3FeatureExtractor;g.MobileNetV3ForImageClassification;g.MobileNetV3ImageProcessor;g.MobileNetV3Model;g.MobileNetV3PreTrainedModel;g.MobileNetV4FeatureExtractor;g.MobileNetV4ForImageClassification;g.MobileNetV4ImageProcessor;g.MobileNetV4Model;g.MobileNetV4PreTrainedModel;g.MobileViTFeatureExtractor;g.MobileViTForImageClassification;g.MobileViTImageProcessor;g.MobileViTModel;g.MobileViTPreTrainedModel;g.MobileViTV2ForImageClassification;g.MobileViTV2Model;g.MobileViTV2PreTrainedModel;g.ModelOutput;g.Moondream1ForConditionalGeneration;g.MptForCausalLM;g.MptModel;g.MptPreTrainedModel;g.MultiModalityCausalLM;g.MultiModalityPreTrainedModel;g.MusicgenForCausalLM;g.MusicgenForConditionalGeneration;g.MusicgenModel;g.MusicgenPreTrainedModel;g.NllbTokenizer;g.NoBadWordsLogitsProcessor;g.NoRepeatNGramLogitsProcessor;g.NomicBertModel;g.NomicBertPreTrainedModel;g.NougatImageProcessor;g.NougatTokenizer;g.OPTForCausalLM;g.OPTModel;g.OPTPreTrainedModel;g.ObjectDetectionPipeline;g.OlmoForCausalLM;g.OlmoModel;g.OlmoPreTrainedModel;g.OpenELMForCausalLM;g.OpenELMModel;g.OpenELMPreTrainedModel;g.OwlViTFeatureExtractor;g.OwlViTForObjectDetection;g.OwlViTImageProcessor;g.OwlViTModel;g.OwlViTPreTrainedModel;g.OwlViTProcessor;g.Owlv2ForObjectDetection;g.Owlv2ImageProcessor;g.Owlv2Model;g.Owlv2PreTrainedModel;g.PatchTSMixerForPrediction;g.PatchTSMixerModel;g.PatchTSMixerPreTrainedModel;g.PatchTSTForPrediction;g.PatchTSTModel;g.PatchTSTPreTrainedModel;g.Phi3ForCausalLM;g.Phi3Model;g.Phi3PreTrainedModel;g.PhiForCausalLM;g.PhiModel;g.PhiPreTrainedModel;g.Pipeline;g.PreTrainedModel;g.PreTrainedTokenizer;g.PretrainedConfig;g.PretrainedMixin;g.Processor;g.PvtForImageClassification;g.PvtImageProcessor;g.PvtModel;g.PvtPreTrainedModel;g.PyAnnoteFeatureExtractor;g.PyAnnoteForAudioFrameClassification;g.PyAnnoteModel;g.PyAnnotePreTrainedModel;g.PyAnnoteProcessor;g.QuestionAnsweringModelOutput;g.QuestionAnsweringPipeline;g.Qwen2ForCausalLM;g.Qwen2Model;g.Qwen2PreTrainedModel;g.Qwen2Tokenizer;g.Qwen2VLForConditionalGeneration;g.Qwen2VLImageProcessor;g.Qwen2VLPreTrainedModel;g.Qwen2VLProcessor;g.RTDetrForObjectDetection;g.RTDetrImageProcessor;g.RTDetrModel;g.RTDetrObjectDetectionOutput;g.RTDetrPreTrainedModel;var Bf=g.RawImage;g.RepetitionPenaltyLogitsProcessor;g.ResNetForImageClassification;g.ResNetModel;g.ResNetPreTrainedModel;g.RoFormerForMaskedLM;g.RoFormerForQuestionAnswering;g.RoFormerForSequenceClassification;g.RoFormerForTokenClassification;g.RoFormerModel;g.RoFormerPreTrainedModel;g.RoFormerTokenizer;g.RobertaForMaskedLM;g.RobertaForQuestionAnswering;g.RobertaForSequenceClassification;g.RobertaForTokenClassification;g.RobertaModel;g.RobertaPreTrainedModel;g.RobertaTokenizer;g.SamImageProcessor;g.SamImageSegmentationOutput;g.SamModel;g.SamPreTrainedModel;g.SamProcessor;g.SapiensForDepthEstimation;g.SapiensForNormalEstimation;g.SapiensForSemanticSegmentation;g.SapiensPreTrainedModel;g.SeamlessM4TFeatureExtractor;g.SegformerFeatureExtractor;g.SegformerForImageClassification;g.SegformerForSemanticSegmentation;g.SegformerImageProcessor;g.SegformerModel;g.SegformerPreTrainedModel;g.Seq2SeqLMOutput;g.SequenceClassifierOutput;g.SiglipImageProcessor;g.SiglipModel;g.SiglipPreTrainedModel;g.SiglipTextModel;g.SiglipTokenizer;g.SiglipVisionModel;g.SpeechT5FeatureExtractor;g.SpeechT5ForSpeechToText;g.SpeechT5ForTextToSpeech;g.SpeechT5HifiGan;g.SpeechT5Model;g.SpeechT5PreTrainedModel;g.SpeechT5Processor;g.SpeechT5Tokenizer;g.SqueezeBertForMaskedLM;g.SqueezeBertForQuestionAnswering;g.SqueezeBertForSequenceClassification;g.SqueezeBertModel;g.SqueezeBertPreTrainedModel;g.SqueezeBertTokenizer;g.StableLmForCausalLM;g.StableLmModel;g.StableLmPreTrainedModel;g.Starcoder2ForCausalLM;g.Starcoder2Model;g.Starcoder2PreTrainedModel;g.StoppingCriteria;g.StoppingCriteriaList;g.SummarizationPipeline;g.SuppressTokensAtBeginLogitsProcessor;g.Swin2SRForImageSuperResolution;g.Swin2SRImageProcessor;g.Swin2SRModel;g.Swin2SRPreTrainedModel;g.SwinForImageClassification;g.SwinModel;g.SwinPreTrainedModel;g.T5ForConditionalGeneration;g.T5Model;g.T5PreTrainedModel;g.T5Tokenizer;g.TableTransformerForObjectDetection;g.TableTransformerModel;g.TableTransformerObjectDetectionOutput;g.TableTransformerPreTrainedModel;g.TemperatureLogitsWarper;g.Tensor;g.Text2TextGenerationPipeline;g.TextClassificationPipeline;g.TextGenerationPipeline;g.TextStreamer;g.TextToAudioPipeline;g.TokenClassificationPipeline;g.TokenClassifierOutput;g.TokenizerModel;g.TopKLogitsWarper;g.TopPLogitsWarper;g.TrOCRForCausalLM;g.TrOCRPreTrainedModel;g.TranslationPipeline;g.UniSpeechForCTC;g.UniSpeechForSequenceClassification;g.UniSpeechModel;g.UniSpeechPreTrainedModel;g.UniSpeechSatForAudioFrameClassification;g.UniSpeechSatForCTC;g.UniSpeechSatForSequenceClassification;g.UniSpeechSatModel;g.UniSpeechSatPreTrainedModel;g.VLChatProcessor;g.VLMImageProcessor;g.ViTFeatureExtractor;g.ViTForImageClassification;g.ViTImageProcessor;g.ViTMAEModel;g.ViTMAEPreTrainedModel;g.ViTMSNForImageClassification;g.ViTMSNModel;g.ViTMSNPreTrainedModel;g.ViTModel;g.ViTPreTrainedModel;g.VisionEncoderDecoderModel;g.VitMatteForImageMatting;g.VitMatteImageProcessor;g.VitMattePreTrainedModel;g.VitPoseForPoseEstimation;g.VitPoseImageProcessor;g.VitPosePreTrainedModel;g.VitsModel;g.VitsModelOutput;g.VitsPreTrainedModel;g.VitsTokenizer;g.Wav2Vec2BertForCTC;g.Wav2Vec2BertForSequenceClassification;g.Wav2Vec2BertModel;g.Wav2Vec2BertPreTrainedModel;g.Wav2Vec2CTCTokenizer;g.Wav2Vec2FeatureExtractor;g.Wav2Vec2ForAudioFrameClassification;g.Wav2Vec2ForCTC;g.Wav2Vec2ForSequenceClassification;g.Wav2Vec2Model;g.Wav2Vec2PreTrainedModel;g.Wav2Vec2ProcessorWithLM;g.WavLMForAudioFrameClassification;g.WavLMForCTC;g.WavLMForSequenceClassification;g.WavLMForXVector;g.WavLMModel;g.WavLMPreTrainedModel;g.WeSpeakerFeatureExtractor;g.WeSpeakerResNetModel;g.WeSpeakerResNetPreTrainedModel;g.WhisperFeatureExtractor;g.WhisperForConditionalGeneration;g.WhisperModel;g.WhisperPreTrainedModel;g.WhisperProcessor;g.WhisperTextStreamer;g.WhisperTimeStampLogitsProcessor;g.WhisperTokenizer;g.XLMForQuestionAnswering;g.XLMForSequenceClassification;g.XLMForTokenClassification;g.XLMModel;g.XLMPreTrainedModel;g.XLMRobertaForMaskedLM;g.XLMRobertaForQuestionAnswering;g.XLMRobertaForSequenceClassification;g.XLMRobertaForTokenClassification;g.XLMRobertaModel;g.XLMRobertaPreTrainedModel;g.XLMRobertaTokenizer;g.XLMTokenizer;g.XLMWithLMHeadModel;g.XVectorOutput;g.YolosFeatureExtractor;g.YolosForObjectDetection;g.YolosImageProcessor;g.YolosModel;g.YolosObjectDetectionOutput;g.YolosPreTrainedModel;g.ZeroShotAudioClassificationPipeline;g.ZeroShotClassificationPipeline;g.ZeroShotImageClassificationPipeline;g.ZeroShotObjectDetectionPipeline;g.bankers_round;g.cat;g.cos_sim;g.dot;g.dynamic_time_warping;g.env;g.full;g.full_like;g.getKeyValueShapes;g.hamming;g.hanning;g.interpolate;g.interpolate_4d;g.interpolate_data;g.is_chinese_char;g.layer_norm;g.log_softmax;g.magnitude;g.matmul;g.max;g.mean;g.mean_pooling;g.medianFilter;g.mel_filter_bank;g.min;g.ones;g.ones_like;g.permute;g.permute_data;g.pipeline;g.quantize_embeddings;g.read_audio;g.rfft;g.round;g.softmax;g.spectrogram;g.stack;g.std_mean;g.topk;g.window_function;g.zeros;g.zeros_like;let of=null,af=null;const gm="Xenova/clip-vit-base-patch16",ym={revision:"main",format:"onnx",quantized:!1},cg=async()=>{of||(of=await ug.from_pretrained(gm,{...ym,device:"webgpu",progress_callback:ke=>{console.log(`Loading model: ${ke}%`)}})),af||(af=await lg.from_pretrained(gm,{...ym,device:"webgpu"}))},dg=async ke=>{if(typeof ke=="string")if(ke.startsWith("data:")){const f=await(await fetch(ke)).blob();return await Bf.fromBlob(f)}else{const f=await(await fetch(ke)).blob();return await Bf.fromBlob(f)}else return await Bf.fromBlob(ke)},pg=async ke=>{if(console.log("[@UI/embeddings] Starting embedding computation"),console.log("[@UI/embeddings] Input type:",typeof ke),console.log("[@UI/embeddings] Input value:",ke),!navigator.gpu)throw new Error("WebGPU not supported in this browser.");if(await cg(),console.log("[@UI/embeddings] Models initialized successfully"),!of||!af)throw new Error("Failed to initialize models");console.log("[@UI/embeddings] Processing image...");const V=await dg(ke);console.log("[@UI/embeddings] Image processed successfully"),console.log("[@UI/embeddings] Running through processor...");const f=await af(V);console.log("[@UI/embeddings] Image processed through CLIP processor"),console.log("[@UI/embeddings] Computing embeddings...");const{image_embeds:P}=await of(f);console.log("[@UI/embeddings] Raw embeddings computed"),console.log("[@UI/embeddings] Normalizing embeddings...");const R=P.normalize(),Q=R.tolist();return P.dispose(),R.dispose(),console.log("[@UI/embeddings] Embedding computation complete"),console.log("[@UI/embeddings] Embedding dimensions:",Q[0].length),console.log("[@UI/embeddings] First few values:",Q[0].slice(0,5)),Q[0]};function fg(){var fe,ge;const[ke,V]=fa.useState("initializing"),[f,P]=fa.useState(null),[R,Q]=fa.useState({state:{type:"Unbound"},coordinator:null,supported_models:["clip-vit-base-patch16"]}),[se,oe]=fa.useState(null),E=fa.useRef(null),[C,k]=fa.useState({totalJobs:0,lastJobTime:null});fa.useEffect(()=>{async function le(){var q,ie;try{const pe=await((q=navigator.gpu)==null?void 0:q.requestAdapter());if(!pe)throw new Error("No WebGPU adapter found");const X=await pe.requestDevice();V("ready");const W=new Z_({nodeId:(ie=window.our)==null?void 0:ie.node,processId:Rf,onMessage:b=>{A(b)},onOpen:()=>{V("ready"),W.send({data:{message_type:"still_bound",data:"lol"}})},onClose:()=>{},onError:b=>{console.error("[ProviderDashboard] WebSocket error:",b),V("error"),P(b.toString())}});oe(W),E.current=W}catch(pe){console.error("[ProviderDashboard] Initialization error:",pe),V("error"),P(pe.message)}}return le(),()=>{E.current=null,oe(null)}},[]);const A=async le=>{var ie,pe,X;const q=typeof le=="string"?JSON.parse(le):le;switch(q.type){case"state_update":const W=q.state.state,b={type:W,...W==="Working"?{request:q.state.request}:{},...W==="Failed"?{error:q.state.error}:{}};if(Q(z=>({...z,state:b,coordinator:q.coordinator??z.coordinator})),!((ie=q.state)!=null&&ie.type))break;break;case"work_request":if(!((pe=q.data)!=null&&pe.uri)){console.warn("Invalid work request - missing URI");break}if(!E.current){console.error("No API connection available");break}try{const z=await pg(q.data.uri);(X=E.current)==null||X.send({data:{message_type:"work_result",data:z}}),k(L=>({totalJobs:L.totalJobs+1,lastJobTime:new Date().toLocaleTimeString()}))}catch(z){console.error("Work processing error:",z),E.current&&E.current.send({data:{message_type:"work_failed",data:{error:z.message}}})}break;default:console.warn("Unknown message type:",q.type)}},$=async le=>{var q;try{const ie=await fetch(`/${Rf}/register_provider`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({coordinator_address:le})});if(!ie.ok)throw new Error(await ie.text());(q=E.current)==null||q.send({data:{message_type:"still_bound",data:le}})}catch(ie){console.error("Registration error:",ie),Q(pe=>({...pe,state:{type:"Failed",error:{id:"",error:ie.message,timestamp:Date.now()}}}))}};fa.useEffect(()=>{},[R]);const ae=()=>R.state.type==="Unbound"?null:Mr.jsxs("div",{style:{display:"flex",gap:"0.5rem"},children:[R.state.type!=="Offline"&&Mr.jsx("button",{onClick:()=>{var le;(le=E.current)==null||le.send({data:{message_type:"go_offline",data:"lol"}})},style:{padding:"0.5rem 1rem",backgroundColor:"#F43F5E",color:"white",borderRadius:"0.25rem",fontSize:"0.875rem",transition:"all 150ms"},onMouseOver:le=>le.currentTarget.style.backgroundColor="#E11D48",onMouseOut:le=>le.currentTarget.style.backgroundColor="#F43F5E",children:"Go Offline"}),R.state.type==="Offline"&&Mr.jsx("button",{onClick:()=>{var le;(le=E.current)==null||le.send({data:{message_type:"still_bound",data:"lol"}})},style:{padding:"0.5rem 1rem",backgroundColor:"#22C55E",color:"white",borderRadius:"0.25rem",fontSize:"0.875rem",transition:"all 150ms"},onMouseOver:le=>le.currentTarget.style.backgroundColor="#16A34A",onMouseOut:le=>le.currentTarget.style.backgroundColor="#22C55E",children:"Go Online"}),Mr.jsx("button",{onClick:()=>{var le;(le=E.current)==null||le.send({data:{message_type:"still_bound",data:"lol"}})},style:{padding:"0.5rem 1rem",backgroundColor:"#3B82F6",color:"white",borderRadius:"0.25rem",fontSize:"0.875rem",transition:"all 150ms"},onMouseOver:le=>le.currentTarget.style.backgroundColor="#2563EB",onMouseOut:le=>le.currentTarget.style.backgroundColor="#3B82F6",children:"Ping Coordinator"})]});return Mr.jsx("div",{style:{display:"flex",justifyContent:"center",alignItems:"center",minHeight:"100vh",width:"100vw",backgroundColor:"#F9FAFB",padding:0,margin:0,position:"absolute",left:0,top:0},children:Mr.jsxs("div",{style:{width:"100%",maxWidth:"675px",display:"flex",flexDirection:"column",gap:"1.5rem",padding:"2rem"},children:[Mr.jsx("h3",{style:{fontSize:"1.5rem",fontWeight:"bold",color:"#1F2937",textAlign:"center",margin:0},children:"Embedding Provider Node"}),Mr.jsx("div",{style:{fontSize:"0.875rem",color:"#4B5563",textAlign:"center",margin:0},children:(fe=window.our)==null?void 0:fe.node}),Mr.jsx("div",{style:{backgroundColor:"white",borderRadius:"0.5rem",boxShadow:"0 1px 3px 0 rgba(0, 0, 0, 0.1)",padding:"1rem"},children:Mr.jsxs("div",{style:{display:"flex",alignItems:"center",gap:"0.5rem"},children:[Mr.jsx("div",{style:{width:"0.75rem",height:"0.75rem",borderRadius:"9999px",backgroundColor:ke==="ready"?"#22C55E":ke==="error"?"#EF4444":"#EAB308"}}),Mr.jsx("span",{children:ke==="ready"?"WebGPU - clip-vit-base-patch16":ke==="error"?`WebGPU Error: ${f}`:"Initializing WebGPU..."})]})}),Mr.jsxs("div",{style:{padding:"1rem",backgroundColor:R.state.type==="Unbound"?"#FEF3C7":R.state.type==="Idle"?"#DCFCE7":R.state.type==="Offline"?"#FEE2E2":R.state.type==="Working"?"#DBEAFE":"#FEF2F2",borderRadius:"0.5rem",display:"flex",justifyContent:"space-between",alignItems:"center"},children:[Mr.jsx("div",{style:{display:"flex",alignItems:"center",gap:"1rem"},children:Mr.jsxs("div",{children:[Mr.jsx("h2",{style:{fontSize:"1.25rem",fontWeight:"bold"},children:R.state.type==="Unbound"?"Unbound":R.state.type==="Idle"?"Idle":R.state.type==="Offline"?"Offline":R.state.type==="Working"?"Working":"Error"}),R.state.type!=="Unbound"&&Mr.jsxs("p",{style:{color:"#4B5563",marginTop:"0.25rem"},children:["Coordinator: ",R.state.type==="Idle"?(ge=R.coordinator)==null?void 0:ge.split("@")[0]:""]})]})}),ae()]}),Mr.jsxs("div",{style:{backgroundColor:"white",borderRadius:"0.5rem",boxShadow:"0 1px 3px 0 rgba(0, 0, 0, 0.1)",padding:"1.5rem"},children:[Mr.jsx("div",{style:{display:"flex",alignItems:"center",justifyContent:"space-between",marginBottom:"1rem"}}),R.state.type==="Unbound"&&Mr.jsx("h3",{style:{fontSize:"1.125rem",fontWeight:"600"},children:"Coordinators"}),R.state.type==="Unbound"&&Mr.jsx(hg,{onSelect:$}),R.state.type==="Working"&&Mr.jsx("div",{style:{width:"100%",backgroundColor:"#E5E7EB",borderRadius:"9999px",height:"0.625rem"},children:Mr.jsx("div",{style:{backgroundColor:"#2563EB",height:"0.625rem",borderRadius:"9999px",width:`${R.state.progress}%`,transition:"all 500ms"}})}),R.state.type==="Failed"&&Mr.jsx("div",{style:{marginTop:"1rem",padding:"1rem",backgroundColor:"#FEF2F2",border:"1px solid #FEE2E2",borderRadius:"0.25rem",color:"#B91C1C"},children:R.state.type==="Failed"&&R.state.error.error}),R.state.type!=="Unbound"&&Mr.jsx("div",{style:{marginTop:"1rem",paddingTop:"1rem",borderTop:"1px solid #E5E7EB"},children:Mr.jsxs("div",{style:{fontSize:"0.875rem",color:"#4B5563"},children:[Mr.jsxs("p",{children:["Total jobs completed: ",C.totalJobs]}),C.lastJobTime&&Mr.jsxs("p",{children:["Last job completed: ",C.lastJobTime]})]})})]})]})})}function hg({onSelect:ke}){const[V,f]=fa.useState([]),[P,R]=fa.useState(!0);return fa.useEffect(()=>{fetch(`/${Rf}/coordinators`,{method:"POST",headers:{"Content-Type":"application/json"}}).then(Q=>Q.json()).then(f).finally(()=>R(!1))},[]),P?Mr.jsx("div",{style:{animation:"pulse 2s infinite",backgroundColor:"#F3F4F6",height:"8rem",borderRadius:"0.25rem"}}):Mr.jsx("div",{style:{display:"flex",flexDirection:"column",gap:"1rem"},children:V.map(Q=>Mr.jsxs("button",{style:{width:"100%",padding:"1rem",backgroundColor:"white",border:"1px solid #E5E7EB",borderRadius:"0.5rem",textAlign:"left",transition:"background-color 150ms"},onMouseOver:se=>se.currentTarget.style.backgroundColor="#F9FAFB",onMouseOut:se=>se.currentTarget.style.backgroundColor="white",onClick:()=>ke(Q.address),children:[Mr.jsx("h3",{style:{fontWeight:"500"},children:Q.address}),Mr.jsxs("div",{style:{marginTop:"0.5rem",fontSize:"0.875rem",color:"#4B5563"},children:[Mr.jsx("h4",{style:{fontWeight:"500"},children:"Required Models:"}),Mr.jsx("ul",{style:{listStyleType:"disc",paddingLeft:"1rem",marginTop:"0.25rem"},children:Q.requiredModels.map(se=>Mr.jsx("li",{children:se},se))})]})]},Q.address))})}function mg(){var ke;return Mr.jsxs("div",{children:[Mr.jsxs("div",{style:{color:"#9CA3AF",fontSize:"0.875rem",fontFamily:"system-ui, -apple-system, sans-serif",letterSpacing:"0.05em",fontWeight:500,textTransform:"lowercase",marginBottom:"3rem",textAlign:"right"},children:["embedding provider ",(ke=window.our)==null?void 0:ke.node]}),Mr.jsx(fg,{})]})}X_.createRoot(document.getElementById("root")).render(Mr.jsx(mg,{}));
